[{"title":"AtCoder Beginner Contest 252","url":"/2022/05/26/atcoder-abc-252/","content":"\n[比赛链接](https://atcoder.jp/contests/abc252)\n\n<!-- more -->\n\n# D Distinct Trio\n\n## Description\n\n[题目链接](https://atcoder.jp/contests/abc252/tasks/abc252_d)\n\n## Solution\n\n考虑容斥，设 $pre[a_i]$ 表示 $i$ 之前和 $a_i$ 相同的数的个数，$suf[a_i]$ 表示 $i$ 之后和 $a_i$ 相同的数的个数。对于给定的 $j$，答案可以表示为 $(j - 1)*(n - j) - \\sum_k pre[k]suf[k] - pre[a_j] * (n - j) - suf[a_j] * (j - 1) + 2 * pre[a_j] * suf[a_j]$，即从总的方案数中扣除 $a_i$ 和 $a_k$ 相同的方案数，再扣除 $a_i = a_j$ 或 $a_j = a_k$ 的方案数。由于 $a_i = a_j = a_k$ 的方案数被扣除了两次，因此要加回去。$pre$，$suf$ 以及 $\\sum_k pre[k]suf[k]$ 可以在顺序遍历时 $O(1)$ 更新，因此总的时间复杂度为 $O(n)$。\n\n## Code\n\n```cpp Distinct Trio\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define int long long\n\nusing namespace std;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, T, a[MAXN], pre[MAXN], suf[MAXN];\nint ans;\n\nsigned main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        if (i < n) pre[a[i]]++;\n    }\n    int eq = 0, ans = 0;\n    for (int i = n - 1; i >= 2; i--) {\n        eq -= suf[a[i]] * pre[a[i]];\n        if (a[i] != a[i + 1]) eq -= suf[a[i + 1]] * pre[a[i + 1]];\n        suf[a[i + 1]]++;\n        pre[a[i]]--;\n        eq += suf[a[i]] * pre[a[i]];\n        if (a[i] != a[i + 1]) eq += suf[a[i + 1]] * pre[a[i + 1]];\n        int tmp = (i - 1) * (n - i) - eq;\n        tmp -= (i - 1) * suf[a[i]];\n        tmp -= (n - i) * pre[a[i]];\n        tmp += suf[a[i]] * pre[a[i]] * 2;\n        ans += tmp;\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n# E Road Reduction\n\n## Description\n\n[题目链接](https://atcoder.jp/contests/abc252/tasks/abc252_e)\n\n## Solution\n\n设 $D_i$ 表示从节点 $1$ 到节点 $i$ 的最短路，则对 $\\forall i$，有 $d_i \\ge D_i$。因此，需要保留的道路是最短路树上的边，在求最短路时记录起点到各个节点最短路的最后一条边即可。\n\n## Code\n\n```cpp Road Reduction\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\n#define int long long\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, T;\nint dis[MAXN], lastEdge[MAXN];\nbool vis[MAXN];\nvector<tuple<int, int, int>> G[MAXN];\n\nsigned main() {\n    // freopen(\"1.in\", \"r\", stdin);\n    ios::sync_with_stdio(false), cin.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        G[u].push_back({v, w, i});\n        G[v].push_back({u, w, i});\n    }\n    for (int i = 2; i <= n; i++) dis[i] = LONG_LONG_MAX;\n    priority_queue<pair<int, int>> q;\n    q.push({0, 1});\n    while (!q.empty()) {\n        auto [d, cur] = q.top();\n        q.pop();\n        if (vis[cur]) continue;\n        vis[cur] = 1;\n        for (auto& [to, w, i] : G[cur]) {\n            if (dis[to] > dis[cur] + w) {\n                dis[to] = dis[cur] + w;\n                lastEdge[to] = i;\n                if (!vis[to]) q.push({-dis[to], to});\n            }\n        }\n    }\n    for (int i = 2; i <= n; i++) cout << lastEdge[i] << \" \";\n    return 0;\n}\n```\n\n# F Bread\n\n## Description\n\n[题目链接](https://atcoder.jp/contests/abc252/tasks/abc252_f)\n\n## Solution\n倒着考虑，问题转化为求合并面包的最小代价，每次选取代价最小的两块合并即可。需要注意的是，如果有剩下的面包，那么剩下的面包也需要被合并。显然剩下的面包只有一块，因为对剩下的面包再做分割会增大合并的代价。\n## Code\n\n```cpp Bread\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nLL n, l, a[MAXN];\n\nsigned main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    cin >> n >> l;\n    priority_queue<LL, vector<LL>, greater<LL>> q;\n    LL sum = 0;\n    for (int i = 1; i <= n; i++) cin >> a[i], q.push(a[i]), sum += a[i];\n    if (sum != l) q.push(l - sum);\n\n    LL ans = 0;\n    while (q.size() >= 2) {\n        LL v1 = q.top();\n        q.pop();\n        LL v2 = q.top();\n        q.pop();\n        ans += v1 + v2;\n        q.push(v1 + v2);\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n# G Pre-Order\n\n## Description\n\n[题目链接](https://atcoder.jp/contests/abc252/tasks/abc252_g)\n\n## Solution\n$a[l...r]$ 表示了以 $a[l]$ 为根的树的先序遍历结果。我们将根去掉，就得到了 $a[l + 1...r]$，它表示 $a[l]$ 的子树构成的森林的先序遍历结果，且子树的根节点的编号是递增的。\n\n根据上述观察结果，考虑动态规划。设 $t[l][r]$ 表示先序遍历为 $a[l...r]$ 的树的个数，$f[l][r]$ 表示先序遍历为 $a[l...r]$ 的森林的个数。那么有如下状态转移方程：\n-  $t[l][r] = f[l + 1][r]$\n- $f[l][r] = \\sum \\limits_{k = l + 1}^{r} t[l][k - 1] * f[k][r] * (a[l] < a[k])$。\n\n最终答案为 $t[1][n]$。\n## Code\n\n```cpp Pre-Order\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 5E2 + 5;\nconst int MOD = 998244353;\nint n, a[MAXN];\nint t[MAXN][MAXN], f[MAXN][MAXN];\n\nvoid add(int& a, int b) { a = (a + b) % MOD; }\n\nsigned main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i], t[i][i] = 1, f[i][i] = 1;\n    for (int len = 2; len <= n; len++) {\n        for (int l = 1; l + len - 1 <= n; l++) {\n            int r = l + len - 1;\n            add(t[l][r], f[l + 1][r]);\n            for (int k = l + 1; k <= r; k++)\n                if (a[l] < a[k])\n                    add(f[l][r], 1ll * t[l][k - 1] * f[k][r] % MOD);\n            add(f[l][r], t[l][r]);\n        }\n    }\n    cout << t[1][n];\n    return 0;\n}\n```\n","tags":["区间DP","动态规划","最短路","贪心","容斥原理","contest","优先队列"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 250","url":"/2022/05/12/atcoder-abc-250/","content":"\n[比赛链接](https://atcoder.jp/contests/abc250)\n\n<!-- more -->\n\n# D 250-like Number\n\n## Description\n\n[题目链接](https://atcoder.jp/contests/abc250/tasks/abc250_d)\n\n## Solution\n\n显然 $q$ 一定是 $[1, \\sqrt[3]{N}]$ 内的质数。\n\n首先筛出这个范围内的质数，从小到大存入数组 $a$ 中。\n\n设质数个数为 $n$, 记 $i = 1, j = n$。考虑到 $q$ 增大时 $p$ 的取值范围一定减小，反复进行如下操作直到 $i = n + 1$ 或 $j=0$：\n\n- 当 $a_i^3*a_j>N$ 时，令 $j = j - 1$；\n- 取 $q = a_i$ ，则满足条件的 $250$ 数有 $min(i - 1, j)$ 个，记入答案；\n- $i = i + 1$；\n\n## Code\n\n```cpp 250-like Number\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1E6 + 5;\nconst int MOD = 1E9 + 7;\nLL n;\nvector<int> prime, isprime;\n\nvoid getPrime(int m) {\n    isprime.resize(m + 1);\n    fill(isprime.begin() + 2, isprime.end(), 1);\n    for (int i = 2; i <= m; i++) {\n        if (isprime[i]) prime.push_back(i);\n        for (int j = 0; j < prime.size() && prime[j] * i <= m; j++) {\n            isprime[i * prime[j]] = 0;\n            if (i % prime[j] == 0) break;\n        }\n    }\n}\n\nsigned main() {\n    cin >> n;\n    int m = pow(n, 1.0 / 3) + 1;\n    getPrime(m);\n    int i = 0, j = prime.size() - 1;\n    LL ans = 0;\n    while (i <= (int)prime.size() - 1 && j >= 0) {\n        while (j >= 0 && 1ll * prime[i] * prime[i] * prime[i] * prime[j] > n)\n            j--;\n        ans += min(i, j + 1);\n        i++;\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n# E Prefix Equality\n\n## Description\n\n[题目链接](https://atcoder.jp/contests/abc250/tasks/abc250_e)\n\n## Solution\n\n[官方题解](https://atcoder.jp/contests/abc250/editorial/3933)给出了一种用 $set$ 的做法，这种做法还是比较易懂的，但是有一个问题是不能处理区间查询，即询问集合 $\\{a_x,a_{x+1},...,a_y\\}$ 和 $\\{b_z,b_{z+1},...,b_w\\}$ 是否相同。\n\n这里给出基于哈希的做法。\n\n先讲下本题怎么做。首先对 $a$ 和 $b$ 中所有不同的数分别生成一个 64 位的随机数，再分别求前缀异或和（注意，只在第一次遇到某个数时才加入异或和），最后查询的时候判断前缀异或和是否相同即可。这种做法可能会有误判，但概率很低，怕出错可以多跑几次。\n\n再讲下区间查询怎么做。我们要查询的实际上是区间内不同数的异或和，用可持久化线段树便可求解，也可以离线后用树状数组。对于每个数，我们只记录它在区间内最后出现的位置。\n\n## Code\n\n```cpp Prefix Equality\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\ntemplate <class T>\nvoid write(T x) {\n    if (x < 0) putchar('-'), x = -x;\n    if (x > 9) write(x / 10);\n    putchar(x % 10 + '0');\n}\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, T;\nint a[MAXN], b[MAXN];\nuint64_t f[MAXN], g[MAXN];\n\nunordered_set<int> s;\n\nsigned main() {\n    read(n);\n    for (int i = 1; i <= n; i++) read(a[i]), s.insert(a[i]);\n    for (int i = 1; i <= n; i++) read(b[i]), s.insert(b[i]);\n\n    unsigned seed = chrono::system_clock::now().time_since_epoch().count();\n    mt19937_64 engine(seed);\n\n    unordered_map<int, uint64_t> h;\n    for (auto& v : s) h[v] = engine();\n\n    unordered_map<int, bool> visa, visb;\n\n    for (int i = 1; i <= n; i++) {\n        if (!visa[a[i]]) {\n            f[i] = (f[i - 1] ^ h[a[i]]);\n            visa[a[i]] = 1;\n        } else {\n            f[i] = f[i - 1];\n        }\n\n        if (!visb[b[i]]) {\n            g[i] = (g[i - 1] ^ h[b[i]]);\n            visb[b[i]] = 1;\n        } else {\n            g[i] = g[i - 1];\n        }\n    }\n    read(m);\n    for (int i = 1; i <= m; i++) {\n        int x, y;\n        read(x, y);\n        puts(f[x] == g[y] ? \"Yes\" : \"No\");\n    }\n    return 0;\n}\n```\n\n# F One Fourth\n\n## Description\n\n[题目链接](https://atcoder.jp/contests/abc250/tasks/abc250_f)\n\n## Solution\n\n维护一段凸壳，要求将凸壳两端连起来后，得到的凸多边形面积尽可能接近整个多边形面积的四分之一。如果某凸壳对应凸多边形面积恰好超过四分之一，当凸壳右端点顺时针移动时，左端点一定不会逆时针移动，否则答案不会更优。根据这一单调性，考虑使用双指针，始终保持凸壳对应凸多边形面积恰好超过四分之一。至于面积，我们维护凸壳上相邻点的叉积和便能以 $O(1)$ 的复杂度更新和计算。\n\n## Code\n\n```cpp One Fourth\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\ntemplate <class T>\nvoid write(T x) {\n    if (x < 0) putchar('-'), x = -x;\n    if (x > 9) write(x / 10);\n    putchar(x % 10 + '0');\n}\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\n\nint n;\n\nstruct Vec2 {\n    Vec2() = default;\n    Vec2(LL _x, LL _y) : x(_x), y(_y) {}\n\n    friend inline Vec2 intersect(const Vec2&, const Vec2&, const Vec2&,\n                                 const Vec2&);\n\n    friend inline bool operator<(const Vec2& a, const Vec2& b) {\n        return a.x == b.x ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline Vec2 operator+(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x + b.x, a.y + b.y);\n    }\n    /*@return cross product of two Vec2*/\n    friend inline LL operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;  //×\n    }\n    /*@return 向量与数乘后的向量*/\n    friend inline Vec2 operator*(const Vec2& a, LL num) {\n        return Vec2(a.x * num, a.y * num);\n    }\n    /*@param a 2D vector @return norm of the vector*/\n    friend inline LL norm(const Vec2& a) { return sqrt(a.x * a.x + a.y * a.y); }\n    /*@param a 2D vector @return square norm of the vector*/\n    friend inline LL normSquare(const Vec2& a) { return a.x * a.x + a.y * a.y; }\n    LL x = 0, y = 0;\n} vec[MAXN];\n\nLL getArea() {\n    LL ans = 0;\n    for (int i = 1; i <= n; i++) ans += vec[i] * vec[i % n + 1];\n    return ans;\n}\n\nsigned main() {\n    read(n);\n    for (int i = 1; i <= n; i++) read(vec[i].x, vec[i].y);\n    LL area = getArea();\n    LL ans = LONG_LONG_MAX;\n    LL sum = 0;\n    for (int i = 1, j = 1; i <= n; i++) {\n        LL b = sum + (vec[j] * vec[i]);\n        if (i != j)\n            ans = min({ans, abs(area - b * 4), abs(area - (area - b) * 4)});\n        while ((sum + (vec[j] * vec[i])) * 4 <= area) {\n            sum += vec[j] * vec[j % n + 1];\n            j = j % n + 1;\n            LL b = sum + (vec[j] * vec[i]);\n            if (i != j)\n                ans = min({ans, abs(area - b * 4), abs(area - (area - b) * 4)});\n        }\n        sum -= vec[i] * vec[i % n + 1];\n    }\n    write(ans);\n    return 0;\n}\n```\n\n# G Stonks\n\n## Description\n\n[题目链接](https://atcoder.jp/contests/abc250/tasks/abc250_g)\n\n## Solution\n\n做法参考这篇[题解](https://atcoder.jp/contests/abc250/editorial/3946)。\n\n证明的话，考虑一个 $a_i$ 原本可以从 $1$ 修改为 $0$，但是却没有修改，且后续在某一位置 $j$ 进行了修改，满足 $p_j <= p_i$，$j > i$，且 $j$ 是最小的，那么可以取消对 $a_j$ 的修改，将其作用于 $a_i$，答案不会减小。类似的，当 $a_i$ 可以从 $1$ 改为 $-1$ 时，我们没有理由保持 $a_i$ 不变，或者改为 $0$。\n\n## Code\n\n```cpp Stonks\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\n\nint n;\nint p[MAXN], s[MAXN];\nLL sum = 0;\n\n#define lid id << 1\n#define rid id << 1 | 1\n\nstruct node {\n    int l, r;\n    int mi, lazy;\n} tr[MAXN << 2];\n\nvoid update(int id) { tr[id].mi = min(tr[lid].mi, tr[rid].mi); }\n\nvoid build(int id, int l, int r) {\n    tr[id].l = l, tr[id].r = r;\n    tr[id].lazy = 0;\n    if (l == r) {\n        tr[id].mi = s[l];\n        return;\n    }\n    int mid = l + r >> 1;\n    build(lid, l, mid);\n    build(rid, mid + 1, r);\n    update(id);\n}\n\nvoid pushdown(int id) {\n    if (tr[id].lazy) {\n        tr[lid].mi += tr[id].lazy;\n        tr[rid].mi += tr[id].lazy;\n        tr[lid].lazy += tr[id].lazy;\n        tr[rid].lazy += tr[id].lazy;\n        tr[id].lazy = 0;\n    }\n}\n\nvoid modify(int id, int l, int r, int v) {\n    if (tr[id].l == l && tr[id].r == r) {\n        tr[id].mi += v;\n        tr[id].lazy += v;\n        return;\n    }\n    pushdown(id);\n    int mid = tr[id].l + tr[id].r >> 1;\n    if (r <= mid)\n        modify(lid, l, r, v);\n    else if (l > mid)\n        modify(rid, l, r, v);\n    else\n        modify(lid, l, mid, v), modify(rid, mid + 1, r, v);\n    update(id);\n}\n\nint qmin(int id, int l, int r) {\n    if (tr[id].l == l && tr[id].r == r) return tr[id].mi;\n    pushdown(id);\n    int mid = tr[id].l + tr[id].r >> 1;\n    if (r <= mid)\n        return qmin(lid, l, r);\n    else if (l > mid)\n        return qmin(rid, l, r);\n    else\n        return min(qmin(lid, l, mid), qmin(rid, mid + 1, r));\n}\n\nsigned main() {\n    ios::sync_with_stdio(false), cin.tie(0);\n    cin >> n;\n    LL sum = 0;\n    set<pair<int, int>> sp;\n    for (int i = 1; i <= n; i++) {\n        cin >> p[i];\n        sum -= p[i];\n        s[i] = s[i - 1] + 1;\n        sp.insert({-p[i], -i});\n    }\n    build(1, 1, n);\n    while (sp.size()) {\n        auto [val, id] = *sp.begin();\n        sp.erase(sp.begin());\n        val = -val;\n        id = -id;\n        int tmp = qmin(1, id, n);\n        if (tmp >= 2) {\n            sum += val * 2;\n            modify(1, id, n, -2);\n        } else if (tmp >= 1) {\n            sum += val;\n            modify(1, id, n, -1);\n        }\n    }\n    cout << sum;\n    return 0;\n}\n```\n","tags":["线段树","可持久化线段树","数论","contest","set","计算几何","双指针","哈希"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 223","url":"/2021/10/22/atcoder-abc-223/","content":"[比赛链接](https://atcoder.jp/contests/abc223)\n<!-- more -->\n# D Restricted Permutation\n## Description\n[题目链接](https://atcoder.jp/contests/abc223/tasks/abc223_d)\n## Solution\n给出 $A_i,B_i$，由 $A_i$ 向 $B_i$ 连边，表示 $A_i$ 比 $B_i$ 更早出现，从而得到一个有向图。若该有向图中存在环则无解；否则进行拓扑排序，优先选取编号最小的入度为 $0$ 的点，我们用优先队列存储这些点即可。\n## Code\n```cpp Restricted Permutation\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, T;\narray<int, MAXN> in;\nvector<int> G[MAXN], ans;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i = 1, u, v; i <= m; i++) {\n        cin >> u >> v;\n        G[u].push_back(v);\n        in[v]++;\n    }\n    priority_queue<int, vector<int>, greater<int>> q;\n    for (int i = 1; i <= n; i++)\n        if (in[i] == 0) q.push(i);\n    while (!q.empty()) {\n        int now = q.top();\n        ans.push_back(now);\n        q.pop();\n        for (auto& to : G[now]) {\n            in[to]--;\n            if (in[to] == 0) q.push(to);\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        if (in[i]) return cout << -1, 0;\n    for (auto& i : ans) cout << i << \" \";\n    return 0;\n}\n```\n\n# E Placing Rectangles\n## Description\n[题目链接](https://atcoder.jp/contests/abc223/tasks/abc223_e)\n## Solution\n任何一种合法的方案都可以转化成下面四种方案之一：\n\n![](/images/atcoder_abc_223e.png)\n\n枚举这四种方案判断是否可行即可。\n## Code\n```cpp Placing Rectangles\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\n#define int long long\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint x, y, a, b, c;\n\nbool solve2(int x, int y, int a, int b) {\n    if (y <= 0) return false;\n    int k1 = (a % y == 0 ? a / y : a / y + 1);\n    int k2 = (b % y == 0 ? b / y : b / y + 1);\n    if (k1 + k2 > x) return false;\n    return true;\n}\n\nbool solve3(int x, int y) {\n    int k1 = (a % x == 0 ? a / x : a / x + 1);\n    int k2 = (b % x == 0 ? b / x : b / x + 1);\n    int k3 = (c % x == 0 ? c / x : c / x + 1);\n    if (k3 + k2 + k1 <= y) return true;\n    if (solve2(x, y - k1, b, c)) return true;\n    if (solve2(x, y - k3, a, b)) return true;\n    if (solve2(x, y - k2, a, c)) return true;\n    return false;\n}\n\nsigned main() {\n    cin >> x >> y >> a >> b >> c;\n    if (solve3(x, y))\n        cout << \"Yes\";\n    else if (solve3(y, x))\n        cout << \"Yes\";\n    else\n        cout << \"No\";\n    return 0;\n}\n```\n\n# F Parenthesis Checking\n## Description\n[题目链接](https://atcoder.jp/contests/abc223/tasks/abc223_f)\n## Solution\n记 ```(``` 为 $1$，```)``` 为 $-1$，则合法的括号序列满足任意前缀和大于等于 $0$，且总和为 $0$，用线段树维护区间和与区间前缀和最小值即可。\n## Code\n```cpp Parenthesis Checking\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, q;\nchar s[MAXN];\n\n#define lid id << 1\n#define rid id << 1 | 1\n\nstruct node {\n    int l, r;\n    int sum, mipre;\n} tr[MAXN << 2];\n\nvoid update(int id) {\n    tr[id].sum = tr[lid].sum + tr[rid].sum;\n    tr[id].mipre = min(tr[lid].mipre, tr[lid].sum + tr[rid].mipre);\n}\n\nvoid build(int id, int l, int r) {\n    tr[id].l = l, tr[id].r = r;\n    if (l == r) {\n        tr[id].sum = tr[id].mipre = (s[l] == '(' ? 1 : -1);\n        return;\n    }\n    int mid = l + r >> 1;\n    build(lid, l, mid);\n    build(rid, mid + 1, r);\n    update(id);\n}\n\nvoid modify(int id, int x, char v) {\n    if (tr[id].l == x && tr[id].r == x) {\n        tr[id].sum = tr[id].mipre = (v == '(' ? 1 : -1);\n        return;\n    }\n    int mid = tr[id].l + tr[id].r >> 1;\n    if (x <= mid)\n        modify(lid, x, v);\n    else\n        modify(rid, x, v);\n    update(id);\n}\n\nint qsum(int id, int l, int r) {\n    if (tr[id].l == l && tr[id].r == r) return tr[id].sum;\n    int mid = tr[id].l + tr[id].r >> 1;\n    if (r <= mid)\n        return qsum(lid, l, r);\n    else if (l > mid)\n        return qsum(rid, l, r);\n    else\n        return qsum(lid, l, mid) + qsum(rid, mid + 1, r);\n}\n\nint qmin(int id, int l, int r) {\n    if (tr[id].l == l && tr[id].r == r) return tr[id].mipre;\n    int mid = tr[id].l + tr[id].r >> 1;\n    if (r <= mid)\n        return qmin(lid, l, r);\n    else if (l > mid)\n        return qmin(rid, l, r);\n    else\n        return min(qmin(lid, l, mid),\n                   qsum(lid, l, mid) + qmin(rid, mid + 1, r));\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> q;\n    for (int i = 1; i <= n; i++) cin >> s[i];\n    build(1, 1, n);\n    for (int i = 1, t, l, r; i <= q; i++) {\n        cin >> t >> l >> r;\n        if (t == 1) {\n            modify(1, l, s[r]), modify(1, r, s[l]);\n            swap(s[l], s[r]);\n        } else {\n            if (qmin(1, l, r) >= 0 && qsum(1, l, r) == 0)\n                cout << \"Yes\\n\";\n            else\n                cout << \"No\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n# G Vertex Deletion\n## Description\n[题目链接](https://atcoder.jp/contests/abc223/tasks/abc223_g)\n## Solution\n首先考虑如何得到一棵树的最大匹配：\n\n设根节点为 1，每个节点初始为白色。然后从叶子节点向根节点染色，如果一个节点存在一个子节点颜色为白色，则将其染成黑色，并将其与该子节点匹配。\n\n可以证明最大匹配为上述操作后黑色节点的个数。删除节点 1 并且最大匹配不变，当且仅当节点 1 不为黑色。\n\n对于一个节点，判断将其删除后最大匹配是否不变，可通过简单树形 DP 解决。设 $dp_i$ 表示对 $i$ 子树染色后 $i$ 的颜色 （0 为 白色，1 为 黑色）。则$dp_i |= !dp_{son_i}$，同时用 $cnt_{i, 0/1}$ 表示节点 $i$ 的颜色为白色或黑色的子节点数目。\n\n然后考虑换根 DP，用 $f_i$ 表示以 $i$ 为根，染色操作后 $i$ 最后为什么颜色，$f_1 = dp_1$。\n\n对于 $i != 1$，首先让 $fa_i$ 的 $dp_i$ 颜色数目减 1（即 $cnt_{fa_i,dp_i}-1$），得出以 $i$ 为根时 $fa_i$ 的颜色，从而修改 $cnt_{i, color_{fa_i}}$，进一步可判断出 $f_i$。最后将让 $fa_i$ 的 $dp_i$ 颜色数目加 1。\n\nDFS 对每个节点进行上述操作即可得到以每个节点为根，染色后的最终颜色。\n\n最后统计 $f_i = 0$ 的节点个数即可。\n\n时间复杂度 $O(n)$。\n## Code\n```cpp Vertex Deletion\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 2e5 + 5, MOD = 1e9 + 7;\n\nint n;\nbool dp[MAXN], f[MAXN];\nint cnt[MAXN][2]; // 0 white && 1 black\nvector<int> g[MAXN];\n\nvoid DP(int cur, int fa) {\n    for (auto& to : g[cur]) {\n        if (to == fa) continue;\n        DP(to, cur);\n        dp[cur] |= (!dp[to]);\n        cnt[cur][dp[to]]++;\n    }\n}\n\nvoid dfs(int cur, int fa) {\n    for (auto& to : g[cur]) {\n        if (to == fa) continue;\n        cnt[cur][dp[to]]--;\n\n        bool colorCur;\n        if (cnt[cur][0]) colorCur = true;\n        else colorCur = false;\n\n        f[to] = (dp[to] | (!colorCur));\n        cnt[to][colorCur]++;\n\n        dfs(to, cur);\n\n        cnt[cur][dp[to]]++;\n    }\n}\n\nsigned main() {\n    boost;\n    cin >> n;\n    for (int i = 1, u, v; i < n; i++) {\n        cin >> u >> v;\n        g[u].push_back(v), g[v].push_back(u);\n    }\n    DP(1, 0);\n    f[1] = dp[1], dfs(1, 0);\n    int ans(0);\n    for (int i = 1; i <= n; i++) ans += (!f[i]);\n    cout << ans << \"\\n\";\n    return 0;\n}\n```\n\n# H Xor Query\n## Description\n[题目链接](https://atcoder.jp/contests/abc223/tasks/abc223_h)\n## Solution\n前缀线性基模板题。建出前缀线性基，剩下的就是线性基的基本操作了。\n\n类似题目：[Ivan and Burgers](https://codeforces.com/problemset/problem/1100/F)\n## Code\n```cpp Xor Query\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define int long long\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 4E5 + 5;\nconst int MOD = 1E9 + 7;\nconst int BIT = 60;\nint n, q;\n\nstruct PrefixLinearBasis {\n    int p[BIT], pos[BIT];  // 60 位记得 define int long long\n\n    void init() {\n        memset(p, 0, sizeof(p));\n        memset(pos, 0, sizeof(pos));\n    }\n\n    bool insert(PrefixLinearBasis& pre, int w, int x) {\n        *this = pre;\n        for (register int i = BIT; ~i; i--)\n            if ((x >> i) & 1)\n                if (!p[i]) {\n                    pos[i] = w;\n                    p[i] = x;\n                    return true;\n                } else {\n                    if (pos[i] < w) swap(pos[i], w), swap(p[i], x);\n                    x ^= p[i];\n                }\n        return false;\n    }\n\n    bool query(int l, int x) {\n        for (int i = BIT; i >= 0; i--)\n            if (p[i] && pos[i] >= l && ((x >> i) & 1)) x ^= p[i];\n        return x == 0;\n    }\n} plb[MAXN];\n\nsigned main() {\n    read(n, q);\n    plb[0].init();\n    for (int i = 1, x; i <= n; i++) read(x), plb[i].insert(plb[i - 1], i, x);\n    for (int i = 1, l, r, x; i <= q; i++) {\n        read(l, r, x);\n        if (plb[r].query(l, x))\n            puts(\"Yes\");\n        else\n            puts(\"No\");\n    }\n    return 0;\n}\n```\n\n","tags":["线段树","动态规划","贪心","contest","换根DP","拓扑排序","线性基","前缀线性基"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 222","url":"/2021/10/22/atcoder-abc-222/","content":"[比赛链接](https://atcoder.jp/contests/abc222)\n<!-- more -->\n# D Between Two Arrays\n## Description\n[题目链接](https://atcoder.jp/contests/abc222/tasks/abc222_d)\n## Solution\n设 $dp[i][j]$ 表示构造出长度为 $i$，最后一个数为 $j$ 的序列的方案数，则有 $dp[i][j] = \\sum \\limits_{k<j} dp[i-1][k]$，这里要求 $a_i \\le j \\le b_i$。 \n\n初始条件为 $dp[0][0] = 1$，最终答案为 $\\sum \\limits_{i = a_n}^{b_n} dp[n][i]$。\n## Code\n```cpp Between Two Arrays\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 3E3 + 5;\nconst int MOD = 998244353;\nint n, m, T;\nint dp[MAXN][MAXN], sum[MAXN], a[MAXN], b[MAXN];\n\nvoid add(int& a, int b) { a = (a + b) % MOD; }\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= n; i++) cin >> b[i];\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= 3000; j++)\n            sum[j] = ((j ? sum[j - 1] : 0) + dp[i - 1][j]) % MOD;\n\n        for (int j = a[i]; j <= b[i]; j++) dp[i][j] = sum[j];\n    }\n    int ans = 0;\n    for (int i = a[n]; i <= b[n]; i++) add(ans, dp[n][i]);\n    cout << ans;\n\n    return 0;\n}\n```\n\n# E Red and Blue Tree\n## Description\n[题目链接](https://atcoder.jp/contests/abc222/tasks/abc222_e)\n## Solution\n首先通过 BFS 或 DFS 求出从 $A_i$ 到 $A_{i+1}$ 的路径，从而求出每条边的经过次数 $cnt[]$。\n\n问题转化为给每个 $cnt_i$ 赋予一个系数 $coef_i \\in \\{-1, 1\\}$ （即把边赋为蓝色或红色），使得 $\\sum cnt_i*coef_i=K$。\n\n可以通过 DP 解决。设 $dp_{i,j}$ 表示计算前 i 条边，总和为 $j$ 的方案数，状态转移易得。\n\n注意总和可能为负数，需要加上一个偏移量。另外可以使用滚动数组进一步节省空间。\n\n## Code\n```cpp Red and Blue Tree\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e3 + 3, MOD = 998244353;\n\nint n, m, a[MAXN], k;\nint cnt[MAXN];\nvector<pair<int, int>> g[MAXN];\npair<int, int> pre[MAXN];\nint vis[MAXN];\n\nvoid getpath(int s, int t) {\n    queue<int> q;\n    for (int i = 1; i <= n; i++) vis[i] = 0, pre[i] = {0, 0};\n    q.push(s), vis[s] = 1;\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        for (auto& e : g[cur]) {\n            int to = e.first, id = e.second;\n            if (!vis[to]) {\n                q.push(to), vis[to] = true;\n                pre[to] = {cur, id};\n            }\n        }\n    }\n    int cur = t;\n    while (cur != s) {\n        int id = pre[cur].second;\n        cnt[id]++;\n        cur = pre[cur].first;\n    }\n}\n\nint dp[2][200005];\n\nint main() {\n    boost;\n    cin >> n >> m >> k;\n    int bias = n * m;\n    for (int i = 1; i <= m; i++) cin >> a[i];\n    for (int i = 1, u, v; i < n; i++) {\n        cin >> u >> v;\n        g[u].push_back({v, i - 1});\n        g[v].push_back({u, i - 1});\n    }\n    for (int i = 1; i < m; i++) getpath(a[i], a[i + 1]);\n    dp[1][bias] = 1;\n    for (int i = 0; i < n - 1; i++) {\n        memset(dp[i & 1], 0, sizeof(dp[i & 1]));\n        for (int j = 0; j <= 2 * bias; j++) {\n            if (j + cnt[i] <= 2 * bias) dp[i & 1][j] = (dp[i & 1][j] + dp[(i & 1) ^ 1][j + cnt[i]]) % MOD;\n            if (j - cnt[i] >= 0) dp[i & 1][j] = (dp[i & 1][j] + dp[(i & 1) ^ 1][j - cnt[i]]) % MOD;\n        }\n    }\n    if (bias + k < 0) cout << 0 << endl;\n    else cout << dp[(n - 2) & 1][bias + k] << endl;\n    return 0;\n}\n```\n\n# F Expensive Expense\n## Description\n[题目链接](https://atcoder.jp/contests/abc222/tasks/abc222_f)\n## Solution\n如果只计算一个点的答案，可以通过树形 DP 解决。设根节点为 1， $dp_i$ 表示 $i$ 到子树内的最大值花费，则 $dp_i = max\\{dp_{son}+w, d_{son}+w\\}$。此外用 ``multiset[]`` 记录从 节点 $i$ 出发，到其儿子节点的子树内的最大费用的可重集和，即 $\\{max(dp_j+w, d_j+w)| j\\in son_i\\}$。\n\n之后可以通过换根 DP 求出其它节点的答案。\n\n设 $f_i$ 表示节点 $i$ 的正确答案，则 $f_1 = dp_1$。\n\n对于 $i != 1$，首先从 $multiset_{fa_i}$ 减去 $max(dp[i] + w, d[i] + w)$，表示先不考虑 $i$ 的子树，$fa_i$ 到其它节点的最大费用。\n\n如果 $multiset_{fa_i}$ 不为空，得到 $multiset_{fa_i}$ 中的最大值 $mx$，令 $f_i = max(dp_i, mx + w, d_{fa_i} + w)$，并将 $max(mx + w, d_{fa_i} + w)$ 插入到 $multiset_i$，表示 $i$ 到 $\\{j \\notin SubTree_i\\}$ 的最大费用；否则直接令 $f_i = max(dp_i, d_{fa_i} + w)$，并将 $d_{fa_i} + w$ 插入到 $multiset_i$。\n\n最后在将 $max(dp[i] + w, d[i] + w)$ 加回到 $multiset_{fa_i}$。\n\nDFS 对每个节点进行上述操作即可得到每个点到其它节点的正确最大费用。\n\n时间复杂度 $O(nlogn)$。上述思路可以通过前缀、后缀最大值做到 O(n) [Link](https://atcoder.jp/contests/abc222/editorial/2763)。\n## Code\n```cpp Expensive Expense O(nlogn)\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n#define int long long\n\nconstexpr int MAXN = 2e5 + 5, MOD = 1e9 + 7;\n\nint n, d[MAXN], dp[MAXN], f[MAXN];\nvector<pair<int, int>> g[MAXN];\nmultiset<int> s[MAXN];\n\nvoid DP(int cur, int f) {\n    for (const auto& [to, w] : g[cur]) {\n        if (to == f) continue;\n        DP(to, cur);\n        dp[cur] = max({dp[cur], dp[to] + w, d[to] + w});\n        s[cur].insert(max(dp[to] + w, d[to] + w));\n    }\n}\n\nvector<int> vec;\nvoid dfs(int cur, int fa) {\n    for (const auto& [to, w] : g[cur]) {\n        if (to == fa) continue;\n        const int tmp = max(dp[to] + w, d[to] + w);\n\n        s[cur].erase(s[cur].find(tmp));\n\n        if (s[cur].size()) {\n            int mx = *s[cur].rbegin();\n            f[to] = max({f[to], dp[to], mx + w, d[cur] + w});\n            s[to].insert({mx + w, d[cur] + w});\n        } else {\n            f[to] = max({f[to], dp[to], d[cur] + w});\n            s[to].insert(d[cur] + w);\n        }\n\n        dfs(to, cur);\n\n        s[cur].insert(tmp);\n    }\n}\n\nsigned main() {\n    boost;\n    cin >> n;\n    for (int i = 1, u, v, w; i < n; i++) {\n        cin >> u >> v >> w;\n        g[u].push_back({v, w});\n        g[v].push_back({u, w});\n    }\n    for (int i = 1; i <= n; i++) cin >> d[i];\n    DP(1, 0);\n    f[1] = dp[1];\n    dfs(1, 0);\n    for (int i = 1; i <= n; i++) cout << f[i] << \"\\n\";\n    return 0;\n}\n```\n\n# G 222\n## Description\n[题目链接](https://atcoder.jp/contests/abc222/tasks/abc222_g)\n## Solution\n转化题意，即求最小的 $n$ 满足 $\\frac{2}{9}(10^n-1) ≡ 0 \\mod K$。设 $M = (K\\&1?9K:\\frac{9}{2}K)$，那么我们要求的是最小的 $n$，使得 $10^n≡1 \\mod M$。\n\n要让上面的等式成立，那么 $M$ 不能是 $2$ 或 $5$ 的倍数，即 $M$ 与 $10$ 互质。由欧拉定理可知 $10^{\\phi(M)}≡1 \\mod M$。可以证明满足条件的 $n$ 一定是 $\\phi(M)$ 的约数（证明见[官方题解](https://atcoder.jp/contests/abc222/editorial/2764)），因此从小大到枚举 $\\phi(M)$ 的约数并检查是否满足条件即可。\n\n时间复杂度：$O(T\\sqrt{M})$\n## Code\n```cpp 222\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint k;\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a % MOD;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nint phi(int x) {\n    int ans = x;\n    for (int i = 2; i * i <= x; i++)\n        if (x % i == 0) {\n            while (x % i == 0) x /= i;\n            ans -= ans / i;\n        }\n    if (x != 1) ans -= ans / x; // 依据欧拉函数公式\n    return ans;\n}\n\nvector<int> divisor(int x) {\n    vector<int> ans;\n    for (int i = 1; i * i <= x; i++)\n        if (x % i == 0) {\n            ans.push_back(i);\n            if (i * i != x) ans.push_back(x / i);\n        }\n    sort(ans.begin(), ans.end());\n    return ans;\n}\n\nvoid solve(int caseNum) {\n    cin >> k;\n    if (k % 2 == 0) k /= 2;\n    k *= 9;\n    if (__gcd(k, 10) != 1) return cout << -1 << endl, void();\n    for (auto& d : divisor(phi(k)))\n        if (qpow(10, d, k) == 1) return cout << d << endl, void();\n}\n\nsigned main() {\n    int testCase = 1;\n    ios::sync_with_stdio(false);\n    cin >> testCase;\n    for (int i = 1; i <= testCase; i++) solve(i);\n    return 0;\n}\n```\n\n附上 BSGS 代码，当 $b = 1$ 且 $gcd(a, p) != 1$ 时无解:\n```cpp BSGS\n#include <bits/stdc++.h>\n// bsgs\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e5 + 5;\n\nnamespace BSGS {\n    struct custom_hash {\n        static uint64_t splitmix64(uint64_t x) {\n            x += 0x9e3779b97f4a7c15;\n            x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n            x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n            return x ^ (x >> 31);\n        }\n\n        size_t operator()(uint64_t x) const {\n            static const uint64_t FIXED_RANDOM =\n                chrono::steady_clock::now().time_since_epoch().count();\n            return splitmix64(x + FIXED_RANDOM);\n        }\n    };\n\n    int qpow(int a, int b, int p) {\n        int res = 1;\n        while (b) {\n            if (b & 1) res = 1LL * res * a % p;\n            a = 1LL * a * a % p;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    /* for a^x = b(mod p) where gcd(a, p) = 1*/\n    int bsgsCoprime(int a, int b, int p) {\n        if (__gcd(a, p) != 1) return -1;\n        unordered_map<int, int, custom_hash> mp;\n        int sq = sqrt(p) + 1;\n        for (int i = 0, tmp; i <= sq; i++) {\n            if (!i) tmp = b;\n            else tmp = 1LL * tmp * a % p;\n            mp[tmp] = i;\n        }\n\n        int gap = qpow(a, sq, p);\n        for (int i = 0, tmp; i <= sq; i++) {\n            if (!i) tmp = 1;\n            else tmp = 1LL * tmp * gap % p;\n\n            if (i == 1) {\n                int res = INT_MAX;\n                for (int j = 0, tmp; j <= sq; j++) {\n                    if (!j) tmp = b;\n                    else tmp = 1LL * tmp * a % p;\n                    if (gap == tmp && i * sq - j > 0) res = min(res, i * sq - j);\n                }\n                if (res != INT_MAX) return res;\n            } else if (mp.find(tmp) != mp.end()) {\n                int j = mp[tmp];\n                if (i * sq - j > 0) return i * sq - j;\n            }\n        }\n        return -1;\n    }\n};\n\nint main() {\n    boost;\n    int tc;\n    cin >> tc;\n    while (tc--) {\n        int k;\n        cin >> k;\n        if (k & 1) k = 9 * k;\n        else k = 9 * k / 2;\n        cout << BSGS::bsgsCoprime(10, 1, k) << \"\\n\";\n    }\n    return 0;\n}\n```\n","tags":["动态规划","数论","组合计数","contest","换根DP","欧拉定理","欧拉函数"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 220","url":"/2021/10/13/atcoder-abc-220/","content":"[比赛链接](https://atcoder.jp/contests/abc220)\n<!-- more -->\n# D FG operation\n## Description\n[题目链接](https://atcoder.jp/contests/abc220/tasks/abc220_d)\n## Solution\n设 $DP_{i, j}$ 表示计算了前 i 个数，结果为 $j$ 的方案数，初始条件为 $DP_{1, a[1]}=1$，然后根据题意转移即可。\n## Code\n```cpp FG operation\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e5 + 5, MOD = 998244353;\n\n#define int long long\n\nint n;\nint dp[MAXN][10];\nint a[MAXN];\n\nsigned main() {\n    boost;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    dp[1][a[1]] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int pre = 0; pre < 10; pre++) {\n            (dp[i][pre * a[i] % 10] += dp[i - 1][pre]) %= MOD;\n            (dp[i][(pre + a[i]) % 10] += dp[i - 1][pre]) %= MOD;\n        }\n    }\n    for (int i = 0; i < 10; i++) cout << dp[n][i] << \"\\n\";\n    return 0;\n}\n```\n\n# E Distance on Large Perfect Binary Tree\n## Description\n[题目链接](https://atcoder.jp/contests/abc220/tasks/abc220_e)\n统计满二叉树上距离为 D 的点对数。\n## Solution\n按深度从小达到考虑 （深度范围为 [1, n])，为防止重复计算，只考虑经过选定点 $v$ ，且不经过其父亲节点的长度为 D 的路径（类似点分治路径统计）。\n\n深度为 $1\\le i\\le n$ 的满二叉树节点数为 $2^{i - 1}$。\n\n对每个节点 $v$，以 $v$ 为端点，且另一端在 $v$ 子树中的路径数为 $2^d$，所以计入答案的点对数为 $2 * 2^d*2^{i-1}=2^{i+d}$。\n\n否则设路径的一段长度为 $j$， 则另一端长度为 $D - j$，需要满足 $1\\le j\\le n-i$ 且 $1\\le D-j\\le n-i$，所以 $l = max(1, D + i - n) \\le j \\le r =min(D - 1, n - i)$。对应的计入答案的点对数为 $2 * max(0, r - l + 1) * 2^{i-1} * 2^{j-1} * 2^{D - j - 1}=2*max(0, r - l + 1) * 2^{i-1}*2^{d-1}。$\n\n## Code\n```cpp Distance on Large Perfect Binary Tree\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e5 + 5, MOD = 998244353;\n\n#define int long long\n\nint n, d, ans;\n\nint qpow(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nsigned main() {\n    boost;\n    cin >> n >> d;\n    for (int i = 1; i <= n; i++) {\n        int num = qpow(2, i - 1);\n        \n        if (i + d <= n) {\n            ans = (ans + qpow(2, i + d)) % MOD;\n        }\n\n        int high = min(d - 1, n - i), low = max(1LL, d + i - n);\n\n        if (low > high) continue;\n        ans = (ans + num * (high - low + 1) % MOD * qpow(2, d - 1) % MOD) % MOD;\n    }\n    cout << (ans % MOD) << \"\\n\";\n    return 0;\n}\n```\n\n\n# F Distance Sums 2\n## Description\n[题目链接](https://atcoder.jp/contests/abc220/tasks/abc220_f)\n## Solution\n二次扫描与换根 DP 模板题。\n\n首先选择一个节点为根节点进行树形 DP，设 $dp_i$ 表示 $节点 i$ 到子树中所有节点的距离和，状态转移方程为 $dp_i = \\sum\\limits_{j \\in Son_i}dp[j]+sz_j*w_{i,j}$。\n\ndfs 换根时，设 $f_i$ 表示节点 $i$ 到其它所有节点的距离和。对于 $j \\in Son_i$，$f_j$ 分为两个部分，一个是到子树节点的距离和 $dp_j$，另一个是经过 $e_{j, i}$ 到其它节点的距离和。可以先从 $f_i$ 中减去 $i$ 到 $j$ 的子树节点的距离和，即$f_i - dp_j - sz_j*w$，在加上 $w$ 乘以其它节点的数目 $n-sz_j$ 即为答案。最终结果为 $f_j = dp_j + (f_i-dp_j-sz_j*w) + (n - sz_j)*w$。\n\n时间复杂度 $O(n)$。\n## Code Distance Sums 2\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 2e5 + 5, MOD = 998244353;\n\nint n;\nlong long d[MAXN], f[MAXN], sz[MAXN];\nvector<int> g[MAXN];\n\nvoid DP(int cur, int fa) {\n    sz[cur] = 1;\n    for (auto& to : g[cur]) {\n        if (to == fa) continue;\n        DP(to, cur);\n        d[cur] += d[to] + sz[to];\n        sz[cur] += sz[to];\n    }\n}\n\nvoid dfs(int cur, int fa) {\n    for (auto& to : g[cur]) {\n        if (to == fa) continue;\n        f[to] = d[to] + (f[cur] - d[to] - sz[to]) + (n - sz[to]);\n        dfs(to, cur);\n    }\n}\n\n\nsigned main() {\n    boost;\n    cin >> n;\n    for (int i = 1, u, v; i < n; i++) {\n        cin >> u >> v;\n        g[u].push_back(v), g[v].push_back(u);\n    }\n    DP(1, 0);\n    f[1] = d[1];\n    dfs(1, 0);\n    for (int i = 1; i <= n; i++) cout << f[i] << \"\\n\";\n    return 0;\n}\n```\n\n# G Isosceles Trapezium\n## Description\n[题目链接](https://atcoder.jp/contests/abc220/tasks/abc220_g)\n给定平面上 $4\\le n \\le 1000$ 个点，每个点有一个点权，找出一个等腰梯形，使得点权和最大。\n## Solution\n两条线段能构成等腰梯形当且仅当它们的中垂线相同，且延长后不重叠。\n\n首先得出所有线段 （只考虑向一个方向连线），求出中点，两端点点权和，和对应的中垂线方程（可通过求出中垂线向量得到）。然后按照中垂线分类。\n\n对于同一类中垂线，按中点分类，记录最大的端点点权和，排序后找到前 2 大的点权和即可。\n\n\n为防止浮点误差，最好预先将坐标 * 2，并且用 $ax+by+c$ 的形式表示中垂线。此外 ``map`` 不是按照 ``value`` 排序的，求最大 ``value`` 不要用 ``map.rbegin()->second``。\n\n时间复杂度 $O(N^2logN^2)$。\n## Code Isosceles Trapezium\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n#define int long long\n\nconstexpr int MAXN = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, ans(-1);\nvector<tuple<int, int, int>> perpenb; // perpendicular bisectors\nvector<map<pair<int, int>, int>> midpoints; // midpoints of a perpendicular bisector\nvector<tuple<int, int, int>> p;\n\nsigned main() {\n    boost;\n    cin >> n;\n    for (signed i = 0, x, y, c; i < n; i++) {\n        cin >> x >> y >> c;\n        p.emplace_back(x << 1, y << 1, c);\n    }\n    sort(p.begin(), p.end());\n    for (signed i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++) {\n            int xi, yi, ci, xj, yj, cj;\n            tie(xi, yi, ci) = p[i], tie(xj, yj, cj) = p[j];\n            long long x1 = (xi + xj) >> 1, y1 = (yi + yj) >> 1;\n            long long vecx = yi - yj, vecy = xj - xi;\n            long long x2 = x1 + vecx, y2 = y1 + vecy;\n            int a = y2 - y1, b = x1 - x2, c = x1 * y2 - x2 * y1;\n            int gcd = __gcd(a, __gcd(b, c));\n            a /= gcd, b /= gcd, c /= gcd;\n            perpenb.emplace_back(a, b, c);\n        }\n    sort(perpenb.begin(), perpenb.end());\n    int cnt = unique(perpenb.begin(), perpenb.end()) - perpenb.begin();\n    midpoints.resize(cnt);\n\n    for (signed i = 0; i < n; i++)\n        for (signed j = i + 1; j < n; j++) {\n            int xi, yi, ci, xj, yj, cj;\n            tie(xi, yi, ci) = p[i], tie(xj, yj, cj) = p[j];\n            long long x1 = (xi + xj) >> 1, y1 = (yi + yj) >> 1;\n            long long vecx = yi - yj, vecy = xj - xi;\n            long long x2 = x1 + vecx, y2 = y1 + vecy;\n            int a = y2 - y1, b = x1 - x2, c = x1 * y2 - x2 * y1;\n            int gcd = __gcd(a, __gcd(b, c));\n            a /= gcd, b /= gcd, c /= gcd;\n            int pos = lower_bound(perpenb.begin(), perpenb.begin() + cnt, make_tuple(a, b, c)) - perpenb.begin();\n            int tmp = midpoints[pos][{x1, y1}];\n            midpoints[pos][{x1, y1}] = max(tmp, ci + cj);\n        }\n    for (auto& mp : midpoints) {\n        if (mp.size() < 2) continue;\n        vector<int> cs;\n        for (auto& i : mp) cs.push_back(i.second);\n        sort(cs.begin(), cs.end());\n        ans = max(ans, cs[cs.size() - 1] + cs[cs.size() - 2]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n```\n\n\n","tags":["动态规划","线性DP","换根DP","组合数学","计算几何"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 221","url":"/2021/10/05/atcoder-abc-221/","content":"[比赛链接](https://atcoder.jp/contests/abc221)\n<!-- more -->\n# D Online games\n## Description\n[题目链接](https://atcoder.jp/contests/abc221/tasks/abc221_d)\n## Solution\n离散化后做差分。设离散化前相邻两个修改位置为 $X_i$，$X_{i+1}$，离散化后的修改位置为 $i,i+1$，那么对差分数组求和（记为 $Sum$）后，答案为 $Sum_i$ 的天数会加上 $X_{i+1}-X_i$，开个桶统计下答案即可。 \n## Code\n```cpp Online games\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 4E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, last;\nint a[MAXN], b[MAXN], from[MAXN], sum[MAXN], ans[MAXN];\nvector<int> v;\nunordered_map<int, int> mp;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i] >> b[i];\n        b[i] = b[i] + a[i];\n        v.push_back(a[i]), v.push_back(b[i]);\n    }\n    sort(v.begin(), v.end());\n    last = unique(v.begin(), v.end()) - v.begin();\n    for (int i = 0; i < last; i++) mp[v[i]] = i + 1, from[i + 1] = v[i];\n    for (int i = 1; i <= n; i++) sum[mp[a[i]]]++, sum[mp[b[i]]]--;\n    for (int i = 1; i <= last; i++) {\n        sum[i] += sum[i - 1];\n        if (i < last)\n            ans[sum[i]] += (from[i + 1] - from[i]);\n        else\n            ans[sum[i]] += 1;\n    }\n    for (int i = 1; i <= n; i++) cout << ans[i] << \" \";\n    return 0;\n}\n```\n\n# E LEQ\n## Description\n[题目链接](https://atcoder.jp/contests/abc221/tasks/abc221_e)\n## Solution\n设 $A_x \\le A_i,x < i$，那么由 $(A_x,A_{x+1},\\dots,A_i)$ 生成的包含端点的子序列个数为 $2^{i-x-1} = 2^{i-1}2^{-x}$。容易发现 $A_x$ 会贡献 $2^{-x}$，将所有小于等于 $A_i$ 的 $A_x$ 的贡献加起来（可使用值域树状数组快速求解）再乘以 $2^{i-1}$ 即可。\n## Code\n```cpp LEQ\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n#define int long long\n\nconst int MAXN = 3E5 + 5;\nconst int MOD = 998244353;\n\nvector<int> v;\nunordered_map<int, int> mp;\nint n, a[MAXN];\n\nvoid desc() {\n    sort(v.begin(), v.end());\n    int m = unique(v.begin(), v.end()) - v.begin();\n    for (int i = 0; i < m; i++) mp[v[i]] = i + 1;\n}\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a % MOD;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nstruct BIT {  // Binary Index Trees, 1based\n    int lowbit(int x) { return x & (~x + 1); }\n    /* O(n) build tree*/\n    BIT() {\n        for (int i = 1; i <= n; i++) c[i] = 0;\n    }\n    void build() {\n        for (int i = 1; i <= n; i++) {\n            int j = i + lowbit(i);  // j is father of i\n            if (j <= n) c[j] += c[i];\n        }\n    }\n    /*@param x the position to add val*/\n    void add(int x, LL val) {\n        val %= MOD;\n        while (x <= n) (c[x] += val) %= MOD, x += lowbit(x);\n    }\n    /*range [1, x] sum query*/\n    LL query(int x, LL res = 0) {\n        while (x) (res += c[x]) %= MOD, x -= lowbit(x);\n        return res;\n    }\n    array<LL, MAXN> c;\n} bit[3];\n/*range [l, r] add val*/\ninline void add(int l, int r, LL val) {\n    bit[1].add(l, val), bit[1].add(r + 1, -val);\n    bit[2].add(l, val * l), bit[2].add(r + 1, -val * (r + 1));\n}\n/*range [l, r] sum query*/\ninline LL query(int l, int r, LL res = 0) {\n    res =\n        (bit[0].query(r) + bit[1].query(r) * (r + 1) % MOD - bit[2].query(r)) %\n        MOD;\n    res %= MOD;\n    res -= (bit[0].query(l - 1) + bit[1].query(l - 1) * l % MOD -\n            bit[2].query(l - 1)) %\n           MOD;\n    return (res % MOD + MOD) % MOD;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i], v.push_back(a[i]);\n    desc();\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        int id = mp[a[i]];\n        ans = (ans + query(1, id) * qpow(2, i - 1, MOD) % MOD) % MOD;\n        add(id, id, qpow(qpow(2, i, MOD), MOD - 2, MOD));\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n# F Diameter set \n## Description\n[题目链接](https://atcoder.jp/contests/abc221/tasks/abc221_f)\n## Solution\n首先求出树的直径，设为 $D$，直径上的点依次记为 $V_0,V_1,\\dots,V_D$。下面对直径分奇偶讨论：\n\n1. D 为奇数\n  设 $A=V_{\\frac{D-1}{2}}$, $B = V_{\\frac{D+1}{2}}$。割掉连接 $A,B$ 的边，得到两个子树 $T_A,T_B$。易证 $T_A$ 中任意两点距离不超过 $D-1$，$T_B$ 中任意两点距离不超过 $D-1$，因此距离为 $D$ 的两点只能一个在 $T_A$ 中，一个在 $T_B$ 中。设 $T_A$ 中和 $A$ 距离为 $\\frac{D-1}{2}$ 的点有 $M_1$ 个，$T_B$ 中和 $B$ 距离为 $\\frac{D-1}{2}$ 的点有 $M_2$ 个，那么答案为 $M_1M_2$。\n2. D 为偶数\n  设 $C=V_{\\frac{D}{2}}$。将 $C$ 以及它所连的边（设有 $k$) 条删去，得到 $k$ 个子树，记为 $T_1,T_2,\\dots,T_k$，它们的根为 $R_1,R_2,\\dots,R_k$。易证 $T_i$ 中任意两点距离不超过 $D-2$。因此符合条件的点集中，任意两点不在同一子树中。设 $T_i$ 中和 $R_i$ 距离为 $\\frac{D}{2}-1$ 的点有 $M_i$ 个，那么答案为 $(M_1+1)(M_2+1)\\dots(M_k+1)-(M_1+M_2+\\dots+M_k)-1$。\n## Code\n```cpp Diameter set \n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 998244353;\n\nint n, D, ed;\nvector<int> G[MAXN];\narray<int, MAXN> pre, dis;\n\ninline void dfs1(int cur, int fa) { // 求直径\n    for (auto &to : G[cur]) {\n        if (to == fa) continue;\n        dis[to] = dis[cur] + 1, pre[to] = cur;\n        if (dis[to] > D) D = dis[to], ed = to;\n        dfs1(to, cur);\n    }\n}\n\nvoid getDia() {\n    dfs1(1, 0);\n    dis[ed] = 0, pre[ed] = -1, D = 0;\n    dfs1(ed, 0);\n}\n\nint getNode(int ed, int d) {\n    while (d) ed = pre[ed], d--;\n    return ed;\n}\n\nint dfs2(int now, int fa, int d) { // 求到 now 距离为 d 的点的个数\n    if (!d) return 1;\n    int ans = 0;\n    for (auto &to : G[now]) {\n        if (to == fa) continue;\n        ans += dfs2(to, now, d - 1);\n    }\n    return ans;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 1, u, v; i < n; i++) {\n        cin >> u >> v;\n        G[u].push_back(v), G[v].push_back(u);\n    }\n    getDia();\n    if (D % 2 == 0) {\n        int center = getNode(ed, D / 2);\n        vector<int> v;\n        for (auto &to : G[center]) v.push_back(dfs2(to, center, D / 2 - 1));\n        LL tmp = 1;\n        for (auto &sz : v) tmp = tmp * (sz + 1) % MOD;\n        tmp--;\n        for (auto &sz : v) tmp -= sz;\n        cout << (tmp % MOD + MOD) % MOD;\n    } else {\n        int a = getNode(ed, (D - 1) / 2);\n        int b = getNode(ed, (D + 1) / 2);\n        int m1 = dfs2(a, b, D / 2);\n        int m2 = dfs2(b, a, D / 2);\n        cout << 1ll * m1 * m2 % MOD;\n    }\n    return 0;\n}\n```\n\n# G Jumping sequence\n## Description\n[题目链接](https://atcoder.jp/contests/abc221/tasks/abc221_g)\n## Solution\n将坐标系顺时针旋转 $45°$，再施加 $\\sqrt{2}$ 的缩放，得到新的坐标系 $(X+Y,X-Y)$。在这个坐标系中，向上移动表示为 $(+D,-D)$，向下移动表示为 $(-D,+D)$，向左移动表示为 $(-D,-D)$，向右移动表示为 $(+D,+D)$，从而问题转化为找到两个 $+1,-1$ 序列 $s,s'$，使得 \n$$\\sum\\limits_{i=1}^{N} s_iD_i=A+B,\\sum\\limits_{i=1}^{N} s'_iD_i=A-B$$\n\n定义 $S=\\sum\\limits_{i=1}^{N}D_i$，那么问题可以继续转化为找到 $0,1$ 序列 $t,t'$，满足 \n$$\\sum\\limits_{i=1}^{N} t_iD_i=\\frac{S+A+B}{2},\\sum\\limits_{i=1}^{N} t'_iD_i=\\frac{S+A-B}{2}$$\n\n显然上述等式右边小于零，大于 $S$，或者不是偶数时无解。否则，设 $dp[i][s]$ 表示考虑前 $i$ 个数，和为 $s$ 的方案是否存在，我们可以在 $O(NS)$ 时间内求解。由于 $NS$ 可达 $7.2*10^9$，朴素 $DP$ 无法通过此题。考虑到我们只关心方案是否存在，因此可用 $bitset$ 优化。\n\n判断完可行性后，从终态倒着往前推，枚举四个方向，看之前的状态是否可行来确定每一步的方向。\n## Code\n```cpp Jumping sequence\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E3 + 5;\nconst int MOD = 1E9 + 7;\nint n, st, ed, sumd;\narray<int, MAXN> d;\nbitset<3600001> dp[MAXN];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> st >> ed;\n    for (int i = 1; i <= n; i++) {\n        cin >> d[i];\n        sumd += d[i];\n    }\n    int a = sumd + st + ed, b = sumd + st - ed;\n    if (b < 0 || a < 0 || a % 2 || b % 2 || a / 2 > sumd || b / 2 > sumd)\n        return cout << \"No\", 0;\n    a /= 2, b /= 2;\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) dp[i] = dp[i - 1] | (dp[i - 1] << d[i]);\n    if (!dp[n][a] || !dp[n][b]) return cout << \"No\", 0;\n    cout << \"Yes\\n\";\n    // u10,d01,l00,r11\n    string ans = \"\";\n    for (int i = n; i >= 1; i--) {\n        if (a - d[i] >= 0 && b - d[i] >= 0 && dp[i - 1][a - d[i]] &&\n            dp[i - 1][b - d[i]])\n            a -= d[i], b -= d[i], ans = \"R\" + ans;\n        else if (dp[i - 1][a] && dp[i - 1][b])\n            ans = \"L\" + ans;\n        else if (b - d[i] >= 0 && dp[i - 1][a] && dp[i - 1][b - d[i]])\n            b -= d[i], ans = \"D\" + ans;\n        else\n            a -= d[i], ans = \"U\" + ans;\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n# H Count Multiset\n## Description\n[题目链接](https://atcoder.jp/contests/abc221/tasks/abc221_h)\n## Solution\n将 ```multiset``` 中元素从小到大排列，记为 $A_1,A_2,\\dots,A_k$。\n\n令 $B_1 = A_1$，$B_i = A_i-A_{i-1},i\\ge 2$，那么问题转化为：\n\n<blockquote>\n\n对 $k=1,2,\\dots,N$，求满足下面三个条件的序列个数：\n- $B_1>0$。\n- 不存在长度超过 $M-1$ 的连续的 $0$。\n- $\\sum\\limits_{i=1}^{k}B_i*(k-i+1)=N$。\n\n</blockquote>\n\n将 $B$ 翻转，那么上述问题可以继续转化为：\n\n<blockquote>\n\n对 $k=1,2,\\dots,N$，求满足下面三个条件的序列个数：\n- $B_k>0$。\n- 不存在长度超过 $M-1$ 的连续的 $0$。\n- $\\sum\\limits_{i=1}^{k}B_i*i=N$。\n\n</blockquote>\n\n设 $dp[i][s]$ 表示求满足下列条件的 $B$ 的个数：\n- $B_i>0$\n- 不存在长度超过 $M-1$ 的连续的 $0$。\n- $\\sum\\limits_{j=1}^{i}B_j*j=N$。\n\n易得状态转移方程：$dp[i][s] = \\sum\\limits_{j=i-M+1}^{i-1}\\sum\\limits_{k=1}^{\\lfloor \\frac{s}{i} \\rfloor}dp[j][s-i*k]$。直接转移需要枚举 $i,j,k,s$，时间复杂度 $O(N^3M)$ 无法通过此题。\n\n对状态转移式进行变形，得 $dp[i][s] = \\sum\\limits_{k=1}^{\\lfloor \\frac{s}{i} \\rfloor}\\sum\\limits_{j=i-M+1}^{i-1}dp[j][s-i*k] = \\sum\\limits_{k=1}^{\\lfloor \\frac{s}{i} \\rfloor}(\\sum\\limits_{j=1}^{i-1}dp[j][s-i*k]-\\sum\\limits_{j=1}^{i-M+1}dp[j][s-i*k])$。我们先按第一维求和，再对第二维以间隔 $i$ 求和即可在 $O(N^2)$ 时间内完成求解。\n## Code\n```cpp Count Multiset\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 5E3 + 5;\nconst int MOD = 998244353;\nint n, m;\nLL dp[MAXN][MAXN], sum[MAXN][MAXN], tmp[MAXN];\n\nsigned main() {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        if (i <= m)\n            for (int s = i; s <= n; s += i) dp[i][s] = 1;\n        for (int s = 0, j = i - m; s <= n; s++)\n            tmp[s] = ((s >= i ? tmp[s - i] : 0) + sum[i - 1][s] -\n                      (j > 0 ? sum[j - 1][s] : 0)) %\n                     MOD;\n        for (int s = i; s <= n; s++) dp[i][s] = (dp[i][s] + tmp[s - i]) % MOD;\n        for (int s = 0; s <= n; s++)\n            sum[i][s] = (sum[i - 1][s] + dp[i][s]) % MOD;\n    }\n    for (int i = 1; i <= n; i++) cout << (dp[i][n] + MOD) % MOD << '\\n';\n    return 0;\n}\n```\n\n\n\n","tags":["动态规划","组合计数","contest","树状数组","差分","离散化","树的直径","bitset"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 218","url":"/2021/09/21/atcoder-abc-218/","content":"[比赛链接](https://atcoder.jp/contests/abc218)\n<!-- more -->\n# C Shapes\n## Description\n[题目链接](https://atcoder.jp/contests/abc218/tasks/abc218_c)\n有两个 N * N 的 grid S 和 T（仅包含 ``*`` 和 ``#``），问能否通过若干次 90° 旋转和平移操作使得两个 grid 相同。\n## Solution\n90° 旋转 4 次，每次旋转后用最小矩形 Rs 框出 S 中的所有 ``#``，用 Rt 框出 T 中所有 ``#``。判断 Rs、Rt 是否相同。\n## Code \n```cpp Shapes\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 202, MOD = 1e9 + 7;\n\nint n;\nchar s[MAXN][MAXN], t[MAXN][MAXN];\n\nbool equal() {\n    int ups(1e9), downs(-1);\n    int ls(1e9), rs(-1);\n    int upt(1e9), downt(-1);\n    int lt(1e9), rt(-1);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++) {\n            if (s[i][j] == '#') {\n                ups = min(ups, i);\n                ls = min(ls, j);\n                rs = max(rs, j);\n                downs = max(downs, i);\n            }\n            if (t[i][j] == '#') {\n                upt = min(upt, i);\n                lt = min(lt, j);\n                rt = max(rt, j);\n                downt = max(downt, i);\n            }\n        }\n\n    if (downt - upt != downs - ups) return false;\n    if (rs - ls != rt - lt) return false;\n\n    for (int i = 0; i <= downt - upt; i++) {\n        for (int j = 0; j <= rt - lt; j++)\n            if (s[ups + i][ls + j] != t[upt + i][lt + j]) return false;\n    }\n\n    return true;\n}\n\nvoid rotate() {\n    int tmp[MAXN][MAXN];\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++) {\n            tmp[i][j] = s[j][n - i + 1];\n        }\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            s[i][j] = tmp[i][j];\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin.ignore(1, '\\n');\n        for (int j = 1; j <= n; j++)\n            cin >> s[i][j];\n    }\n        \n    for (int i = 1; i <= n; i++) {\n        cin.ignore(1, '\\n');\n        for (int j = 1; j <= n; j++)\n            cin >> t[i][j];\n    }\n  \n    for (int i = 1; i <= 4; i++) {\n        rotate();\n        if (equal()) {\n            cout << \"Yes\\n\";\n            return 0;\n        }\n    }\n    cout << \"No\\n\";\n    return 0;\n}\n```\n\n# D Rectangles\n## Description\n[题目链接](https://atcoder.jp/contests/abc218/tasks/abc218_d)\n给出 $1 \\le N \\le 2000$ 个互异点，求出这些点构成的边界与 $x$ 或 $y$ 轴平行的矩形个数。\n## Solution\n如果一个矩形的左下角和右上角都确定了，那么该矩形也就确定了。因此只需要枚举两个顶点，然后通过 ``map`` 查找另外两个顶点是否存在即可。\n## Code\n下给出 ``pair<int, int>`` 的哈希方法。\n```cpp Rectangles\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\ntemplate <typename T>\ninline void hash_combine(std::size_t &seed, const T &val) {\n    seed ^= std::hash<T>()(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n// auxiliary generic functions to create a hash value using a seed\ntemplate <typename T> inline void hash_val(std::size_t &seed, const T &val) {\n    hash_combine(seed, val);\n}\ntemplate <typename T, typename... Types>\ninline void hash_val(std::size_t &seed, const T &val, const Types &... args) {\n    hash_combine(seed, val);\n    hash_val(seed, args...);\n}\n\ntemplate <typename... Types>\ninline std::size_t hash_val(const Types &... args) {\n    std::size_t seed = 0;\n    hash_val(seed, args...);\n    return seed;\n}\n\nstruct pair_hash {\n    template <class T1, class T2>\n    std::size_t operator()(const std::pair<T1, T2> &p) const {\n        return hash_val(p.first, p.second);\n    }\n};\n\nunordered_map<pair<int, int>, bool, pair_hash> um;\n\nint main() {\n    boost;\n    int n;\n    cin >> n;\n    vector<pair<int, int>> p(n);\n    for (int i = 0; i < n; i++) cin >> p[i].first >> p[i].second, um[p[i]] = true;\n    sort(p.begin(), p.end());\n    int ans(0);\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++) {\n            if (p[i].first < p[j].first && p[i].second < p[j].second) {\n                if (um.count({p[i].first, p[j].second}) &&\n                    um.count({p[j].first, p[i].second}))\n                    ans++;\n            }\n        }\n    cout << ans << \"\\n\";\n    return 0;\n}\n```\n\n# E Destruction\n## Description\n[题目链接](https://atcoder.jp/contests/abc218/tasks/abc218_e)\n## Solution\n问题等价于求出原图的最小生成树，用 $\\sum C_i>0$ 减去最小生成树中大于 0 的边权和。\n## Code\n```cpp Destruction\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\n\nint n, m, fa[MAXN];\n\nint find(int x) {\n    if (fa[x] != x) fa[x] = find(fa[x]);\n    return fa[x];\n}\n\nvector<tuple<int, int, int>> v;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    v.resize(m);\n    for (int i = 1; i <= n; i++) fa[i] = i;\n    LL tot = 0;\n    for (auto& [c, a, b] : v) {\n        cin >> a >> b >> c;\n        if (c > 0) tot += c;\n    }\n    sort(v.begin(), v.end());\n    LL res = 0;\n    for (auto& [c, a, b] : v) {\n        int r1 = find(a), r2 = find(b);\n        if (r1 != r2) {\n            fa[r2] = r1;\n            if (c > 0) res += c;\n        }\n    }\n    cout << tot - res;\n    return 0;\n}\n```\n\n# F Blocked Roads \n## Description\n[题目链接](https://atcoder.jp/contests/abc218/tasks/abc218_f)\n给出 $2\\le N \\le 400$ 个点，$1\\le M \\le N(N-1)$ 条边的有向图，问删除边 i 后从 1 到 N 的最短路。\n## Solution\n从 1 到 N 的最短路所经过的边数是 $O(N)$ 的。对于不在最短路上的边，答案是最短路长度；否则重新跑最短路，遇到该边则跳过。\n\n注意图一开始就不连通的情况。\n## Code \n```cpp Blocked Roads\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 404, MOD = 1e9 + 7;\n\nint n, m;\nvector<pair<int, int>> g[MAXN];\npair<int, int> e[MAXN * MAXN];\nint dis[MAXN];\nbool inq[MAXN];\n\nvoid spfa() {\n    memset(dis, 0x3f, sizeof(dis));\n    memset(inq, false, sizeof(inq));\n    queue<int> q;\n    q.push(1), dis[1] = 0;\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        inq[cur] = false;\n        for (auto& [to, id] : g[cur]) {\n            if (dis[to] > dis[cur] + 1) {\n                dis[to] = dis[cur] + 1;\n                if (!inq[to]) q.push(to), inq[to] = true;\n            }\n        }\n    }\n}\n\nbool vis[MAXN];\nint dis2[MAXN];\nint bfs(int del) {\n    memset(vis, false, sizeof(vis));\n    queue<int> q;\n    q.push(1), vis[1] = true, dis2[1] = 0;\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        for (auto& [to, id] : g[cur]) {\n            if (id == del) continue;\n            if (vis[to]) continue;\n            dis2[to] = dis2[cur] + 1;\n            q.push(to), vis[to] = true;\n        }\n    }\n    if (!vis[n]) return -1;\n    else return dis2[n];\n}\n\nint main() {\n    boost;\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        cin >> e[i].first >> e[i].second;\n        g[e[i].first].emplace_back(e[i].second, i);\n    }\n    spfa();\n    for (int i = 1; i <= m; i++) {\n        int u = e[i].first, v = e[i].second;\n        if (dis[v] == dis[u] + 1) {\n            cout << bfs(i) << \"\\n\";\n        } else {\n            if (dis[n] == 0x3f3f3f3f) cout << -1 << \"\\n\";\n            else cout << dis[n] << \"\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n# G Game on Tree 2\n## Description\n[题目链接](https://atcoder.jp/contests/abc218/tasks/abc218_g)\n给定一颗 N 个节点的树，每个点有一个奇数值 $A_i$。根节点 1 处有一个棋子，两个人轮流移动棋子到未被访问过的节点。将棋子所到的节点的值保存到 $multiset$，先手希望 $mulitset$ 的中位数尽可能大，后手希望中位数尽可能小。假设两人都按最有决策行动，问最后的中位数是多少。\n## Solution\n可以发现棋子最终会从根节点一直走到叶子节点，并在叶子节点得出中位数的值。\n\n如果能知道叶子节点中位数的值，那么根据 Min-Max 搜索，可以得到根节点移动的最有策略与最优值（即给每个节点一个估值，表示最终能得到的最优结果；先手会选择估值最大的子节点，后手会选择估值最小的子节点；叶子节点的估值为 $multiset$ 的中位数）。\n\n中位数可在 dfs 过程中通过两个 $multiset$ 动态维护。当访问一个节点树，将其加入两个 $multiset$ 中的一个；当删除一个节点时，将其从两个 $multiset$ 中的一个删除；当访问叶子节点时，求出当前两个 $multiset$ 的中位数即可。\n\n需要保证两个 $multiset$ 的大小差值不超过 1，即每次插入或删除操作后需要调整两个 $multiset$ 的大小。\n## Code\n```cpp Game on Tree 2\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 2e5 + 5, MOD = 1e9 + 7;\n\nint n;\nint dp[MAXN], a[MAXN];\nvector<int> g[MAXN];\n\nmultiset<int> s1, s2;\nvoid adjust() {\n    if (s1.size() + 1 < s2.size()) {\n        auto it = s2.begin();\n        s2.erase(it);\n        s1.insert(*it);\n    } else if (s2.size() + 1 < s1.size()) {\n        auto it = s1.end();\n        --it;\n        s1.erase(it);\n        s2.insert(*it);\n    }\n}\n\nvoid insert(int x) {\n    if (!s2.size()) s2.insert(x);\n    else {\n        if (x > *s2.begin()) s2.insert(x);\n        else s1.insert(x);\n    }\n    adjust();\n}\n\nvoid remove(int x) {\n    if (s1.count(x)) s1.erase(s1.find(x));\n    else if (s2.count(x)) s2.erase(s2.find(x));\n    adjust();\n}\n\nint median() {\n    adjust();\n    auto it1 = s1.end();\n    auto it2 = s2.begin();\n    if (s1.size() == s2.size()) return ((*--it1) + (*it2)) >> 1;\n    else if (s1.size() > s2.size()) return *--it1;\n    else return *it2;\n}\n\nvoid DP(int cur, int f, bool isMax) {\n    int mn = 2e9, mx = 0;\n\n    insert(a[cur]);\n\n    for (auto& to : g[cur]) {\n        if (to == f) continue;\n        DP(to, cur, isMax ^ 1);\n        mn = min(mn, dp[to]), mx = max(mx, dp[to]);\n    }\n    if (mx == 0) dp[cur] = median();\n    else if (isMax) dp[cur] = mx;\n    else dp[cur] = mn;\n\n    remove(a[cur]);\n}\n\nint main() {\n    boost;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1, u, v; i < n; i++) {\n        cin >> u >> v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    DP(1, 0, true);\n    cout << dp[1] << \"\\n\";\n    return 0;\n}\n```\n\n官方动态中位数求法：\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nmultiset<int> S,T; // Always S.size()==T.size() or S.size()==T.size()+1\nvoid eval(){\n    if(S.size()){\n        auto itr = S.end(); itr--;\n        T.insert(*itr); S.erase(itr);\n    }\n    while(S.size() < T.size()){\n        S.insert(*T.begin()); T.erase(T.begin());\n    }\n}\nint val(){\n    auto itr = S.end(); itr--;\n    if(S.size()==T.size()+1)return *itr;\n    return (*itr+*T.begin())/2;\n}\nvoid erase(int x){\n    auto itr = S.end(); itr--;\n    if(*itr < x) T.erase(T.lower_bound(x));\n    else S.erase(S.lower_bound(x));\n}\n\nint main(){\n    int n; cin >> n;\n    vector<int> A(n); for(int i = 0; i < n; i++) cin >> A[i];\n    vector<int> dp(n);\n    vector<vector<int>> g(n);\n    for(int i = 0; i < n-1; i++){\n        int a, b; cin >> a >> b; a--; b--;\n        g[a].push_back(b); g[b].push_back(a);\n    }\n    function<void(int,int,int)> dfs=[&](int i,int p,int d){\n        S.insert(A[i]); eval();\n        int mi = 1000000005, ma = 0;\n        for(int x : g[i]) if(x != p) {\n            dfs(x, i, d+1);\n            mi = min(mi,dp[x]); ma = max(ma,dp[x]);\n        }\n        if(ma == 0) dp[i] = val();\n        else if(d&1) dp[i] = mi;\n        else dp[i] = ma;\n        erase(A[i]); eval();\n    }; dfs(0,-1,0);\n    cout << dp[0] << endl;\n}\n```\n","tags":["contest"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 219","url":"/2021/09/21/atcoder-abc-219/","content":"[比赛链接](https://atcoder.jp/contests/abc219)\n<!-- more -->\n# D Strange Lunchbox\n## Description\n[题目链接](https://atcoder.jp/contests/abc219/tasks/abc219_d)\n## Solution\n设 $dp[i][j][k]$ 表示考虑前 $i$ 个盒子，选了 $j$ 个，```takoyaki``` 数量为 $k$ （大于 $k$ 仍记为 $k$）时能获得 ```taiyaki``` 的最大值，状态转移如下：\n\n- 选第 $i$ 个盒子，则 $dp[i][j][min(k,X)] \\leftarrow dp[i-1][j-1][k-A_i] + B_i$，其中 $A_i \\le k \\le X+A_i$。\n- 不选第 $i$ 个盒子，则 $dp[i][j][k] \\leftarrow dp[i-1][j][k]$，其中 $0 \\le k \\le X$。\n\n最后答案为 $\\min \\limits_{1 \\le j \\le N}dp[N][j][X]$。\n\n时间复杂度：$O(N^2X)$。\n## Code\n```cpp Strange Lunchbox\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 3E2 + 5;\nconst int MOD = 1E9 + 7;\nint n, x, y;\nint dp[2][MAXN][MAXN], a[MAXN], b[MAXN];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> x >> y;\n    for (int i = 1; i <= n; i++) cin >> a[i] >> b[i];\n    memset(dp, -1, sizeof(dp));\n    dp[0][0][0] = 0;\n    for (int i = 1; i <= n; i++) {\n        memset(dp[i & 1], -1, sizeof(dp[i & 1]));\n        for (int j = 0; j <= i; j++) {\n            for (int k = 0; k <= x + a[i]; k++) {\n                if (j && k - a[i] >= 0 &&\n                    dp[(i & 1) ^ 1][j - 1][k - a[i]] != -1)\n                    dp[i & 1][j][min(k, x)] =\n                        max(dp[i & 1][j][min(k, x)],\n                            dp[(i & 1) ^ 1][j - 1][k - a[i]] + b[i]);\n\n                if (dp[(i & 1) ^ 1][j][min(k, x)] != -1)\n                    dp[i & 1][j][min(k, x)] = max(\n                        dp[i & 1][j][min(k, x)], dp[(i & 1) ^ 1][j][min(k, x)]);\n            }\n        }\n    }\n    for (int j = 0; j <= n; j++)\n        if (dp[n & 1][j][x] >= y) {\n            cout << j;\n            return 0;\n        }\n    cout << -1;\n    return 0;\n}\n```\n\n# E Moat\n## Description\n[题目链接](https://atcoder.jp/contests/abc219/tasks/abc219_e)\n## Solution\n由于矩阵大小为 $4*4$，我们可以枚举哪些格子没有被护城河包围，哪些格子被护城河包围。在一个合法方案中，所有城市应该被护城河包围，且被包围的格子和没有被包围的格子恰好形成两个联通块（规定边界的没有被包围的格子和外部一个超级源点相连），因此二进制枚举包围状态，然后用并查集求联通块个数即可。\n## Code\n```cpp Moat\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, ans;\nint a[4][4], num[4][4], fa[17];\n\nint find(int x) {\n    if (fa[x] != x) fa[x] = find(fa[x]);\n    return fa[x];\n}\n\nvoid unionn(int a, int b) {\n    int r1 = find(a), r2 = find(b);\n    if (r1 != r2) fa[r2] = r1;\n}\n\nsigned main() {\n    for (int i = 0; i < 4; i++)\n        for (int j = 0; j < 4; j++) cin >> a[i][j], num[i][j] = i * 4 + j;\n    for (int s = 0; s < (1 << 16); s++) {\n        for (int i = 0; i <= 16; i++) fa[i] = i;\n        for (int i = 0; i < 4; i++)\n            for (int j = 0; j < 4; j++) {\n                if (i) {\n                    if (!((s >> num[i][j]) & 1) && !((s >> num[i - 1][j]) & 1))\n                        unionn(num[i - 1][j], num[i][j]);\n                    if (((s >> num[i][j]) & 1) && ((s >> num[i - 1][j]) & 1))\n                        unionn(num[i][j], num[i - 1][j]);\n                }\n                if (j) {\n                    if (((s >> num[i][j]) & 1) && ((s >> num[i][j - 1]) & 1))\n                        unionn(num[i][j], num[i][j - 1]);\n                    if (!((s >> num[i][j]) & 1) && !((s >> num[i][j - 1]) & 1))\n                        unionn(num[i][j - 1], num[i][j]);\n                }\n            }\n\n        for (int i = 0; i < 4; i++)\n            for (int j = 0; j < 4; j++)\n                if ((!i || !j || i == 3 || j == 3) && !((s >> num[i][j]) & 1))\n                    unionn(16, num[i][j]);\n        int cnt = 0;\n        for (int i = 0; i <= 16; i++)\n            if (fa[i] == i) cnt++;\n        if (cnt != 2) continue;\n        bool ok = 1;\n        for (int i = 0; i < 4; i++)\n            for (int j = 0; j < 4; j++)\n                if (a[i][j] && !((s >> num[i][j]) & 1)) ok = 0;\n        ans += ok;\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n# F Cleaning Robot \n## Description\n[题目链接](https://atcoder.jp/contests/abc219/tasks/abc219_f)\n## Solution\n设第 $1$ 次执行指令访问到的点集为 \n\n$V_1=\\{(X_1,Y_1),(X_2,Y_2),\\dots,(X_n,Y_n)\\}$\n\n记终止位置为 $(a,b)$。类似定义第 $2k$ 次执行指令访问到的点集：\n\n$V_2=\\{(X_1+a,Y_1+b),(X_2+a,Y_2+b),\\dots,(X_n+a,Y_n+b)\\}$\n$\\vdots$\n$V_k=\\{(X_1+(k-1)a,Y_1+(k-1)b),(X_2+(k-1)a,Y_2+(k-1)b),\\dots,(X_n+(k-1)a,Y_n+(k-1)b)\\}$\n\n对 $(X_i,Y_i)∈V_1$，记 $d_i$ 为最小的满足 $(X_i+d_ia,Y_i+d_ib)∈V_1$ 的正整数（没有则为 $\\infty$)。由反证法可知 $(X_i,Y_i),\\dots,(X_i+(d_i-1)a,Y_i+(d_i-1)b)$ 不会与从 $(X_j,Y_j),j \\neq i$ 开始执行过程中访问到的点重复，否则会存在一个更小的 $d$，同时容易知道答案为 $\\sum\\limits_{i=1}^{n}min(d_i,k)$。\n\n接下来考虑如何求解 $d$。\n\n设 $q_i=\\lfloor \\frac{X_i}{a} \\rfloor,S_i=X_i-aq_i,T_i=Y_i-bq_i$，那么 $(X_j,Y_j)=(X_i+da,Y_i+db)⇔(S_i,Y_i) = (S_j,T_j)⇔(X_j,Y_j)=(X_i+(q_j-q_i)a,Y_i+(q_j-q_i)b)$。我们先根据 $(S,T)$ 对 $q$ 分组，再进行组内排序，相邻两项的差就是 $d$。\n\n时间复杂度：$O(|S|log|S|)$。\n## Code\n```cpp Cleaning Robot \n#include <bits/stdc++.h>\n\n#define debug(a) cerr << #a << \" = \" << a << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\n\nint cnt = 0;\nLL k;\nstring s;\nset<pair<int, int>> p;\nmap<pair<int, int>, int> mp;\nvector<int> q[MAXN];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> s >> k;\n    int a = 0, b = 0;\n    p.insert({a, b});\n    for (auto& c : s) {\n        if (c == 'U') b--;\n        if (c == 'D') b++;\n        if (c == 'L') a--;\n        if (c == 'R') a++;\n        p.insert({a, b});\n    }\n    if (!a && !b) return cout << p.size(), 0;\n    for (auto& [x, y] : p) {\n        int m1 = a ? (x % a + a) % a : (y % b + b) % b;\n        int k = a ? (x - m1) / a : (y - m1) / b;\n        int m2 = a ? y - k * b : x - k * a;\n        int id = mp[{m1, m2}];\n        if (!id) {\n            mp[{m1, m2}] = ++cnt;\n            q[cnt].push_back(k);\n        } else\n            q[id].push_back(k);\n    }\n    LL ans = 0;\n    for (int i = 1; i <= cnt; i++) {\n        sort(q[i].begin(), q[i].end());\n        for (int j = 0; j < q[i].size() - 1; j++)\n            ans += min(k, (LL)q[i][j + 1] - q[i][j]);\n        ans += k;\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n# G Propagation\n## Description\n[题目链接](https://atcoder.jp/contests/abc219/tasks/abc219_g)\n## Solution\n将每次询问分为下面两步操作：\n\n1. 根据相邻点的修改状态更新当前点的值。\n2. 根据当前点的度修改周围节点的值/打上延迟修改标记。\n\n对于操作 $2$，若当前点的度小于 $B$，则直接将所有相邻点的值修改为当前点的值，并记录这些点的最后一次被修改的时刻（$qid$）为当前询问编号；若当前点的度大于等于 $B$，则不立刻更新相邻点的值，而是对这个点记录当前询问编号为 $sign$，同时用 $tag$ 记录该点的值。\n\n对于操作 $1$，由于对度大于等于 $B$ 的点采用延迟更新，因此我们要遍历这些点，并根据这些点的状态更新当前点的值。具体的，如果某一度大于等于 $B$ 的点的 $sign$ 大于等于当前点 $qid$，说明需要更新，将 $tag$ 赋给当前点，同时将当前点的 $qid$ 更新为 $sign$。\n\n由于度大于等于 $B$ 的点不超过 $\\frac{2M}{B}$ 个，因此总的复杂度为 $O(Q(B+\\frac{2M}{B})$。由均值不等式可知，$B$ 取 $\\sqrt{M}$ 比较合适。\n\n类似题目：[CF1580C Train Maintenance](http://codeforces.com/problemset/problem/1580/C)([参考代码](https://codeforces.com/contest/1580/submission/130616952))、[CF342E Xenia and Tree](https://codeforces.com/contest/342/problem/E)([参考代码](https://codeforces.com/contest/342/submission/131023346))\n## Code\n```cpp Propagation\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, q, B;\nvector<int> G[MAXN];\narray<int, MAXN> v, sign, qid, deg, tag;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m >> q;\n    B = max((int)sqrt(m), 1);\n    for (int i = 1, u, v; i <= m; i++) {\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n        deg[v]++, deg[u]++;\n    }\n    auto cmp = [&](int& a, int& b) -> bool { return deg[a] > deg[b]; };\n    for (int i = 1; i <= n; i++) v[i] = i, sort(G[i].begin(), G[i].end(), cmp);\n    for (int i = 1, x; i <= q; i++) {\n        cin >> x;\n        for (auto& to : G[x]) {\n            if (deg[to] < B) break;\n            if (sign[to] > qid[x]) {\n                qid[x] = sign[to];\n                v[x] = tag[to];\n            }\n        }\n        if (deg[x] < B)\n            for (auto& to : G[x]) v[to] = v[x], qid[to] = i;\n        else\n            sign[x] = i, tag[x] = v[x];\n    }\n    for (int i = 1; i <= n; i++) {\n        for (auto& to : G[i]) {\n            if (deg[to] < B) break;\n            if (sign[to] > qid[i]) {\n                qid[i] = sign[to];\n                v[i] = tag[to];\n            }\n        }\n        cout << v[i] << \" \";\n    }\n    return 0;\n}\n```\n\n\n","tags":["动态规划","contest","状态压缩","分块"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 217","url":"/2021/09/08/atcoder-abc-217/","content":"[比赛链接](https://atcoder.jp/contests/abc217)\n<!-- more -->\n# D Cutting Woods\n## Description\n[题目链接](https://atcoder.jp/contests/abc217/tasks/abc217_d)\n## Solution\n设 $x_1 \\le x \\le x_2$，$x_1,x_2$ 分别为 $x$ 左边第一个被切过的位置和右边第一个被切过的位置，那么 $x$ 所属木头段的长度为 $x_2-x_1$。为了快速求得 $x_1,x_2$，我们将切过的位置插入 ```set``` 中，查询时使用 ```upper_bound``` 函数即可。\n## Code\n```cpp Cutting Woods\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, T;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    set<int> s;\n    s.insert(n);\n    s.insert(0);\n    for (int i = 1; i <= m; i++) {\n        int c, x;\n        cin >> c >> x;\n        if (c == 1) {\n            s.insert(x);\n        } else {\n            auto it = s.lower_bound(x);\n            int r = *it;\n            int l = *(--it);\n            cout << r - l << endl;\n        }\n    }\n    return 0;\n}\n```\n\n# E Sorting Queries\n## Description\n[题目链接](https://atcoder.jp/contests/abc217/tasks/abc217_e)\n## Solution\n观察任意时刻序列的结构，容易发现它是由一段升序的序列和一段乱序的序列构成的。对于操作 $1$，我们将新的元素插在乱序序列的尾部；对于操作 $2$，取升序序列中首元素，若升序序列为空则取乱序序列的首元素；对于操作 $3$，我们将乱序序列的元素转移到升序序列中，将元素升序排列。比较自然的想到用队列维护乱序序列，用 ```set``` 维护升序序列以快速完成操作 $3$ 中元素顺序的调整。\n## Code\n```cpp Sorting Queries\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, T;\n\nmultiset<int> s;\nqueue<int> q;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        int type, x;\n        cin >> type;\n        if (type == 1)\n            cin >> x, q.push(x);\n        else if (type == 2) {\n            if (s.size())\n                cout << *s.begin() << endl, s.erase(s.begin());\n            else\n                cout << q.front() << endl, q.pop();\n        } else {\n            while (!q.empty()) {\n                s.insert(q.front());\n                q.pop();\n            }\n        }\n    }\n    return 0;\n}\n```\n\n# F Make Pair\n## Description\n[题目链接](https://atcoder.jp/contests/abc217/tasks/abc217_f)\n## Solution\n设 $dp[l][r]$ 表示将区间 $[l,r]$ 的学生配对的方案数，采用区间 $DP$，考虑如下转移（规定所有区间长为偶数）：\n- 学生 $l$ 和 $r$ 可配对，则有 $dp[l][r] \\leftarrow dp[l+1][r-1]$。 \n- 学生 $l$ 和 $r$ 不可配对，我们枚举中间位置 $k$。此时我们已知 $dp[l][k]$ 和 $dp[k+1][r]$，记 $[l,k]$ 对应 $x = \\frac{k-l+1}{2}$ 对学生，$[k+1,r]$ 对应 $y = \\frac{r-k}{2}$ 对学生。由乘法原理，将这 $x+y$ 对学生配对的方案数等于 $dp[l][k]$ 乘 $dp[k+1][r]$ 再乘上将这 $x+y$ 对学生进行组合，并保证各自原有的相对顺序不变的方案数。这个方案数可用隔板法求解，结果为 $\\binom{x+y}{x}$。于是我们得到 $dp[l][r] \\leftarrow dp[l][k]*dp[k+1][r]*\\binom{x+y}{x}$。为了保证不重复计算答案，这里要求学生 $l$ 和 $k$ 能配对（假设学生 $l$ 和 $k$ 不可配对，那么一定存在一个位置 $k'$ 和 $l$ 配对，那么我们得到了三段区间，分别为 $[l,k']$，$[k'+1,k]$，$[k+1,r]$。显然将 $[k'+1,k]$ 归到 $[l,k']$ 和归到 $[k+1,r]$ 是等价的，这两种情况下学生的配对方式是完全一样的）。\n## Code\n```cpp Make Pair\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 4E2 + 5;\nconst int MOD = 998244353;\nint n, m, T;\nLL dp[MAXN][MAXN], fac[MAXN * 2], inv[MAXN * 2];\nbool good[MAXN][MAXN];\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a % MOD;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nvoid add(LL& a, LL b) { a = (a + b) % MOD; }\n\nvoid init() {\n    fac[0] = inv[0] = 1;\n    for (int i = 1; i <= n * 2; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = qpow(fac[i], MOD - 2, MOD);\n    }\n}\n\nLL C(int n, int m) { return fac[n] * inv[m] % MOD * inv[n - m] % MOD; }\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    n *= 2;\n    init();\n    for (int i = 1; i <= m; i++) {\n        int a, b;\n        cin >> a >> b;\n        good[a][b] = 1;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (good[i][i + 1]) dp[i][i + 1] = 1;\n        dp[i][i - 1] = 1;\n    }\n\n    for (int len = 4; len <= n; len += 2)\n        for (int l = 1; l + len - 1 <= n; l++) {\n            int r = l + len - 1;\n            if (good[l][r]) add(dp[l][r], dp[l + 1][r - 1]);\n            for (int k = l + 1; k <= r - 2; k += 2) {\n                int x = (k - l + 1) / 2, y = (r - k) / 2;\n                if (good[l][k])\n                    add(dp[l][r], dp[l + 1][k - 1] * dp[k + 1][r] % MOD *\n                                      C(y + x, x) % MOD);\n            }\n        }\n    cout << dp[1][n];\n    return 0;\n}\n```\n\n# G Groups\n## Description\n[题目链接](https://atcoder.jp/contests/abc217/tasks/abc217_g)\n## Solution\n设 $dp[i][j]$ 表示考虑前 $i$ 个元素，分了 $j$ 组，各组内元素对 $M$ 取模的结果互不相同的方案数。显然，我们此时最多分 $i$ 组，最少分 $\\lfloor \\frac{(i+M-1)}{M} \\rfloor$ 组，因为 $[1...i]$ 与 $i$ 模 $M$ 同余的数有 $\\lfloor \\frac{(i+M-1)}{M} \\rfloor$ 个。对于第 $i$ 个元素，我们要么将其单独分一组，此时有 $dp[i][j]\\leftarrow dp[i-1][j-1]$；要么将其分到已有的 $j$ 组中，但这些组中不能有与之同余的元素，这样的组有 $j - \\lfloor \\frac{i - 1}{M} \\rfloor$ 个，因此有 $dp[i][j] \\leftarrow dp[i-1][j]*(j - \\lfloor \\frac{i - 1}{M} \\rfloor)$。初始条件为 $dp[0][0] = 1$。\n## Code\n```cpp Groups\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 5E3 + 5;\nconst int MOD = 998244353;\nint n, m, T;\nLL dp[MAXN][MAXN];\n\nvoid add(LL& a, LL b) { a = (a + b) % MOD; }\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        int mi = (i + m - 1) / m;\n        for (int k = mi; k <= i; k++) {\n            if (k <= i - 1)\n                add(dp[i][k], dp[i - 1][k] * (k - (i - 1) / m) % MOD);\n            add(dp[i][k], dp[i - 1][k - 1]);\n        }\n    }\n    for (int i = 1; i <= n; i++) cout << dp[n][i] << \"\\n\";\n    return 0;\n}\n```\n\n\n","tags":["动态规划","组合计数","contest","set"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 216","url":"/2021/09/01/atcoder-abc-216/","content":"[比赛链接](https://atcoder.jp/contests/abc216)\n<!-- more -->\n# D Pair of Balls\n## Description\n[题目链接](https://atcoder.jp/contests/abc216/tasks/abc216_d)\n## Solution\n模拟题，用 $M$ 个栈存储各个圆柱中的球，如果某个颜色的球在栈顶出现两次则将它们弹出，最后看是否有栈非空即可。\n## Code\n```cpp Pair of Balls\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\n\nint n, m;\nstack<int> s[MAXN];\nvector<int> pos[MAXN];\nint cnt[MAXN];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        int k;\n        cin >> k;\n        for (int j = 1; j <= k; j++) {\n            int a;\n            cin >> a;\n            s[i].push(a);\n            pos[a].push_back(i);\n        }\n    }\n\n    queue<int> q;\n    for (int i = 1; i <= m; i++) {\n        cnt[s[i].top()]++;\n        if (cnt[s[i].top()] == 2) q.push(s[i].top());\n    }\n\n    while (!q.empty()) {\n        int c = q.front();\n        q.pop();\n        s[pos[c][0]].pop(), s[pos[c][1]].pop();\n        if (s[pos[c][0]].size()) {\n            int ca = s[pos[c][0]].top();\n            cnt[ca]++;\n            if (cnt[ca] == 2) q.push(ca);\n        }\n        if (s[pos[c][1]].size()) {\n            int ca = s[pos[c][1]].top();\n            cnt[ca]++;\n            if (cnt[ca] == 2) q.push(ca);\n        }\n    }\n\n    for (int i = 1; i <= m; i++)\n        if (s[i].size()) {\n            puts(\"No\");\n            return 0;\n        }\n    puts(\"Yes\");\n    return 0;\n}\n```\n\n# E Amusement Park\n## Description\n[题目链接](https://atcoder.jp/contests/abc216/tasks/abc216_e)\n## Solution\n二分满足 $\\sum \\limits_{i=1}^{N} max(0,A_i-x+1) \\le K$ 的最小值 $x$。对于公园 $i$，若 $A_i \\ge x$，那么 ```Takahashi ``` 可获得的满足度为 $x+(x+1)+\\dots+A_i$。除此之外，他还会获得 $(x-1)*(K-\\sum \\limits_{i=1}^{N} max(0,A_i-x+1))$ 的满足度。\n## Code\n```cpp Amusement Park\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e5 + 5, MOD = 1e9 + 7;\n\n#define int long long\n\nint n, k;\nint a[MAXN], mx;\nunsigned int ans;\n\nbool check(int mid) {\n    int tot(0);\n    for (int i = 1; i <= n; i++) \n        if (a[i] >= mid) tot += a[i] - mid + 1;\n    return tot <= k;\n}\n\nsigned main() {\n    boost;\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) cin >> a[i], mx = max(mx, a[i]);\n    int l = 1, r = 2e9, tmp = 2e9;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (check(mid)) r = mid - 1, tmp = mid;\n        else l = mid + 1;\n    }\n    int tot(0);\n    for (int i = 1; i <= n; i++) {\n        if (a[i] >= tmp) {\n            tot += a[i] - tmp + 1;\n            ans += (a[i] + tmp) * (a[i] - tmp + 1) / 2;\n        }\n    }\n    ans += (k - tot) * (tmp - 1);\n    cout << ans << \"\\n\";\n    return 0;\n}\n```\n\n# F Max Sum Counting\n## Description\n[题目链接](https://atcoder.jp/contests/abc216/tasks/abc216_f)\n## Solution\n若指定 $A_i$ 为最大值，取 $S = \\{j|(j<i ∧ A_j \\le A_i)|(j>i ∧ A_j<A_i)\\}$，那么问题转化成求满足 $S' \\subset S ∧ \\sum \\limits_{j∈S'} B_j \\le A_i-B_i$ 的 $S'$ 的数目，这可以用 $O(N^2)$ 的 $DP$ 求解。如果 $A$ 不是单增的，那么不同的 $i$ 对应的 $S$ 可能没有包含关系，这时需要重新 $DP$，从而总的时间复杂度为 $O(N^3)$。将 $A$ 升序排列，那么当前 $S$ 是从之前的 $S$ 扩展得到的，因此可以延用之前 $DP$ 的结果，从而时间复杂度降至 $O(N^2)$。\n## Code\n```cpp Max Sum Counting\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 5E3 + 5;\nconst int MOD = 998244353;\nint n, ans;\nint dp[MAXN][MAXN];\n\nvoid add(int& a, int b) { a = (a + b) % MOD; }\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    vector<pair<int, int>> v;\n    v.resize(n + 1);\n    for (int i = 1; i <= n; i++) cin >> v[i].first;\n    for (int i = 1; i <= n; i++) cin >> v[i].second;\n    sort(v.begin(), v.end());\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n        for (int s = 0; s <= v[n].first; s++) {\n            add(dp[i][s], dp[i - 1][s]);\n            if (s - v[i].second >= 0) add(dp[i][s], dp[i - 1][s - v[i].second]);\n        }\n    sort(v.begin(), v.end());\n    for (int i = 1; i <= n; i++) {\n        int mx = v[i].first;\n        int s = mx - v[i].second;\n        for (int j = 0; j <= s; j++) add(ans, dp[i - 1][j]);\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n# G 01Sequence\n## Description\n[题目链接](https://atcoder.jp/contests/abc216/tasks/abc216_g)\n## Solution\n将区间按右端点升序排列，将 1 尽可能放在区间右边即可。实现过程中需要求解区间内 1 的个数，查询区间内从右往左第一个不为 1 的位置，将不为 1 的位置用 1 覆盖，这些操作用树状数组和并查集便可快速实现。\n## Code\n```cpp 01Sequence\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, fa[MAXN];\n\nvector<tuple<int, int, int>> v;\n\nstruct BIT {  // Binary Index Trees, 1based\n    int lowbit(int x) { return x & (~x + 1); }\n    /* O(n) build tree*/\n    BIT() {\n        for (int i = 1; i <= n; i++) c[i] = 0;\n    }\n    void build() {\n        for (int i = 1; i <= n; i++) {\n            int j = i + lowbit(i);  // j is father of i\n            if (j <= n) c[j] += c[i];\n        }\n    }\n    /*@param x the position to add val*/\n    void add(int x, LL val) {\n        while (x <= n) c[x] += val, x += lowbit(x);\n    }\n    /*range [1, x] sum query*/\n    LL query(int x, LL res = 0) {\n        while (x) res += c[x], x -= lowbit(x);\n        return res;\n    }\n    array<LL, MAXN> c;\n} bit[3];\n/*range [l, r] add val*/\ninline void add(int l, int r, LL val) {\n    bit[1].add(l, val), bit[1].add(r + 1, -val);\n    bit[2].add(l, val * l), bit[2].add(r + 1, -val * (r + 1));\n}\n/*range [l, r] sum query*/\ninline LL query(int l, int r, LL res = 0) {\n    res = bit[0].query(r) + bit[1].query(r) * (r + 1) - bit[2].query(r);\n    res -= bit[0].query(l - 1) + bit[1].query(l - 1) * l - bit[2].query(l - 1);\n    return res;\n}\n\nint find(int x) {\n    if (fa[x] != x) fa[x] = find(fa[x]);\n    return fa[x];\n}\n\nsigned main() {\n    read(n, m);\n    for (int i = 1; i <= n; i++) fa[i] = i;\n    v.resize(m);\n    for (auto& [r, l, x] : v) read(l, r, x);\n    sort(v.begin(), v.end());\n    for (auto& [r, l, x] : v) {\n        int v = query(l, r);\n        if (v >= x) continue;\n        x -= v;\n        int p = r;\n        while (x) {\n            p = find(p);\n            add(p, p, 1);\n            fa[p] = p - 1;\n            x--;\n        }\n    }\n    for (int i = 1; i <= n; i++) printf(\"%d \", query(i, i));\n    return 0;\n}\n```\n\n\n","tags":["动态规划","二分答案","贪心","contest","树状数组","模拟","并查集"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 215","url":"/2021/08/30/atcoder-abc-215/","content":"[比赛链接](https://atcoder.jp/contests/abc215)\n<!-- more -->\n# D Coprime 2\n## Description\n[题目链接](https://atcoder.jp/contests/abc215/tasks/abc215_d)\n## Solution\n先预处理哪些质因数出现过，那么满足条件的数不能含有这些质因数。\n## Code\n```cpp Coprime 2\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, m, vis[MAXN];\nvector<int> divs[MAXN];\n\nint main() {\n    boost;\n    cin >> n >> m;\n    for (int i = 1; i < MAXN; i++)\n        for (int j = i; j < MAXN; j += i)\n            divs[j].push_back(i);\n    for (int i = 1, tmp; i <= n; i++) {\n        cin >> tmp;\n        for (auto& j : divs[tmp]) vis[j] = true;\n    }\n    vis[1] = 0;\n    vector<int> ans;\n    for (int i = 1; i <= m; i++) {\n        bool ok = true;\n        for (auto& j : divs[i]) if (vis[j]) ok = false;\n        if (ok) ans.push_back(i);\n    }\n    cout << ans.size() << \"\\n\";\n    for (auto& i : ans) cout << i << \"\\n\";\n    return 0;\n}\n```\n\n# E Chain Contestant\n## Description\n[题目链接](https://atcoder.jp/contests/abc215/tasks/abc215_e)\n## Solution\n设 $dp[i][j][k]$ 表示考虑到第 $i$ 个字符，已选择的字符集为 $j(j \\neq \\empty)$，最后一个选取的字符为 $k$ 的方案数。\n\n考虑第 $i+1$ 个字符 $k'$：\n1. 加入字符 $k'$\n    - 若 $k' \\in j$，必有 $k'=k$，从而有 $dp[i+1][j][k'] \\leftarrow dp[i][j][k]$。\n    - 若 $k' \\notin j$，有 $dp[i+1][j∪k'][k'] \\leftarrow dp[i][j][k]$。\n    - 若 $k'$ 是第一个加入的字符，有 $dp[i+1][k'][k'] \\leftarrow 1$。\n\n2. 不加入字符 $k'$\n    - 字符集和最后加入的字符都没有改变，有 $dp[i+1][j][k] \\leftarrow dp[i][j][k]$。\n## Code\n```cpp Chain Contestant\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1025;\nconst int MOD = 998244353;\nint n, a[MAXN];\nint dp[2][MAXN][10];\n\nvoid add(int& a, int b) { a = (a + b) % MOD; }\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        char c;\n        cin >> c;\n        a[i] = c - 'A';\n    }\n    // 10 为空\n    for (int i = 1; i <= n; i++) {\n        memset(dp[i & 1], 0, sizeof(dp[i & 1]));\n        // 空串\n        add(dp[i & 1][1 << a[i]][a[i]], 1);\n        // 非空串\n        for (int s = 1; s < (1 << 10); s++) {\n            if ((s >> a[i]) & 1) {\n                // 选 a[i]\n                add(dp[i & 1][s][a[i]], dp[(i & 1) ^ 1][s][a[i]]);\n                // 不选 a[i]\n                for (int k = 0; k <= 9; k++)\n                    if ((s >> k) & 1)\n                        add(dp[i & 1][s][k], dp[(i & 1) ^ 1][s][k]);\n            } else {\n                // 选 a[i]\n                for (int k = 0; k <= 9; k++) {\n                    if ((s >> k) & 1)\n                        add(dp[i & 1][s | (1 << a[i])][a[i]],\n                            dp[(i & 1) ^ 1][s][k]);\n                }\n                // 不选 a[i]\n                for (int k = 0; k <= 9; k++) {\n                    if ((s >> k) & 1)\n                        add(dp[i & 1][s][k], dp[(i & 1) ^ 1][s][k]);\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < (1 << 10); i++)\n        for (int k = 0; k < 10; k++)\n            if ((i >> k) & 1) add(ans, dp[n & 1][i][k]);\n    cout << ans;\n    return 0;\n}\n```\n\n# F Dist Max 2\n## Description\n[题目链接](https://atcoder.jp/contests/abc215/tasks/abc215_f)\n## Solution\n将点按横坐标排序，二分最大距离 $d$，接下验证最大距离能否至少是 $d$。对于点 $i$，满足和它距离至少是 $d$ 的点的横坐标一定小于等于 $x_i-d$，设这些点在区间 $[1,k]$ 中，$k$ 可以用 ```lower_bound``` 快速求得。在这些点中，必须存在一个点 $j$，满足 $|y_j-y_i| \\ge d$。我们不必考察区间内每一个点的纵坐标，而只需要考察区间内 $y$ 的最大值和最小值，这里区间最值可用线段树快速求解（也可以利用单调队列）。\n\n时间复杂度：$O(NlogNlog\\max \\limits_{1 \\le i \\le N}(x_i,y_i))$ 或 $O(Nlog\\max \\limits_{1 \\le i \\le N}(x_i,y_i))$，取决于区间最值的求解方式。\n## Code\n```cpp Dist Max 2\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, T;\n\n#define lid id << 1\n#define rid id << 1 | 1\n\nvector<pair<int, int>> p;\n\nstruct node {\n    int l, r;\n    int mx, mi;\n} tr[MAXN << 2];\n\nvoid update(int id) {\n    tr[id].mx = max(tr[lid].mx, tr[rid].mx);\n    tr[id].mi = min(tr[lid].mi, tr[rid].mi);\n}\n\nvoid build(int id, int l, int r) {\n    tr[id].l = l, tr[id].r = r;\n    if (l == r) {\n        tr[id].mx = p[l].second;\n        tr[id].mi = p[l].second;\n        return;\n    }\n    int mid = l + r >> 1;\n    build(lid, l, mid);\n    build(rid, mid + 1, r);\n    update(id);\n}\n\nint qmin(int id, int l, int r) {\n    if (tr[id].l == l && tr[id].r == r) return tr[id].mi;\n    int mid = tr[id].l + tr[id].r >> 1;\n    if (r <= mid)\n        return qmin(lid, l, r);\n    else if (l > mid)\n        return qmin(rid, l, r);\n    else\n        return min(qmin(lid, l, mid), qmin(rid, mid + 1, r));\n}\n\nint qmax(int id, int l, int r) {\n    if (tr[id].l == l && tr[id].r == r) return tr[id].mx;\n    int mid = tr[id].l + tr[id].r >> 1;\n    if (r <= mid)\n        return qmax(lid, l, r);\n    else if (l > mid)\n        return qmax(rid, l, r);\n    else\n        return max(qmax(lid, l, mid), qmax(rid, mid + 1, r));\n}\n\nbool check(int mid) {\n    for (int i = 1; i <= n; i++) {\n        int id1 = lower_bound(p.begin() + 1, p.end(),\n                              make_pair(p[i].first + mid, 0)) -\n                  p.begin();\n        int id2 = upper_bound(p.begin() + 1, p.end(),\n                              make_pair(p[i].first - mid, 0)) -\n                  p.begin() - 1;\n        bool tag = 0;\n        if (id1 <= n) {\n            if (qmax(1, id1, n) - p[i].second >= mid ||\n                p[i].second - qmin(1, id1, n) >= mid)\n                tag = 1;\n            else\n                tag = 0;\n        }\n        if (id2 >= 1) {\n            if (qmax(1, 1, id2) - p[i].second >= mid ||\n                p[i].second - qmin(1, 1, id2) >= mid)\n                tag = 1;\n            else\n                tag = 0;\n        }\n        if (tag) return true;\n    }\n    return false;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    p.resize(n + 1);\n    for (int i = 1; i <= n; i++) cin >> p[i].first >> p[i].second;\n    sort(p.begin() + 1, p.end());\n    build(1, 1, n);\n    int l = 0, r = 1e9, ans;\n    while (l <= r) {\n        int mid = l + r >> 1;\n        if (check(mid)) {\n            ans = mid;\n            l = mid + 1;\n        } else\n            r = mid - 1;\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n# G Colorful Candies 2\n## Description\n[题目链接](https://atcoder.jp/contests/abc215/tasks/abc215_g)\n## Solution\n设总共有 $C$ 种不同的颜色，定义随机变量 $X_i$ 表示是否有颜色 $i$，$m_i$ 表示第 $i$ 种颜色出现次数，则对于给定的 $K$，答案为 $\\sum\\limits_{i=1}^{C} EX_i= \\sum\\limits_{i=1}^{C} \\frac{\\binom{N}{K}-\\binom{N-m_i}{K}}{\\binom{N}{K}}$。直接求解的话时间复杂度为 $O(NC)$ 无法通过。\n\n注意到 $\\frac{\\binom{N}{K}-\\binom{N-m_i}{K}}{\\binom{N}{K}}$ 在 $m$ 相同时的值是一样的，设 $f(m)$ 表示出现 $m$ 次的颜色有多少种，设不同的 $m$ 有 $M$ 个，分别为 $g_1,g_2,\\dots,g_M$，那么答案又可以写成 $\\sum\\limits_{i=1}^{M}\\frac{\\binom{N}{K}-\\binom{N-g_i}{K}}{\\binom{N}{K}}*f(g_i)$。由 $N = g_1*f(g_1) +  g_2*f(g_2) + \\dots + g_M*f(g_M) \\ge 1*f(1)+2*f(2)+\\dots+M*f(M) \\ge 1+2+\\dots+M$ 可知 $M$ 不超过 $\\sqrt{N}$，因此可在 $O(\\sqrt{N})$ 时间内完成单次求解，从而总的时间复杂度为 $O(N\\sqrt{N})$。\n## Code\n```cpp Colorful Candies 2\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 5E4 + 5;\nconst int MOD = 998244353;\nint n;\nunordered_map<int, int> cntc, cntm;\nLL fac[MAXN], inv[MAXN];\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a % MOD;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nLL C(LL n, LL m) {\n    if (m > n) return 0;\n    return fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    fac[0] = inv[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        int c;\n        cin >> c;\n        cntc[c]++;\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = qpow(fac[i], MOD - 2, MOD);\n    }\n    for (auto& pii : cntc) cntm[pii.second]++;\n    for (int k = 1; k <= n; k++) {\n        LL ans = 0;\n        LL v1 = C(n, k);\n        LL inv1 = qpow(v1, MOD - 2, MOD);\n        for (auto& pii : cntm) {\n            ans += (v1 - C(n - pii.first, k)) * pii.second % MOD * inv1 % MOD;\n            ans %= MOD;\n        }\n        cout << (ans + MOD) % MOD << endl;\n    }\n    return 0;\n}\n```\n\n\n","tags":["线段树","动态规划","二分答案","组合计数","contest","数学期望","单调队列"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 212","url":"/2021/08/26/atcoder-abc-212/","content":"[比赛链接](https://atcoder.jp/contests/abc212)\n<!-- more -->\n# D Querying Multiset\n## Description\n[题目链接](https://atcoder.jp/contests/abc212/tasks/abc212_d)\n## Solution\n记录一个全局增量，然后用 ```multiset``` 维护即可。具体怎么维护可参考 [Venice Technique](https://codeforces.ml/blog/entry/58316)。\n## Code\n```cpp Querying Multiset\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define int long long\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, T;\n\nstruct VeniceSet {\n    multiset<int> S;\n    int water_level = 0;\n    void add(int v) { S.insert(v + water_level); }\n    void remove(int v) { S.erase(S.find(v + water_level)); }\n    void updateAll(int v) { water_level += v; }\n    int getMin() { return *S.begin() - water_level; }\n    int size() { return S.size(); }\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    VeniceSet s;\n    for (int i = 1; i <= n; i++) {\n        cin >> m;\n        if (m == 1)\n            cin >> T, s.add(T);\n        else if (m == 2)\n            cin >> T, s.updateAll(-T);\n        else {\n            int v = s.getMin();\n            cout << v << endl;\n            s.remove(v);\n        }\n    }\n    return 0;\n}\n```\n\n# E Safety Journey\n## Description\n[题目链接](https://atcoder.jp/contests/abc212/tasks/abc212_e)\n## Solution\n首先要知道如果给出的图是完全图该怎么处理：\n\n设 $dp_{i,j}$ 表示从 1 号点出发，走 $k$ 步到达 $i$ 的方案数。假设 $dp_{i,k}$ 已求出，考虑求解 $dp_{i,k+1}$。由于是完全图，因此从除了 $i$ 以外的点再走一步都可以到达 $i$。记 $S_k = \\sum \\limits_{i=1}^{n}dp_{i,k}$，于是有 $dp_{i,k+1} = S_k-dp_{i,k}$，从而可以在 $O(NK)$ 时间内得到答案 $dp_{1,K}$。\n  \n本题在完全图中去掉了一些边，但可以借鉴上述做法，记录哪些点不和当前节点直接相连，然后将这些点对 $S$ 的贡献扣除即可。\n## Code\n```cpp Safety Journey\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 5005;\nconst int MOD = 998244353;\nint n, m, k, u, v;\nvector<int> G[MAXN];\nint dp[MAXN], f[MAXN];\n\nsigned main() {\n    cin >> n >> m >> k;\n    for (int i = 1; i <= m; i++) {\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dp[1] = 1;\n    for (int i = 1; i <= k; i++) {\n        int tot = 0;\n        for (int j = 1; j <= n; j++) tot = (tot + dp[j]) % MOD;\n        for (int j = 1; j <= n; j++) {\n            f[j] = 0;\n            for (auto& to : G[j]) f[j] = (f[j] + dp[to]) % MOD;\n        }\n        for (int j = 1; j <= n; j++) dp[j] = ((tot - dp[j]) % MOD - f[j]) % MOD;\n    }\n    cout << (dp[1] + MOD) % MOD;\n    return 0;\n}\n```\n\n# F Greedy Takahashi\n## Description\n[题目链接](https://atcoder.jp/contests/abc212/tasks/abc212_f)\n## Solution\n以各个班车为节点，根据转乘关系，由当前班车向下一次乘坐的班车连边，最后得到一个森林。给定起始城市和时间，可以二分查找首次搭乘的班车号，然后再利用树上倍增可以知道 $Takahashi$ 在结束时刻会停留在哪一个城市或者在哪辆车上。\n## Code\n```cpp Greedy Takahashi\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\nconst int MAXN = 1E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, q;\nvector<int> G[MAXN];\nvector<pair<int, int>> city[MAXN];\narray<int, MAXN> in, a, b, s, t, p[22];\n\nvoid dfs(int now) {\n    for (auto& to : G[now]) {\n        for (int j = 1; j <= 20; j++)\n            if (p[j - 1][to]) p[j][to] = p[j - 1][p[j - 1][to]];\n        dfs(to);\n    }\n}\n\nsigned main() {\n    read(n, m, q);\n    for (int i = 1; i <= m; i++) {\n        read(a[i], b[i], s[i], t[i]);\n        city[a[i]].push_back({s[i], i});\n    }\n    for (int i = 1; i <= n; i++) sort(city[i].begin(), city[i].end());\n    for (int i = 1; i <= n; i++) {\n        for (auto& [s, j] : city[i]) {\n            auto it = lower_bound(city[b[j]].begin(), city[b[j]].end(),\n                                  make_pair(t[j], 0));\n            if (it != city[b[j]].end()) {\n                G[it->second].push_back(j);\n                p[0][j] = it->second;\n                in[j]++;\n            }\n        }\n    }\n    for (int i = 1; i <= m; i++)\n        if (!in[i]) dfs(i);\n    for (int i = 1; i <= q; i++) {\n        int x, y, z;\n        read(x, y, z);\n        auto it = lower_bound(city[y].begin(), city[y].end(), make_pair(x, 0));\n        if (it == city[y].end())\n            printf(\"%d\\n\", y);\n        else {\n            int bus = it->second;\n            if (z <= s[bus])\n                printf(\"%d\\n\", y);\n            else {\n                for (int j = 20; ~j; j--)\n                    if (p[j][bus] && s[p[j][bus]] < z) bus = p[j][bus];\n                if (z <= t[bus])\n                    printf(\"%d %d\\n\", a[bus], b[bus]);\n                else\n                    printf(\"%d\\n\", b[bus]);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n# G Power Pair\n## Description\n[题目链接](https://atcoder.jp/contests/abc212/tasks/abc212_g)\n## Solution\n显然 $x=0,y=0$ 是一个解，下面仅讨论 $x \\neq 0, y \\neq 0$ 的情况。\n\n设 $r$ 为 $P$ 的原根，令 $x≡r^a\\pmod P,y≡r^b\\pmod P$，其中 $1 \\le a,b \\le P-1$，则：\n$$x^n≡y\\pmod P⇔ r^{an}≡r^b\\pmod P ⇔ an≡b\\pmod {P−1}$$\n\n上式最右边的等价关系由费马小定理推得。\n\n$an≡b\\pmod {P−1}$ 有解当且仅当 $gcd(a,P-1)|b$，对于给定的 $a$，可知满足条件的 $b$ 的个数是 $\\frac{P-1}{gcd(a,P-1)}$，因此总的答案为 $\\sum\\limits_{a=1}^{P-1}\\frac{P-1}{gcd(a,P-1)}$。\n\n注意到 $gcd(a,P-1)$ 的个数不会超过 $P-1$ 的因数的个数，我们可以 $O(\\sqrt{P})$ 求出 $P-1$ 的所有因数，设为 $g_1,g_2,\\dots,g_d$，那么答案可以写成 $\\sum\\limits_{i=1}^{d}\\frac{P-1}{g_i}*f(g_i)$，其中 $f(g_i)$ 表示满足 $g_i=gcd(a,P-1)$ 的 $a$ 的个数。考虑容斥可以 $O(d^2)$ 求解 $f(g_1),f(g_2),\\dots,f(g_d)$，因此总的时间复杂度为 $O(\\sqrt{N}+d^2)$。\n\n官方题解中提到 $10^{12}$ 内因数最多的数是 $963761198400$，它的因数个数是 $6720$，故上述解法的效率可以得到保证。 \n## Code\n```cpp Power Pair\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MOD = 998244353;\nLL p;\nvector<LL> fac;\nunordered_map<LL, LL> f;\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a % MOD;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nsigned main() {\n    cin >> p;\n    p--;\n    for (int i = 1; i <= sqrt(p); i++) {\n        if (p % i == 0) {\n            fac.push_back(i);\n            if (p / i != i) fac.push_back(p / i);\n        }\n    }\n    sort(fac.begin(), fac.end());\n    for (int i = fac.size() - 1; ~i; i--) {\n        (f[fac[i]] += p / fac[i]) %= MOD;\n        for (int j = i - 1; ~j; j--)\n            if (fac[i] % fac[j] == 0) (f[fac[j]] -= f[fac[i]]) %= MOD;\n    }\n    LL ans = 0;\n    for (auto& v : fac) {\n        ans += p % MOD * qpow(v, MOD - 2, MOD) % MOD * f[v] % MOD;\n        ans %= MOD;\n    }\n    cout << (ans + 1 + MOD) % MOD;\n    return 0;\n}\n```\n\n# H Nim Counting\n## Description\n[题目链接](https://atcoder.jp/contests/abc212/tasks/abc212_h)\n## Solution\n定义异或卷积 $X*Y=Z=(\\sum\\limits_{i⊕j=0}X_iY_j,\\sum\\limits_{i⊕j=1}X_iY_j,\\dots,\\sum\\limits_{i⊕j=K-1}X_iY_j)$，其中 $X,Y$ 均为长为 $K=2^k$ 的序列。\n\n令 $C_i = [\\exist j，A_j=i]$，则对于一个确定的 $M$，答案为 $C*C*\\dots(M \\ times)\\dots*C$ 中下标不为 $0$ 的项的和，由快速沃尔什变换，即 $\\sum \\limits_{i=1}^{K-1}IFWT(FWT(C)_i^M)$，因此总的答案为 $\\sum\\limits_{M=1}^{N}\\sum \\limits_{i=1}^{K-1}IFWT(FWT(C)_i^M) = \\sum \\limits_{i=1}^{K-1}IFWT(\\sum\\limits_{M=1}^{N} FWT(C)_i^M)$。\n\n我们先对 $C$ 做快速沃尔什变换，对每一项利用等比数列公式求和（注意 $C_i=0$ 的情况），再反变换对下标不为 $0$ 的项求和即可得到答案。\n\n时间复杂度：$O(A(logA+logN))$。\n## Code\n```cpp Nim Counting\n\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\n#define int long long\nconst int MAXN = 2E5 + 5;\nconst int MOD = 998244353;\nint n, k;\nint c[MAXN];\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a % MOD;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nvoid FWT_XOR(int* A, int N, int tag) {\n    for (int sz = 1; sz < N; sz *= 2)\n        for (int i = 0; i < N; i += sz * 2)\n            for (int k = 0; k < sz; k++) {\n                const int x = A[i + k], y = A[i + k + sz];\n                A[i + k] = (x + y) % MOD;\n                A[i + k + sz] = (x - y) % MOD;\n            }\n    if (tag == -1)\n        for (int i = 0; i < N; i++) (A[i] *= qpow(N, MOD - 2, MOD)) %= MOD;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> k;\n    int N = (1 << 16);\n    for (int i = 1, x; i <= k; i++) cin >> x, c[x] = 1;\n    FWT_XOR(c, N, 1);\n    for (int i = 0; i < N; i++) {\n        if (c[i] == 1)\n            c[i] = n;\n        else\n            c[i] = c[i] * (1 - qpow(c[i], n, MOD)) % MOD *\n                   qpow(1 - c[i], MOD - 2, MOD) % MOD;\n    }\n    FWT_XOR(c, N, -1);\n    int ans = 0;\n    for (int i = 1; i < N; i++) ans = (ans + c[i]) % MOD;\n    cout << (ans + MOD) % MOD;\n    return 0;\n}\n```\n","tags":["动态规划","倍增","数论","contest","set","快速沃尔什变换"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 213","url":"/2021/08/24/atcoder-abc-213/","content":"[比赛链接](https://atcoder.jp/contests/abc213)\n<!-- more -->\n# D Takahashi Tour\n## Description\n[题目链接](https://atcoder.jp/contests/abc213/tasks/abc213_d)\n## Solution\n$vector$ 存图，将后继节点从小到大排序，然后按序深搜即可。 \n## Code\n```cpp Takahashi Tour\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n;\nvector<int> G[MAXN], ans;\n\nvoid dfs(int now, int fa) {\n    ans.push_back(now);\n    for (auto& to : G[now]) {\n        if (to == fa) continue;\n        dfs(to, now);\n        ans.push_back(now);\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    for (int i = 1; i <= n; i++) sort(G[i].begin(), G[i].end());\n    dfs(1, 1);\n    for (auto& v : ans) cout << v << \" \";\n    return 0;\n}\n```\n\n# E Stronger Takahashi\n## Description\n[题目链接](https://atcoder.jp/contests/abc213/tasks/abc213_e)\n## Solution\n建图后跑 $Dijkstra$ 或者 $01BFS$，具体建法如下：\n- 设当前位置为 $(i,j)$。\n- 由 $(i,j)$ 向四周的 ```'.'``` 连代价为 0 的边。这些点不需要 ```punch``` 即可到达。\n- 由 $(i,j)$ 向四周的 ```'#'``` 的 $3×3$ 范围内的所有点连代价为 1 的边。若经由 ```'#'``` 到这些点，需要 ```punch``` 一次。 \n## Code\n```cpp Stronger Takahashi\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 3e5 + 5, MOD = 1e9 + 7;\n\nint H, W;\nchar g[505][505];\n\nvoid print() {\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            cout << g[i][j];\n        }\n        cout << \"\\n\";\n    }\n}\n\nint getId(int x, int y) {\n    if (!(1 <= x && x <= H && 1 <= y && y <= W)) return 0;\n    return W * (x - 1) + y;\n}\n\nvector<pair<int, int>> G[MAXN];\n\nvoid add(int u, int v, int w) {\n    if (!u || !v) return;\n    if (u == v) return;\n    G[u].emplace_back(v, w);\n}\n\nint dis[MAXN], vis[MAXN];\nvoid dijkstra() {\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    int cur, dist;\n    for (int i = 1; i < MAXN; i++) dis[i] = 1e9;\n    dis[getId(1, 1)] = 0;\n    q.emplace(0, getId(1, 1));\n    while (!q.empty()) {\n        tie(dist, cur) = q.top();\n        q.pop();\n        if (vis[cur]) continue;\n        for (auto& e : G[cur]) {\n            int to = e.first, w = e.second;\n            if (dis[to] > dis[cur] + w) {\n                dis[to] = dis[cur] + w;\n                q.emplace(dis[to], to);\n            }\n        }\n        vis[cur] = true;\n    }\n    cout << dis[getId(H, W)] << \"\\n\";\n}\n\nvector<pair<int, int>> delta = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 0}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n\nint main() {\n    boost;\n    cin >> H >> W;\n    for (int i = 1; i <= H; i++) {\n        cin.ignore(10, '\\n');\n        for (int j = 1; j <= W; j++) {\n            cin >> g[i][j];\n        }\n    }\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            if (g[i - 1][j] == '#') {\n                for (auto& d : delta) {\n                    int toi = i - 1 + d.first;\n                    int toj = j + d.second;\n                    add(getId(i, j), getId(toi, toj), 1);\n                }\n            } else if (g[i - 1][j] == '.') {\n                add(getId(i, j), getId(i - 1, j), 0);\n            }\n\n            if (g[i + 1][j] == '#') {\n                for (auto& d : delta) {\n                    int toi = i + 1 + d.first;\n                    int toj = j + d.second;\n                    add(getId(i, j), getId(toi, toj), 1);\n                }\n            } else if (g[i + 1][j] == '.') {\n                add(getId(i, j), getId(i + 1, j), 0);\n            }\n\n            if (g[i][j + 1] == '#') {\n                for (auto& d : delta) {\n                    int toi = i + d.first;\n                    int toj = j + 1 + d.second;\n                    add(getId(i, j), getId(toi, toj), 1);\n                }\n            } else if (g[i][j + 1] == '.') {\n                add(getId(i, j), getId(i, j + 1), 0);\n            }\n\n            if (g[i][j - 1] == '#') {\n                for (auto& d : delta) {\n                    int toi = i + d.first;\n                    int toj = j - 1 + d.second;\n                    add(getId(i, j), getId(toi, toj), 1);\n                }\n            } else if (g[i][j - 1] == '.') {\n                add(getId(i, j), getId(i, j - 1), 0);\n            }\n        }\n    }\n    dijkstra();\n    return 0;\n}\n```\n\n# F Common Prefixes\n## Description\n[题目链接](https://atcoder.jp/contests/abc213/tasks/abc213_f)\n## Solution\n本题求两个后缀的 $LCP$，等价于将原串翻转后，求某两个前缀的 $LCS$。我们知道 $SAM$ 的后缀树中，原串两个前缀对应节点的 $LCA$ 是这两个前缀的 $LCS$ 对应的节点（该 $LCS$ 一定是这个状态中最长的一个串）。利用这个性质可以求解本题。\n\n令 $G(S_k)=f(S_k,S_1)+f(S_k,S_2)+\\ldots+f(S_k,S_N)$。显然对每个 $S_k$ 求 $f(S_k,S_1),f(S_k,S_2),\\ldots,f(S_k,S_N)$ 效率太低。我们不妨考虑每个 $LCS$ 对 $G(S_1),\\dots,G(S_n)$ 的贡献。具体的，我们预处理出后缀树上每个节点 $u$ 的子树中包含前缀的数目，记为 $f_u$，那么 $u$ 对儿子 $v$ 的子树中所有前缀的答案贡献为 $(f_u-f_v)*maxsub_u$。此外，若 $u$ 包含了某一前缀 $S_i$，那么 $G(S_i)$ 还要加上 $f_u*maxsub_u$。\n\n上述解法涉及子树修改加单次查询，利用 $DFS$ 序 + 差分即可。\n## Code\n```cpp Common Prefixes\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1E6 + 5;\nconst int MOD = 1E9 + 7;\nstring s;\nint n;\narray<LL, MAXN * 2> dp, in, out, ans;\nvector<int> G[MAXN * 2], pre;\n\nstruct SAM {\n    int size, last;\n    // 各状态最长子串长度，后缀链接\n    vector<int> len, link;\n    // 转移数组\n    vector<vector<int>> to;\n    // 字符串长度，字符集大小\n    SAM(int _len, int _szC = 26) : size(0), last(0) {\n        len.resize(_len * 2, 0);\n        link.resize(_len * 2, -1);\n        to.resize(_len * 2, vector<int>(_szC, -1));\n    }\n\n    void insert(int c) {\n        int cur = ++size, p = last;\n        dp[cur] = 1, pre.push_back(cur);\n        len[cur] = len[last] + 1;\n        while (p != -1 && to[p][c] == -1) {\n            to[p][c] = cur;\n            p = link[p];\n        }\n        if (p == -1)\n            link[cur] = 0;\n        else {\n            int q = to[p][c];\n            if (len[q] == len[p] + 1)\n                link[cur] = q;\n            else {\n                int clone = ++size;\n                len[clone] = len[p] + 1;\n                to[clone] = to[q];\n                link[clone] = link[q];\n                while (p != -1 && to[p][c] == q) {\n                    to[p][c] = clone;\n                    p = link[p];\n                }\n                link[q] = link[cur] = clone;\n            }\n        }\n        last = cur;\n    }\n\n    void update(int l, int r, LL v) { ans[l] += v, ans[r + 1] -= v; }\n\n    void dfs(int now) {\n        static int times = 0;\n        in[now] = times++;\n        for (auto& to : G[now]) {\n            if (to == -1) continue;\n            dfs(to);\n            dp[now] += dp[to];\n        }\n        out[now] = times;\n        for (auto& to : G[now]) {\n            if (to == -1) continue;\n            update(in[to], out[to] - 1, 1ll * len[now] * (dp[now] - dp[to]));\n        }\n        update(in[now], in[now], 1ll * len[now] * dp[now]);\n    }\n\n    void calcLCPs() {\n        for (int i = 1; i <= size; i++)\n            if (link[i] != -1) G[link[i]].push_back(i);\n        dfs(0);\n        for (int i = 1; i <= size; i++) ans[i] += ans[i - 1];\n    }\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> s;\n    reverse(s.begin(), s.end());\n    SAM mySAM(s.size());\n    for (auto& c : s) mySAM.insert(c - 'a');\n    mySAM.calcLCPs();\n    for (int i = pre.size() - 1; ~i; i--) cout << ans[in[pre[i]]] << endl;\n    return 0;\n}\n```\n\n# G Connectivity 2\n## Description\n[题目链接](https://atcoder.jp/contests/abc213/tasks/abc213_g)\n## Solution\n设 $f[S]$ 表示点集为 $S$ 的联通子图的个数，$g[S]$ 表示点集为 $S$ 的子图的个数，那么答案可以表示为 $\\sum\\limits_{\\{1,k\\}⊆S⊆V}f[S]g[V-S]$。下面考虑如何求解 $f[S],g[S]$。\n\n设有 $m$ 条边两端都在 $S$ 中，则 $g[S]=2^m$。求 $f[S]$ 可以利用容斥，从 $g[S]$ 中扣除不联通的部分，而不联通的部分可以拆成一个联通子图和一个另一个子图，因此可以粗略得到 $f[S] = g[S] - \\sum\\limits_{T⊆S} f[T]g[S-T]$，这可通过枚举子集求得。由于 $g[S]$ 是包含 $f[S]$ 的，因此 $f[T]g[S-T]$ 和 $f[S-T]g[T]$ 都包含了 $f[T]f[S-T]$，这一部分要扣除，故当 $T>S-T$ 时，要从 $g[S-T]$ 中扣除 $f[S-T]$。\n\n求 $g[S]$ 的时间复杂度为 $O(m2^n)$，求 $f[S]$ 的时间复杂度为 $O(3^n)$，因此总的时间复杂度为 $O(3^n+m2^n)$。\n## Code\n```cpp Connectivity 2\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 18;\nconst int MAXS = (1 << 17) - 1;\nconst int MOD = 998244353;\nint n, m;\nint u[MAXN * MAXN], v[MAXN * MAXN];\nLL f[MAXS], g[MAXS];\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a % MOD;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        cin >> u[i] >> v[i];\n        u[i]--, v[i]--;\n    }\n    for (int s = 0; s < (1 << n); s++) {\n        int cnte = 0;\n        for (int i = 1; i <= m; i++)\n            if (((s >> u[i]) & 1) && ((s >> v[i]) & 1)) cnte++;\n        g[s] = qpow(2, cnte, MOD);\n        f[s] = g[s];\n        for (int t = s - 1; t > 0; t--) {\n            t &= s;\n            f[s] -= f[t] * (g[s - t] - (t > s - t ? f[s - t] : 0)) % MOD;\n            f[s] %= MOD;\n        }\n    }\n    for (int k = 1; k < n; k++) {\n        int ans = 0;\n        for (int s = 0; s < (1 << n); s++) {\n            if ((s & 1) && ((s >> k) & 1)) {\n                ans += f[s] * g[(1 << n) - 1 - s] % MOD;\n                ans %= MOD;\n            }\n        }\n        cout << (ans + MOD) % MOD << endl;\n    }\n    return 0;\n}\n```\n\n# H Stroll\n## Description\n[题目链接](https://atcoder.jp/contests/abc213/tasks/abc213_h)\n## Solution\n设 $d_{s,t}$ 表示以 $s$ 为终点，长度为 $t$ 的路径条数。\n\n按 $t$ 递增的顺序，并按边转移，可以得到状态转移如下：\n$$d_{s,t}=\\sum\\limits_{bi=s, 1\\le i\\le M}(\\sum\\limits_{0\\le u\\le t-1}d_{a_i, u} * p_{i,t-u}) + \\sum\\limits_{ai=s, 1\\le i\\le M}(\\sum\\limits_{0\\le u\\le t-1}d_{b_i, u} * p_{i,t-u})$$\n\n上述转移过程的时间复杂度为 $O(MT^2)$。观察式子发现可以通过分治 $fft$ 优化。见 [分治 fft 模板](https://www.luogu.com.cn/problem/P4721)。\n\n即对于区间 $l = 0, r = t$，先递归求出 $d_{1...n, l...mid}$ 的结果，然后枚举每条边，通过卷积计算 $d_{from, l...mid} * p_{...}$ 对 $d_{to, mid + 1...r}$ 的贡献。\n\n最终的时间复杂度为 $O(MTlog^2T)$。\n## Code\n```cpp Stroll\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define PI acos(-1)\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 4e4 + 5;\n\nnamespace NTT {\n    constexpr int NR = 1 << 22, g = 3, gi = 332748118, mod = 998244353;\n\n    long long qpow(long long a, long long b) {\n        long long res = 1;\n        while (b) {\n            if (b & 1) res = res * a % mod;\n            a = a * a % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    int R[4000001];\n    void init(int& sz) {\n        if (__builtin_popcount(sz) != 1) sz = 1 << (1 + (int)log2(sz));\n        for (int i = 0; i < sz; i++) R[i] = (R[i >> 1] >> 1) | ((i & 1) ? (sz >> 1) : 0);\n    }\n\n    void dft(long long a[], int sz, int type) {\n        for (int i = 0; i < sz; i++)\n            if (i < R[i]) swap(a[i], a[R[i]]);\n        for (int m = 2; m <= sz; m <<= 1) {\n            long long gn = qpow(type == 1 ? g : gi, (mod - 1) / m); // 单位原根 g_n\n            for (int k = 0; k < sz; k += m) {\n                long long g0(1);\n                for (int j = 0; j < m / 2; j++) {\n                    long long t = g0 * a[k + j + m / 2] % mod;\n                    long long u = a[k + j];\n                    a[k + j] = (u + t) % mod;\n                    a[k + j + m / 2] = (u - t + mod) % mod;\n                    g0 = g0 * gn % mod;\n                }\n            }\n        }\n        if (type == -1) {\n            long long inv = qpow(sz, mod - 2);\n            for (int i = 0; i < sz; i++) a[i] = a[i] * inv % mod;\n        }\n    }\n}\n\nnamespace Polynomial {\n    using namespace NTT;\n\n    void Convolution(int n, int m, int a[], int b[], int c[]) { // a[0, n] b[0, m]\n        int N = n + m + 1;\n        init(N);\n        long long f[N], g[N];\n        for (int i = 0; i < N; i++) f[i] = g[i] = 0;\n        for (int i = 0; i <= n; i++) f[i] = a[i];\n        for (int i = 0; i <= m; i++) g[i] = b[i];\n        dft(f, N, 1), dft(g, N, 1);\n        long long res[N];\n        for (int i = 0; i < N; i++) res[i] = 0;\n        for (int i = 0; i < N; i++) res[i] = f[i] * g[i] % mod;\n        dft(res, N, -1);\n        for (int i = 0; i <= n + m; i++) c[i] = res[i];\n    }\n};\n\nint n, m, t;\nint d[10][MAXN];\nint p[10][10][MAXN];\nvector<pair<int, int>> e;\n\nusing namespace Polynomial;\nvoid divide_and_conquer(int l, int r) {\n    if (l == r) {\n        if (!l) d[0][0] = 1;\n        return ;\n    }\n    int mid = (l + r) >> 1;\n    divide_and_conquer(l, mid);\n\n    for (auto& i : e) {\n        int x = i.first, y = i.second;\n        int f[mid - l + 1], g[r - l + 1], c[r - l + 1 + mid - l + 1];\n        for (int i = 0; i < mid - l + 1; i++) f[i] = d[x][i + l];\n        for (int i = 0; i < r - l + 1; i++) g[i] = p[x][y][i];\n        Convolution(mid - l, r - l, f, g, c);\n        for (int i = mid + 1; i <= r; i++) d[y][i] = (d[y][i] + c[i - l]) % mod;\n\n        for (int i = 0; i < mid - l + 1; i++) f[i] = d[y][i + l];\n        Convolution(mid - l, r - l, f, g, c);\n        for (int i = mid + 1; i <= r; i++) d[x][i] = (d[x][i] + c[i - l]) % mod;\n    }\n\n    divide_and_conquer(mid + 1, r);\n}\n\nint main() {\n    boost;\n    cin >> n >> m >> t;\n    for (int i = 1; i <= m; i++) {\n        int a, b;\n        cin >> a >> b, a--, b--;\n        e.push_back({a, b});\n        for (int j = 1; j <= t; j++) cin >> p[a][b][j];\n    }\n    divide_and_conquer(0, t);\n    cout << d[0][t] << \"\\n\";\n    return 0;\n}\n```","tags":["动态规划","contest","01-BFS","后缀自动机","dfs 序上差分","状态压缩","分治 fft"],"categories":["contest"]},{"title":"拉格朗日插值笔记","url":"/2021/08/05/Lagrange-Interplotation/","content":"\n在数值分析中，拉格朗日插值法是以法国18世纪数学家约瑟夫·拉格朗日命名的一种多项式插值方法。如果对实践中的某个物理量进行观测，在若干个不同的地方得到相应的观测值，拉格朗日插值法可以找到一个多项式，其恰好在各个观测的点取到观测到的值。上面这样的多项式就称为拉格朗日（插值）多项式。  \n<!-- more -->\n# 拉格朗日插值\n考虑这样一个多项式：$f(x) = f_0 + f_1 x + f_2 x^2 + \\dots + f_n x^n$。\n\n假设我们已知 $n+1$ 个互不相同的点 $(x_0,x_1,\\dots,x_n)$，该多项式在这些点的取值为 $(y_0,y_1,\\dots,y_n)$，我们可以用矩阵描述这 $n+1$ 个等式：\n\n$$\\left(\n\\begin{array}{ccccc}\n\\tag{1}\n1 & x_0  & x_0^2 & \\cdots & x_0^n \\\\\n1 & x_1  & x_1^2 & \\cdots & x_1^n \\\\\n1 & x_2  & x_2^2 & \\cdots & x_2^n \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & x_n & x_n^2 & \\cdots & x_n^n \\\\\n\\end{array} \n\\right)\\left(\n\\begin{array}{c}\nf_0 \\\\\nf_1 \\\\\nf_2 \\\\\n\\vdots \\\\\nf_n \\\\\n\\end{array}\n\\right)=\n\\left(\n\\begin{array}{c}\ny_0 \\\\\ny_1 \\\\\ny_2 \\\\\n\\vdots \\\\\ny_n \\\\\n\\end{array}\n\\right)\n$$\n\n可以发现系数矩阵是一个范德蒙特矩阵，而对于范德蒙特行列式有如下结论：\n\n$$\\left \n\\vert\n\\begin{array}{ccccc}\n\\tag{2}\n1 & x_0  & x_0^2 & \\cdots & x_0^n \\\\\n1 & x_1  & x_1^2 & \\cdots & x_1^n \\\\\n1 & x_2  & x_2^2 & \\cdots & x_2^n \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ \n1 & x_n & x_n^2 & \\cdots & x_n^n \n\\end{array}\n\\right \n\\vert \n= \\prod_{j \\lt i} (x_i - x_j) \n\\neq 0$$\n\n结合线性代数知识可知，给定 $n+1$个 $x$ 不同的点，可以唯一确定经过这些点的次数不超过 $n$ 的多项式。\n\n由 $(1)$ 式，我们只需要求出范德蒙特矩阵的逆，再在等式两边左乘就可以得到系数向量 $(f_0,f_1,\\dots,f_n)$，但这样计算量很大。因此在确定多项式时，一般不选择直接求系数，而是用一组基本多项式来表示该多项式。\n\n引入拉格朗日基本多项式：\n$$\\begin{aligned}\n\\tag{3}\nL_i(x) &= \\prod_{j \\neq i} \\frac{x - x_j}{x_i - x_j} \\\\\n&= \\frac{(x - x_0) (x - x_1)\\dots(x-x_{i-1})(x-x_{i+1})\\dots (x-x_n)}{(x_i - x_0) (x_i - x_1)\\dots(x_i-x_{i-1})(x_i-x_{i+1})\\dots (x_i-x_n)}\n\\end{aligned}$$\n\n从而 $f(x)$ 可以表示为：\n$$\\begin{aligned}\n\\tag{4}\ny_0 L_0(x) + y_1 L_1(x) + \\dots + y_n L_n(x) = \\sum \\limits_{i=0}^{n}y_iL_i(x)\n\\end{aligned}$$\n\n可以证明该表示下 $f(x)$ 是经过 $(x0,y0),(x_1,y_1),\\dots,(x_n,y_n)$的。我们要求 $f(N)$，只需求得各基本多项式在 $N$ 处的值，再按权相加即可。\n\n上述过程代码实现如下，时间复杂度为 $O(n^2)$。\n\n```cpp 拉格朗日插值\n// 由于结果可能很大，一般要对答案取模，这里模数为 MOD\n// qpow 为快速幂，用于快速求逆元\n// 参数依次为插值点数，插值点，待求值点横坐标，返回值为待求值点纵坐标\nLL lagrange(int n, LL* x, LL* y, LL k) {\n    LL ans = 0;\n    for (int i = 1; i <= n; i++) {\n        LL num = 1, d = 1;\n        for (int j = 1; j <= n; j++)\n            if (j != i)\n                num = (k - x[j]) % MOD * num % MOD,\n                d = (x[i] - x[j]) % MOD * d % MOD;\n        ans =\n            (ans + y[i] % MOD * num % MOD * qpow(d, MOD - 2, MOD) % MOD) % MOD;\n    }\n    return (ans + MOD) % MOD;\n}\n```\n# 求插值多项式系数\n由 $(4)$ 式可以确定系数向量 $(f_0,f_1,\\dots,f_n)$。\n\n由于 $y_iL_i(x) = \\frac{y_i}{\\prod \\limits_{j \\neq i} {x_i-x_j}} \\prod \\limits_{j\\neq i} {x-x_j} = C_i*\\prod \\limits_{j \\neq i} {x-x_j} =C_i* \\frac{\\prod \\limits_{0 \\le j \\le n} {x-x_j}}{x-x_i}$，令 $p_i(x) = \\prod \\limits_{j \\neq i} {x-x_j},q(x)=\\prod \\limits_{0 \\le j \\le n} {x-x_j}$，则 $f(x) = \\sum \\limits_{i=0}^{n}y_i*L_i(x) = \\sum \\limits_{i=0}^{n}C_i*p_i(x)$。模拟多项式乘法可以得到 $q(x)$ 的系数向量，记为 $(q_0,q_1,\\dots,q_n)$，同时记 $p_i(x)$ 的系数向量为 $(p_{i,0},p_{i,1},\\dots,p_{i,n})$，则由 $q(x) = (x-x_i)p_i(x)$ 可得 $p_{i,j}=\\frac{p_{i,j-1}-q_j}{x_j}$。由此递推式可 $O(n)$ 求得 $p_i(x)$ 的各次项系数，从而可以 $O(n^2)$ 求得 $f(x)$ 的各次项系数。\n\n求插值多项式系数代码实现如下：\n```cpp 插值多项式系数\n// 参数为插值点数，插值点，返回值为系数向量\nvector<LL> lagrange_coef(int n, LL* x, LL* y) {\n    vector<LL> coef(n), tot(n + 1);\n    tot[1] = 1, tot[0] = -x[1] % MOD;\n    for (int i = 2; i <= n; i++) {\n        vector<LL> v(n + 1);\n        for (int j = 1; j <= i; j++) v[j] = tot[j - 1];\n        for (int j = 0; j < i; j++)\n            v[j] = (v[j] - x[i] % MOD * tot[j] % MOD) % MOD;\n        tot = v;\n    }\n    for (int i = 1; i <= n; i++) {\n        LL mul = 1, invx = qpow(x[i] % MOD, MOD - 2, MOD);\n        for (int j = 1; j <= n; j++)\n            if (j != i) mul = (x[i] - x[j]) % MOD * mul % MOD;\n        mul = y[i] % MOD * qpow(mul, MOD - 2, MOD) % MOD;\n        LL v = 0;\n        for (int j = 0; j < n; j++) {\n            v = (v - tot[j]) * invx % MOD;\n            coef[j] = (coef[j] + mul * v % MOD) % MOD;\n        }\n    }\n    return coef;\n}\n```\n\n注：AtCoder Beginner Contest 208 F 的[官方题解](https://atcoder.jp/contests/abc208/editorial/2219)提到了插值多项式系数可以利用范德蒙特矩阵在 $O(nlog^2n)$ 时间内求得，AC Library 也有相应代码，感兴趣的朋友可以自行阅读。\n# 拉格朗日插值优化 \n## 横坐标连续时插值\n如果题目不限制，我们取插值点时一般取横坐标依次递增 $1$ 的 $n+1$ 个连续的插值点，这时可对 $(3)$ 式进行变形：\n$$\\tag{5} L_i(x) = (-1)^{n-i}\\frac{pre[i-1]*suf[i+1]}{fac[i-1]*fac[n-i]}$$\n\n这里 $fac[i]=i!, pre[i] = (x-x_0)(x-x_1)\\dots(x-x_i), suf[i] = (x-x_i)(x-x_{i+1})\\dots(x-x_n)$。$O(n)$ 预处理前后缀乘积以及阶乘逆元即可 $O(1)$ 计算 $L_i(x)$，从而在 $O(n)$ 时间内完成插值。\n\n代码实现如下：\n```cpp 横坐标连续时插值\n// 参数为插值点数，插值点，待求值点横坐标，返回值为待求值点纵坐标\nLL lagrange_cont(int n, LL* x, LL* y, LL k) {\n    LL ans = 0;\n    vector<LL> pre(n + 1), suf(n + 2), fac(n), inv(n);\n    pre[0] = fac[0] = inv[0] = suf[n + 1] = 1;\n    for (int i = 1; i <= n; i++) pre[i] = (k - x[i]) % MOD * pre[i - 1] % MOD;\n    for (int i = n; i >= 1; i--) suf[i] = (k - x[i]) % MOD * suf[i + 1] % MOD;\n    for (int i = 1; i < n; i++) fac[i] = fac[i - 1] * i % MOD;\n    inv[n - 1] = qpow(fac[n - 1], MOD - 2, MOD);\n    for (int i = n - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % MOD;\n    for (int i = 1; i <= n; i++)\n        ans =\n            (ans + ((n - i) % 2 ? -1ll : 1ll) * y[i] % MOD * pre[i - 1] % MOD *\n                       suf[i + 1] % MOD * inv[i - 1] % MOD * inv[n - i] % MOD) %\n            MOD;\n    return (ans + MOD) % MOD;\n}\n```\n## 重心拉格朗日插值\n重心拉格朗日插值适用于插值点动态变化时，单次插值时间复杂度为 $O(n)$ 或 $O(nlogn)$，取决于能否预处理乘法逆元。\n\n由 $(4)$ 式，有：\n$$\\tag{6} f(x)= \\sum \\limits_{i=0}^{n} y_i \\prod \\limits_{j \\neq i} \\frac{x-x_j}{x_i-x_j}$$\n令 $g = \\prod \\limits_{0 \\le j \\le n} (x-x_j)$，有：\n$$\\tag{7}f(x)= g\\sum \\limits_{i=0}^{n} \\prod \\limits_{j \\neq i} \\frac{y_i}{(x-x_i)(x_i-x_j)}$$ \n再令 $t_i = \\prod \\limits_{j \\neq i} \\frac{y_i}{x_i-x_j}$，则：\n$$\\tag{8} f(x)= g\\sum \\limits_{i=0}^{n} \\frac{t_i}{x-x_i}$$ \n对每个点 $i$，我们记录它的 $t_i$ 和 $x_i$。当加入新的点时，我们只需更新 $t_i$ 。\n```cpp 重心拉格朗日插值\nstruct CentroidLagrange {\n    vector<LL> t, x;\n    int size = 0;\n    // 插入点 (x,y)\n    void insert(LL _x, LL _y) {\n        LL tmp = 1;\n        for (int i = 0; i < size; i++) {\n            tmp = (_x - x[i]) % MOD * tmp % MOD;\n            t[i] = t[i] * qpow((x[i] - _x) % MOD, MOD - 2, MOD) % MOD;\n        }\n        tmp = qpow(tmp, MOD - 2, MOD);\n        size++;\n        x.push_back(_x);\n        t.push_back(_y % MOD * tmp % MOD);\n    }\n    // 计算 x=k 处的值\n    LL calc(LL k) {\n        LL ans = 0;\n        vector<LL> pre(size), suf(size);\n        for (int i = 0; i < size; i++)\n            pre[i] = (k - x[i]) % MOD * (i ? pre[i - 1] : 1) % MOD;\n        for (int i = size - 1; ~i; i--)\n            suf[i] = (k - x[i]) % MOD * (i < size - 1 ? suf[i + 1] : 1) % MOD;\n        for (int i = 0; i < size; i++)\n            ans = (ans + (i ? pre[i - 1] : 1ll) *\n                             (i < size - 1 ? suf[i + 1] : 1ll) % MOD * t[i] %\n                             MOD) %\n                  MOD;\n        return (ans + MOD) % MOD;\n    }\n};\n```\n\n# 多项式多点插值与快速插值\n待补充...\n\n\n# 例题\n## A 洛谷 拉格朗日插值\n[题目链接](https://www.luogu.com.cn/problem/P4781)\n\n套[拉格朗日插值板子](https://shaun-shane.vercel.app/2021/08/05/Lagrange-Interplotation/#拉格朗日插值)即可。\n\n## B LOJ 拉格朗日插值\n[题目链接](https://loj.ac/p/165)\n\n套[重心拉格朗日插值板子](https://shaun-shane.vercel.app/2021/08/05/Lagrange-Interplotation/#重心拉格朗日插值)即可。\n\n## C The Sum of the k-th Powers\n[题目链接](https://codeforces.com/problemset/problem/622/F)\n$\\sum_{i=1}^{n} i^k$ 是 $N$ 的 $k+1$ 次多项式，因此我们取 $k+2$ 个连续的插值点然后 $O(k)$ 插值即可。 \n\n证明的话要用到一个定理：$f(x)$ 是 $n$ 次多项式 ⇔ $f(x)$ 的 $n$ 阶差分为常数。注意到 $\\sum_{i=1}^{n} i^k$ 的一阶差分是 $k$ 次多项式，因此 $\\sum_{i=1}^{n} i^k$ 是 $k+1$ 次多项式。\n \n```cpp The Sum of the k-th Powers\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1E6 + 5;\nconst int MOD = 1e9 + 7;\nLL n, m, T;\nLL x[MAXN], y[MAXN];\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\n// 参数为插值点数，插值点，待求值点横坐标，返回值为待求值点纵坐标\nLL lagrange_cont(int n, LL* x, LL* y, LL k) {\n    LL ans = 0;\n    vector<LL> pre(n + 1), suf(n + 2), fac(n), inv(n);\n    pre[0] = fac[0] = inv[0] = suf[n + 1] = 1;\n    for (int i = 1; i <= n; i++) pre[i] = (k - x[i]) % MOD * pre[i - 1] % MOD;\n    for (int i = n; i >= 1; i--) suf[i] = (k - x[i]) % MOD * suf[i + 1] % MOD;\n    for (int i = 1; i < n; i++) fac[i] = fac[i - 1] * i % MOD;\n    inv[n - 1] = qpow(fac[n - 1], MOD - 2, MOD);\n    for (int i = n - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % MOD;\n    for (int i = 1; i <= n; i++)\n        ans =\n            (ans + ((n - i) % 2 ? -1ll : 1ll) * y[i] % MOD * pre[i - 1] % MOD *\n                       suf[i + 1] % MOD * inv[i - 1] % MOD * inv[n - i] % MOD) %\n            MOD;\n    return (ans + MOD) % MOD;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i = 1; i <= m + 2; i++)\n        x[i] = i, y[i] = (y[i - 1] + qpow(i, m, MOD)) % MOD;\n    cout << lagrange_cont(m + 2, x, y, n);\n    return 0;\n}\n```\n\n## D 教科书般的亵渎\n[题目链接](https://www.luogu.com.cn/problem/P4593)\n假设 $x$ 个怪物的血量为 $1,2,\\dots,x$，那么使用一张亵渎可以将这 $x$ 个怪全部击杀，获得分数为 $\\sum_{i=1}^{x} i^k$。其中 $k$ 为需要使用的亵渎张数，易知 $k = m+1$，故 $\\sum_{i=1}^{x} i^k$ 是 $m+2$ 次多项式，取 $m+3$ 个连续的点插值即可。\n\n下面考虑如果某些血量不存在该如何处理：\n\n设血量为 $a_i$ 的怪不存在（规定 $a_0=0$不存在），那么当血量比它少的怪全部被击杀后，其余怪的剩余血量为 $1,2,\\dots,n-a_i$，由此可计算再次使用一张亵渎的得分。当然，大于 $a_i$ 的某些血量可能不存在，从小到大记为 $a_{i+1},a_{i+2},\\dots,a_m$，我们需要把相应的得分扣除。由于此次亵渎会停在 $a_{i+1}$，接下来只需要从 $a_{i+1}$ 开始重复上述过程。\n\n时间复杂度：$O(m^2)$。\n```cpp 教科书般的亵渎\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 55;\nconst int MOD = 1e9 + 7;\nLL n, m, T;\nLL x[MAXN], y[MAXN], a[MAXN];\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\n// 参数为插值点数，插值点，待求值点横坐标，返回值为待求值点纵坐标\nLL lagrange_cont(int n, LL* x, LL* y, LL k) {\n    LL ans = 0;\n    vector<LL> pre(n + 1), suf(n + 2), fac(n), inv(n);\n    pre[0] = fac[0] = inv[0] = suf[n + 1] = 1;\n    for (int i = 1; i <= n; i++) pre[i] = (k - x[i]) % MOD * pre[i - 1] % MOD;\n    for (int i = n; i >= 1; i--) suf[i] = (k - x[i]) % MOD * suf[i + 1] % MOD;\n    for (int i = 1; i < n; i++) fac[i] = fac[i - 1] * i % MOD;\n    inv[n - 1] = qpow(fac[n - 1], MOD - 2, MOD);\n    for (int i = n - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % MOD;\n    for (int i = 1; i <= n; i++)\n        ans =\n            (ans + ((n - i) % 2 ? -1ll : 1ll) * y[i] % MOD * pre[i - 1] % MOD *\n                       suf[i + 1] % MOD * inv[i - 1] % MOD * inv[n - i] % MOD) %\n            MOD;\n    return (ans + MOD) % MOD;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> T;\n    while (T--) {\n        cin >> n >> m;\n        for (int i = 1; i <= m; i++) cin >> a[i];\n        a[0] = 0;\n        sort(a + 1, a + m + 1);\n        LL ans = 0;\n        for (int i = 1; i <= m + 3; i++)\n            x[i] = i, y[i] = (y[i - 1] + qpow(i, m + 1, MOD)) % MOD;\n        for (int i = 0; i <= m; i++) {\n            ans = (ans + lagrange_cont(m + 3, x, y, n - a[i])) % MOD;\n            for (int j = i + 1; j <= m; j++)\n                ans = (ans - qpow(a[j] - a[i], m + 1, MOD)) % MOD;\n        }\n        cout << (ans + MOD) % MOD << endl;\n    }\n    return 0;\n}\n```\n## E 排名估算\n[题目链接](https://ac.nowcoder.com/acm/contest/3782/D)\n关键是推式子，这里要用到全概率公式和贝叶斯公式。\n\n设 $M$ 表示抽到 $m$ 个人排名比小 C 低，$R_i$ 表示排名为 $i$，则：\n\n$$\\begin{aligned}\nP(R_i|M) &= \\frac{P(R_i)P(M|R_i)}{\\sum_{j=1}^{n}P(R_j)P(M|R_j)} \\\\\n&= \\frac{(n-i)^m}{\\sum_{j=1}^{n}(n-j)^m}\n\\end{aligned}$$\n\n因此答案为：\n$$\\sum_{i=1}^{n}i*P(R_i|M)=\\frac{\\sum_{i=1}^{n}i(n-i)^m}{\\sum_{j=1}^{n}(n-j)^m}$$\n\n换元可证分子是 $m+2$ 次多项式，分母是 $m+1$ 次多项式，使用拉格朗日插值求解即可。\n```cpp 排名估算\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 5005;\nconst int MOD = 998244353;\nLL n, m, x[MAXN], y[MAXN];\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nLL lagrange_cont(int n, LL* x, LL* y, LL k) {\n    LL ans = 0;\n    vector<LL> pre(n + 1), suf(n + 2), fac(n), inv(n);\n    pre[0] = fac[0] = inv[0] = suf[n + 1] = 1;\n    for (int i = 1; i <= n; i++) pre[i] = (k - x[i]) % MOD * pre[i - 1] % MOD;\n    for (int i = n; i >= 1; i--) suf[i] = (k - x[i]) % MOD * suf[i + 1] % MOD;\n    for (int i = 1; i < n; i++) fac[i] = fac[i - 1] * i % MOD;\n    inv[n - 1] = qpow(fac[n - 1], MOD - 2, MOD);\n    for (int i = n - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % MOD;\n    for (int i = 1; i <= n; i++)\n        ans =\n            (ans + ((n - i) % 2 ? -1ll : 1ll) * y[i] * pre[i - 1] % MOD *\n                       suf[i + 1] % MOD * inv[i - 1] % MOD * inv[n - i] % MOD) %\n            MOD;\n    return (ans + MOD) % MOD;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i = 1; i <= m + 2; i++) {\n        x[i] = i;\n        y[i] = (y[i - 1] + qpow((n - i) % MOD, m, MOD)) % MOD;\n    }\n    LL den = qpow(lagrange_cont(m + 2, x, y, n), MOD - 2, MOD);\n    for (int i = 1; i <= m + 3; i++) {\n        x[i] = i;\n        y[i] = (y[i - 1] + qpow((n - i) % MOD, m, MOD) * i % MOD) % MOD;\n    }\n    LL num = lagrange_cont(m + 3, x, y, n);\n    cout << num * den % MOD;\n    return 0;\n}\n```\n\n## F Cumulative Sum\n[题目链接](https://atcoder.jp/contests/abc208/tasks/abc208_f)\n做法见题解 [AtCoder Beginner Contest 208F](https://shaun-shane.vercel.app/2021/08/05/atcoder-abc-208/#f-cumulative-sum)\n\n## G Cowmpany Compensation\n[题目链接](https://codeforces.com/problemset/problem/995/F)\n\n首先考虑用动态规划求解：设 $dp[i][j]$ 表示以 $i$ 为根，根节点工资不超过 $j$ 的方案数，从而有 $dp[i][j] = dp[i][j-1] + \\prod \\limits_{k∈Son_i}dp[k][j]$。\n\n上述动态规划时间复杂度为 $O(nD)$，由于 $D$ 很大无法通过。实际上 $dp[1][D]$ 是 $D$ 的 $n$ 次多项式，因此我们只需要 $O(n^2)$ 求解 $dp[1][1..n+1]$，然后使用拉格朗日插值求解 $dp[1][D]$。\n\n```cpp Cowmpany Compensation\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 3005;\nconst int MOD = 1e9 + 7;\nLL n, d;\nLL x[MAXN], dp[MAXN][MAXN];\nvector<int> G[MAXN];\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nLL lagrange_cont(int n, LL* x, LL* y, LL k) {\n    LL ans = 0;\n    vector<LL> pre(n + 1), suf(n + 2), fac(n), inv(n);\n    pre[0] = fac[0] = inv[0] = suf[n + 1] = 1;\n    for (int i = 1; i <= n; i++) pre[i] = (k - x[i]) % MOD * pre[i - 1] % MOD;\n    for (int i = n; i >= 1; i--) suf[i] = (k - x[i]) % MOD * suf[i + 1] % MOD;\n    for (int i = 1; i < n; i++) fac[i] = fac[i - 1] * i % MOD;\n    inv[n - 1] = qpow(fac[n - 1], MOD - 2, MOD);\n    for (int i = n - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % MOD;\n    for (int i = 1; i <= n; i++)\n        ans =\n            (ans + ((n - i) % 2 ? -1ll : 1ll) * y[i] % MOD * pre[i - 1] % MOD *\n                       suf[i + 1] % MOD * inv[i - 1] % MOD * inv[n - i] % MOD) %\n            MOD;\n    return (ans + MOD) % MOD;\n}\n\nvoid dfs(int now) {\n    for (auto& to : G[now]) dfs(to);\n    for (int i = 1; i <= n + 1; i++) {\n        dp[now][i] = dp[now][i - 1];\n        LL tmp = 1;\n        for (auto& to : G[now]) tmp = tmp * dp[to][i] % MOD;\n        dp[now][i] = (dp[now][i] + tmp) % MOD;\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> d;\n    for (int i = 2; i <= n; i++) {\n        int p;\n        cin >> p;\n        G[p].push_back(i);\n    }\n    dfs(1);\n    for (int i = 1; i <= n + 1; i++) x[i] = i;\n    cout << lagrange_cont(n + 1, x, dp[1], d);\n    return 0;\n}\n```\n\n\n","tags":["数论","拉格朗日插值"],"categories":["数论","拉格朗日插值"]},{"title":"AtCoder Beginner Contest 208","url":"/2021/08/05/atcoder-abc-208/","content":"[比赛链接](https://atcoder.jp/contests/abc208)\n<!-- more -->\n# D Shortest Path Queries 2\n## Description\n[题目链接](https://atcoder.jp/contests/abc208/tasks/abc208_d)\n## Solution\n设 $dp[i][j][k]$ 表示只允许经过城市 $1 \\sim k$，从 $i$ 出发到 $j$ 所需要的最短时间。如果将经过的城市扩展到 $1 \\sim k+1$，此时有两种情况：\n- 不经过城市 $k+1$。\n- 经过城市 $k+1$。显然我们不会经过同一个城市 $2$ 次，此时相当于从 $i$ 经过城市 $1 \\sim k$ 到 $k+1$，再从 $k+1$ 经过城市 $1 \\sim k$ 到 $j$。\n\n由以上分析可得状态转移方程：$dp[i][j][k+1] = min(dp[i][j][k],dp[i][k+1][k]+dp[k+1][j][k])$。\n\n时间复杂度为 $O(n^3)$。 \n## Code\n```cpp Shortest Path Queries 2\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 404;\nconst int MOD = 1E9 + 7;\nint n, m;\nLL dp[MAXN][MAXN][MAXN];\nLL ans = 0;\n\nvoid Floyed() {\n    for (int k = 1; k <= n; k++) {\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                dp[i][j][k] =\n                    min(dp[i][j][k - 1], dp[i][k][k - 1] + dp[k][j][k - 1]);\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                if (dp[i][j][k] != 2e9) ans += dp[i][j][k];\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int k = 0; k <= n; k++)\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++) dp[i][j][k] = 2e9;\n    for (int i = 1; i <= n; i++)\n        for (int k = 0; k <= n; k++) dp[i][i][k] = 0;\n    for (int i = 1; i <= m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        for (int k = 0; k <= n; k++) dp[a][b][k] = min(dp[a][b][k], (LL)c);\n    }\n    Floyed();\n    cout << ans;\n    return 0;\n}\n```\n\n# E Digit Products\n## Description\n[题目链接](https://atcoder.jp/contests/abc208/tasks/abc208_e)\n## Solution\n每一位在 $0 \\sim 9$ 之间，故所有位的乘积可以表示成 $P = 2^a3^b5^c7^d$。由于最多有 $18$ 位，因此 $a \\le 54, b \\le 36, c \\le 18,d \\le 18$，故不同的乘积不超过 $54*36*18*18 = 629856$ 个。我们直接用 ```unordered_map``` 维护数位 $dp$ 就好了。\n\n## Code\n```cpp Digit Products\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nLL n, k;\nunordered_map<LL, LL> dp[20];\nvector<int> v;\n\nvoid add(LL& a, LL b) { a = a + b; }\n\nsigned main() {\n    cin >> n >> k;\n    while (n) {\n        v.push_back(n % 10);\n        n /= 10;\n    }\n    LL pre = 1;\n    for (int i = v.size() - 1; ~i; i--) {\n        if (i == v.size() - 1) {\n            for (int j = 1; j < v[i]; j++) add(dp[i][j], 1);\n            pre = pre * v[i];\n            continue;\n        }\n        // 从顶上界转移\n        for (int j = 0; j < v[i]; j++) add(dp[i][pre * j], 1);\n        // 从全 0 转移\n        for (int j = 1; j < 10; j++) add(dp[i][j], 1);\n        // 不顶上界，不全为 0\n        for (auto& pii : dp[i + 1]) {\n            LL mul = pii.first;\n            LL cnt = pii.second;\n            for (int j = 0; j < 10; j++) add(dp[i][mul * j], cnt);\n        }\n        pre = pre * v[i];\n    }\n    if (pre <= k) add(dp[0][pre], 1);\n    LL ans = 0;\n    for (auto& pii : dp[0])\n        if (pii.first <= k) add(ans, pii.second);\n    cout << ans;\n    return 0;\n}\n```\n\n# F Cumulative Sum\n## Description\n[题目链接](https://atcoder.jp/contests/abc208/tasks/abc208_f)\n## Solution\n由于 $N$ 很大，暴力求解是行不通的，这里要用到拉格朗日插值，关键是确定 $f(N,M)$ 的次数。\n\n首先用归纳法证明 $f(N,M)$ 是 $N$ 的 $M+K$ 次多项式：\n- 假设 $f(N,M)$ 是关于 $N$ 的 $M+K$ 次多项式。\n- 当 $M=0$ 时显然成立。\n- $f(N,M+1) = \\sum \\limits_{n=1}^{N} f(n,M) = \\sum \\limits_{n=1}^{N} (n 的 M+K 次多项式) = (N 的 M+K+1 次多项式)$。\n\n确定了 $f(N,M)$ 的次数，我们只需求出 $f(i,M),其中 1\\le i \\le M+K+1$，再用这 $M+K+1$ 个点插值便可快速求出该多项式在 $N$ 处的值。\n\n时间复杂度为 $O((M+K)M)$。这里 $M$ 很小，可以通过。\n## Code\n```cpp Cumulative Sum \n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXM = 35;\nconst int MAXN = 2.5E6 + 35;\nconst int MOD = 1e9 + 7;\nLL n, m, k;\nLL x[MAXN], y[MAXN];\nLL f[2][MAXM];\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\n// 插值点数，插值点，目标点，要求x连续递增\nLL lagrange_cont(int n, LL* x, LL* y, LL k) {\n    LL ans = 0;\n    vector<LL> pre(n + 1), suf(n + 2), fac(n), inv(n);\n    pre[0] = fac[0] = inv[0] = suf[n + 1] = 1;\n    for (int i = 1; i <= n; i++) pre[i] = (k - x[i]) % MOD * pre[i - 1] % MOD;\n    for (int i = n; i >= 1; i--) suf[i] = (k - x[i]) % MOD * suf[i + 1] % MOD;\n    for (int i = 1; i < n; i++) fac[i] = fac[i - 1] * i % MOD;\n    inv[n - 1] = qpow(fac[n - 1], MOD - 2, MOD);\n    for (int i = n - 2; ~i; i--) inv[i] = inv[i + 1] * (i + 1) % MOD;\n    for (int i = 1; i <= n; i++)\n        ans =\n            (ans + ((n - i) % 2 ? -1ll : 1ll) * y[i] * pre[i - 1] % MOD *\n                       suf[i + 1] % MOD * inv[i - 1] % MOD * inv[n - i] % MOD) %\n            MOD;\n    return (ans + MOD) % MOD;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m >> k;\n    for (int i = 1; i <= m + k + 1; i++) {\n        x[i] = i;\n        f[i % 2][0] = qpow(i, k, MOD);\n        for (int j = 1; j <= m; j++)\n            f[i % 2][j] = (f[(i - 1) % 2][j] + f[i % 2][j - 1]) % MOD;\n        y[i] = f[i % 2][m];\n    }\n    cout << lagrange_cont(m + k + 1, x, y, n % MOD);\n    return 0;\n}\n```\n\n## Bonus\n将原题中 $M \\le 30$ 改为 $M \\le 10^7$，求 $f(N,M)$。","tags":["动态规划","拉格朗日插值","contest","数位DP"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 210","url":"/2021/07/27/atcoder-abc-210/","content":"[比赛链接](https://atcoder.jp/contests/abc210)\n<!-- more -->\n# D National Railway\n## Description\n[题目链接](https://atcoder.jp/contests/abc210/tasks/abc210_d)\n## Solution\n对于 $(i,j)$，我们只需要考虑 $i' \\le i$ 的点和它之间的代价，分两种情况：\n1. $j' \\le j$，代价为 $A_{i,j}+C*(i+j)+A_{i',j'}-C*(i'+j')$。\n2. $j' > j$，代价为 $A_{i,j}+C*(i-j)+A_{i',j'}-C*(i'-j')$。\n\n我们只需要对 $A_{i',j'}-C*(i'+j')$ 和 $A_{i',j'}-C*(i'-j')$ 记录二维前缀/后缀最小值即可。\n## Code \n```cpp National Railway\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1E3 + 5;\nconst int MOD = 1E9 + 7;\nint n, m;\nLL a[MAXN][MAXN], mi1[MAXN][MAXN], mi2[MAXN][MAXN], c;\n\nsigned main() {\n    // freopen(\"1.in\", \"r\", stdin);\n    ios::sync_with_stdio(false);\n    cin >> n >> m >> c;\n    for (int i = 0; i <= n + 1; i++)\n        for (int j = 0; j <= m + 1; j++) mi1[i][j] = mi2[i][j] = LONG_LONG_MAX;\n    LL ans = LONG_LONG_MAX;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++) cin >> a[i][j];\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++)\n            mi1[i][j] =\n                min({a[i][j] - c * (i + j), mi1[i][j - 1], mi1[i - 1][j]});\n    for (int i = 1; i <= n; i++)\n        for (int j = m; j >= 1; j--)\n            mi2[i][j] =\n                min({a[i][j] - c * (i - j), mi2[i][j + 1], mi2[i - 1][j]});\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++) {\n            if (i > 1) ans = min(ans, a[i][j] + c * (i + j) + mi1[i - 1][j]);\n            if (j > 1) ans = min(ans, a[i][j] + c * (i + j) + mi1[i][j - 1]);\n            if (i > 1) ans = min(ans, a[i][j] + c * (i - j) + mi2[i - 1][j]);\n            if (j < m) ans = min(ans, a[i][j] + c * (i - j) + mi2[i][j + 1]);\n        }\n    cout << ans;\n    return 0;\n}\n```\n\n# E Ring MST\n## Description\n[题目链接](https://atcoder.jp/contests/abc210/tasks/abc210_e)\n## Solution\n考虑 $Kruskal$ 算法，每次选择最小的不形成环的边不断加入。然而其时间复杂度为 $O(ElogE)$，其中 $E$ 为图的边数。\n\n在本题中，图的边数是巨大的，所以需要加快 $Kruskal$ 算法加边的过程。\n\n设从小到大枚举到 $C_t$ 时 $Kruskal$ 算法形成的图为 $G_t$，$X_t$ 为 $G_t$ 中联通块的个数。则新增的联通块个数为 $X_{t-1} - X_t$。\n\n所以最终答案为 $\\sum\\limits_{t=1}^{M}C_t(X_{t-1}-X_t)$。如果 $X_M > 1$，则最终图不连通，输出 ``-1``。\n\n如何求得 $X_t$：\n因为对于任意 $i = 1, 2, ..., t$ 和任意 $x = 0, 1, ..., N - 1$，我们可以从顶点 $x$ 移动到 $(x + A_i) \\mod N$。所以在 $G_t$ 中，我们可以从 $v$ 移动到 $w$ 当且仅当存在整数 $k_1, k_2, ..., k_t$，使得 $w \\equiv v + k_1A_1+k_2A_2+...+k_tA_t  \\mod N$\n\n上述式子 $\\Leftrightarrow$ $w = v + k_0N+k_1A_1+k_2A_2+...+k_tA_t$ $\\Leftrightarrow$ $w=v + kd_t$ $\\Leftrightarrow$ $w \\equiv v \\mod d_t$\n\n其中 $d_t = gcd(N, A_1, A_2, ..., A_t)$。\n\n因此 $u$ 和 $v$ 属于相同联通块当且仅当 $w \\equiv v \\mod d_t$，因此 $X_t = d_t$。\n## Code\n```cpp Ring MST\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, m;\narray<pair<int, int>, MAXN> a;\n\nvoid kruskal() {\n    sort(a.begin() + 1, a.begin() + m + 1);\n    int cnt = 0, gcd = n;\n    long long ans = 0;\n    for (int i = 1; i <= m; i++) {\n        int tmp = __gcd(gcd, a[i].second);\n        int add = min(gcd - tmp, n - 1 - cnt);\n        cnt += add;\n        ans += 1LL * a[i].first * add;\n        gcd = tmp;\n    }\n    cout << (gcd == 1 ? ans : -1) << \"\\n\";\n}\n\nint main() {\n    boost;\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) cin >> a[i].second >> a[i].first;\n    kruskal();\n    return 0;\n}\n```\n\n# F Coprime Solitaire\n## Description\n[题目链接](https://atcoder.jp/contests/abc210/tasks/abc210_f)\n## Solution\n枚举 $2$ 到 $2*10^6$ 的素数 $p$。\n\n对于每个 $p$，设所选择的卡牌为 $X_{p,1}, X_{p, 2}, ..., X_{p,k_p}$ (区分正反面, 即 $X_{p,i}$ 可能是某个卡牌的正面或反面)。\n\n则 ``Takahashi is happy`` 当且仅当 $\\forall p(\\le 2*10^6)$ 且 $p$ 为素数，卡牌朝上的数字中只有至多一个有质因子 $p$。即选了 $X_{p,i}$，其它 $X_{p,j}$ 都不能选。\n\n转化为逻辑表达式为 $F:=\\bigwedge\\limits_{p:prime,p\\le 2*10^6}\\bigwedge\\limits_{1\\le i,j \\le k_p, i \\ne j} (X_{p,i} \\rightarrow \\neg X_{p,j}) = true$\n\n我们令 $F_p:= \\bigwedge\\limits_{1\\le i,j \\le k_p, i \\ne j} (X_{p,i} \\rightarrow \\neg X_{p,j})$\n\n该问题可通过 [2-SAT](https://shaun-shane.vercel.app/2021/07/27/two-sat/) 算法解决。但是根据上述表达式建图边数过多，无法在规定时间内通过该题，还需要引入 2 类增补变量 $Y_{p,1}, Y_{p,2},...,Y_{p,k_p}$ 和 $Z_{p,1}, Z_{p,2},...,Z_{p,k_p}$，用 $F_p'$ 来替换 $F_p$:\n\n$$F_p':= \\bigwedge\\limits_{1\\le i\\le k_p}(Y_{p,i} \\rightarrow \\neg X_{p,i}) \\wedge \\bigwedge\\limits_{2\\le i\\le k_p}(Y_{p,i} \\rightarrow Y_{p,i-1}) \\wedge \\bigwedge\\limits_{2\\le i\\le k_p}(X_{p,i} \\rightarrow Y_{p,i-1}) \\wedge  \\\\  \\bigwedge\\limits_{1\\le i\\le k_p}(Z_{p,i} \\rightarrow \\neg X_{p,i}) \\wedge \\bigwedge\\limits_{1\\le i\\le k_p-1}(Z_{p,i} \\rightarrow Z_{p,i+1}) \\wedge \\bigwedge\\limits_{1\\le i\\le k_p-1}(X_{p,i} \\rightarrow Z_{p,i+1})$$\n\n画下图可知这些增补变量相当于两条链，把 $X_{p,i}$ 与 $X_{p,1\\le j < i}$ 以及 $X_{p,i}$ 与 $X_{p, i<j \\le k_p}$ 间接连接起来，从而不用两两加边。\n\n最后令 $F'=\\bigwedge\\limits_{p:prime,p\\le 2*10^6}F_p'$，则 $F' \\Leftrightarrow F$。\n\n时间复杂度 $O(Nlog{\\max(A_i,B_i)})$。\n\n注意即使 $A, B$ 全部相同，最多也只由 8 个不同素数组成，所以即使一个 $p$ 的倍数对应多个 $A_i$ 或 $B_i$，复杂度也是 $O(Nlog{\\max(A_i,B_i)})$ 的。\n## Code\n```cpp Coprime Solitaire\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 3e4 + 4, MAXV = 2e6 + 6, MOD = 1e9 + 7;\n\nint n, tot, cntscc, top, N;\nint dfn[MAXV], low[MAXV], stk[MAXV], ins[MAXV], belong[MAXV];\narray<int, MAXN> a, b;\nvector<int> primes;\nvector<int> ids[MAXV], g[MAXV];\n\nvoid seive() {\n    vector<bool> isprime(MAXV);\n    fill(isprime.begin(), isprime.end(), true);\n    isprime[0] = isprime[1] = false;\n    for (int i = 2; i < MAXV; i++) {\n        if (isprime[i]) primes.push_back(i);\n        for (auto& j : primes) {\n            if (i * j >= MAXV) break;\n            isprime[i * j] = false;\n            if (i % j == 0) break;\n        }\n    }\n}\n\nvoid add(int u, int v) { g[u].push_back(v); }\n\nvoid tarjan(int cur) {\n    dfn[cur] = low[cur] = ++tot;\n    stk[++top] = cur, ins[cur] = true;\n    for (const auto& to : g[cur]) {\n        if (!dfn[to]) {\n            tarjan(to);\n            low[cur] = min(low[cur], low[to]);\n        } else if (ins[to]) {\n            low[cur] = min(low[cur], dfn[to]);\n        }\n    }\n    if (dfn[cur] == low[cur]) {\n        ++cntscc;\n        int tmp;\n        do {\n            tmp = stk[top--];\n            ins[tmp] = false;\n            belong[tmp] = cntscc;\n        } while (cur != tmp);\n    }\n}\n\nint main() {\n    boost;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i] >> b[i];\n        ids[a[i]].push_back(i);\n        ids[b[i]].push_back(i + n); // 某个值对应所有节点编号\n    }\n    seive();\n    vector<int> nodes;\n    N = 2 * n;\n    for (auto& i : primes) {\n        nodes.clear();\n        for (int j = i; j < MAXV; j += i) { // p, 2p, ... kp\n            for (const auto& id: ids[j]) nodes.push_back(id);\n        }\n        for (int j = N + 1; j <= N + nodes.size(); j++) {\n            int x = nodes[j - N - 1];\n            int nx = x > n ? x - n : x + n;\n            add(j, nx);\n            if (j > N + 1) add(j, j - 1), add(x, j - 1);\n        }\n        for (int j = N + nodes.size() + 1; j <= N + nodes.size() * 2; j++) {\n            int x = nodes[j - N - nodes.size() - 1];\n            int nx = x > n ? x - n : x + n;\n            add(j, nx);\n            if (j != N + nodes.size() * 2) add(j, j + 1), add(x, j + 1);\n        }\n        N += nodes.size() * 2;\n    }\n    for (int i = 1; i <= 2 * n; i++) \n        if (!dfn[i]) tarjan(i);\n    for (int i = 1; i <= n; i++)\n        if (belong[i] == belong[i + n]) {\n            cout << \"No\\n\";\n            return 0;\n        }\n    cout << \"Yes\\n\";\n    return 0;\n}\n```\n","tags":["contest"],"categories":["contest"]},{"title":"2-SAT 笔记","url":"/2021/07/27/two-sat/","content":"SAT 是适定性问题 (Satisfiability) 问题的简称。一般形式为 $k$ - 适定性问题，简称 ``k-SAT``。而当 $k > 2$ 时该问题为 NP 完全的。所以我们只研究 $k = 2$ 的情况。\n<!-- more -->\n# 定义\n2-SAT 简单地讲就是给出 $n$ 个集合，每个集合有两个元素 $<a, b>$，以及若干个矛盾关系 (如 $a_i$ 与 $b_i$ 或 $b_j$不能同时选择)。然后从每个集合选择 $a$ 或 $b$，判断能否使这些元素两两不矛盾。\n\n# Solution\n将矛盾关系转化为形如 $(x_i \\vee x_j) \\wedge (\\neg x_p \\vee x_q) \\wedge ...$ 的合取式，最后要使得该逻辑表达式的值为 1。\n\n对于每组 $(i \\vee j)$，其等值于 $\\neg i \\rightarrow j$ 以及 $\\neg j \\rightarrow i$。表示 $i, j$ 至少选择一个，如果不选 $i$，则必须选 $j$；不选 $j$ 则必须选 $i$。否则合取式的值为 0。\n\n例如 $a_i 和 b_j$ 存在矛盾，则可得 $a_i \\rightarrow \\neg b_j$ 以及 $b_j \\rightarrow \\neg a_i$，也等值于 $\\neg a_i \\vee \\neg b_j$，表示 $a_i$ 和 $b_j$ 至少有一个不选。\n\n据此可建立 $2n$ 个点的有向图。对于每个变量 $x_i$，用节点 $i$ 表示 $x_i$ 为真，用节点 $i + n$ 或 $i \\oplus 1$ 表示 $x_i$ 为假。如果 $i \\rightarrow j$，则从 $i$ 向 $j$ 连一条有向边 ($i$，$j$ 可能带 $\\neg$ 符号)。\n\n对于每个变量 $x$ 有 4 种情况：\n- $x$ 与 $\\neg x$ 无关系，取值任意\n- $x \\rightarrow \\neg x$，取 $x$ 为假，否则蕴含式的值为假\n- $\\neg x \\rightarrow x$，取 $x$ 为真\n- $x \\rightarrow \\neg x$ 并且 $\\neg x \\rightarrow x$，无解\n\n对于上述第四种情况，根据假言三段论可知，$x$ 和 $\\neg x$ 一定在同一个联通分量中。于是跑一遍 $tarjan$，判断 $i$ 与 $i + n$ 是否在同一个强连通分量中。\n\n```cpp tarjan 模板\nint n, m, tot, top, cntscc;\nvector<int> g[MAXN * 2];\nint dfn[MAXN * 2], low[MAXN * 2], stk[MAXN * 2], ins[MAXN * 2], belong[MAXN * 2];\n\nvoid tarjan(int cur) {\n    dfn[cur] = low[cur] = ++tot;\n    stk[++top] = cur, ins[cur] = true;\n    for (const auto& to : g[cur]) {\n        if (!dfn[to]) {\n            tarjan(to);\n            low[cur] = min(low[cur], low[to]);\n        } else if (ins[to]) {\n            low[cur] = min(low[cur], dfn[to]);\n        }\n    }\n    if (dfn[cur] == low[cur]) {\n        ++cntscc;\n        int tmp;\n        do {\n            tmp = stk[top--];\n            ins[tmp] = false;\n            belong[tmp] = cntscc;\n        } while (cur != tmp);\n    }\n}\n\nfor (int i = 1; i <= 2 * n; i++) \n        if (!dfn[i]) tarjan(i);\n```\n\n# 可行解\n## 任意解\n[模板题](https://www.luogu.com.cn/problem/P4782)\n因为 $tarjan$ 求强连通分量时使用了栈，所以 $tarjan$ 求得的 $scc$ 编号相当于反拓扑序。所以如果 $i$ 所在的 $scc$ 编号小于 $i + n$ 或 $i \\oplus 1$ 所在的 $scc$ 编号，则说明 $\\neg x_i \\rightarrow ^* x_i$，$x_i = true$。\n\n时间复杂度 $O(n + m)$。\n```cpp\nfor (int i = 1; i <= n; i++)\n    if (belong[i] == belong[i + n]) {\n        cout << \"IMPOSSIBLE\" << \"\\n\";\n        return 0;\n    }\ncout << \"POSSIBLE\" << \"\\n\";\nfor (int i = 1; i <= n; i++) // !x -> x thus x = ture in rev topo order\n    ans[i] = belong[i] < belong[i + n], cout << ans[i] << \" \";\n```\n\n## 最小字典序解\n[注意多组数据](https://acm.hdu.edu.cn/showproblem.php?pid=1814)\n如果需要求出被选择的元素的最小字典序，这时候就不能使用 $tarjan$ 了。\n\n考虑从小到大枚举元素，优先使用 dfs 将该元素 $x$ 对应节点以及之后的节点染色为 $true$，如果出现矛盾则将 $\\neg x$ 对应的节点以及之后的节点染色为 $true$。如果都不行，则无解。\n\n可以通过栈或 ``vector`` 来撤销之前的染色操作。\n\n时间复杂度 $O(nm)$。\n```cpp O(nm)\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 8008, MOD = 1e9 + 7;\n\nint n, m, top;\nvector<int> g[MAXN * 2];\narray<int, MAXN * 2> mark, stk;\n\nvoid add(int u, int v) { g[u].emplace_back(v); }\n\nvoid init() {\n    for (int i = 0; i < 2 * n; i++) g[i].clear();\n    fill(mark.begin(), mark.end(), 0);\n}\n\nbool dfs(int cur) { // 将 current 标记为 true\n    if (mark[cur ^ 1]) return false;\n    if (mark[cur]) return true;\n    mark[cur] = true;\n    stk[top++] = cur;\n    for (auto& to : g[cur]) if (!dfs(to)) return false;\n    return true;\n}\n\nbool solve() {\n    for (int i = 0; i < 2 * n; i += 2) {\n        if (!mark[i] && !mark[i ^ 1]) {\n            top = 0;\n            if (!dfs(i)) {\n                while (top > 0) mark[stk[--top]] = false;\n                if (!dfs(i + 1)) return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    boost;\n    while (cin >> n >> m) {\n        init();\n        for (int i = 1, a, b; i <= m; i++) {\n            cin >> a >> b;\n            a--, b--;\n            add(a, b ^ 1);  // !a | !b\n            add(b, a ^ 1);\n        }\n        if (!solve()) {\n            cout << \"NIE\\n\";\n        } else {\n            for (int i = 0; i < 2 * n; i++)\n                if (mark[i]) cout << i + 1 << \"\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n# 参考链接\n[2-SAT](https://zhuanlan.zhihu.com/p/50211772)\n[OI-wiki](https://oi-wiki.org/graph/2-sat/)\n\n# 例题\n## Kuta Puzzle\n[题目链接](https://ac.nowcoder.com/acm/contest/1061/D)\n$x_i$ 取值为 1 对应节点 $i$，否则对应 $i + n$。\n\n分 6 种情况讨论:\n- $x_a \\wedge x_b = 0$\n  对应的逻辑表达式为 $\\neg x_a \\vee \\neg x_b$，等值于 $x_a \\rightarrow \\neg x_b$ 以及 $x_b \\rightarrow \\neg x_a$\n- $x_a \\wedge x_b = 1$\n  对应的逻辑表达式为 $(x_a \\vee x_a) \\wedge (x_b \\vee x_b)$，等值于 $(\\neg x_a \\rightarrow x_a) \\wedge (\\neg x_b \\rightarrow x_b)$\n- $x_a \\vee x_b = 0$\n  对应的逻辑表达式为 $(\\neg x_a \\vee \\neg x_a) \\wedge (\\neg x_b \\vee \\neg x_b)$，等值于 $(x_a \\rightarrow \\neg x_a) \\wedge (x_b \\rightarrow \\neg x_b)$\n- $x_a \\vee x_b = 1$\n  对应的逻辑表达式 $(x_a \\vee x_b)$，等值于 $(\\neg x_a \\rightarrow x_b) \\wedge (\\neg x_b \\rightarrow x_a)$\n- $x_a \\oplus x_b = 0$\n  对应的逻辑表达式为 $(x_a \\wedge x_b) \\vee (\\neg x_a \\wedge \\neg x_b)$。但我们需要的是合取式，所以需要等值演算一下，得到 $(\\neg x_a \\vee x_b) \\wedge (\\neg x_b \\vee x_a)$。(其实异或为 0 也相当于 $(x_a \\leftrightarrow x_b)$)。\n- $x_a \\oplus x_b = 0$\n  对应的逻辑表达式为 $(x_a \\leftrightarrow \\neg x_b)$，等值于 $(\\neg x_a \\vee \\neg x_b) \\wedge (x_a \\vee x_b)$。\n\n按照上述表达式建边即可。\n\n```cpp Kuta Puzzle\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e3 + 3, MOD = 1e9 + 7;\n\nint n, m, tot, top, cntscc;\nvector<int> g[MAXN * 2];\nint dfn[MAXN * 2], low[MAXN * 2], stk[MAXN * 2], ins[MAXN * 2], belong[MAXN * 2], ans[MAXN];\n\nvoid add(int u, int v) { g[u].emplace_back(v); }\n\nvoid tarjan(int cur) {\n    dfn[cur] = low[cur] = ++tot;\n    stk[++top] = cur, ins[cur] = true;\n    for (const auto& to : g[cur]) {\n        if (!dfn[to]) {\n            tarjan(to);\n            low[cur] = min(low[cur], low[to]);\n        } else if (ins[to]) {\n            low[cur] = min(low[cur], dfn[to]);\n        }\n    }\n    if (dfn[cur] == low[cur]) {\n        ++cntscc;\n        int tmp;\n        do {\n            tmp = stk[top--];\n            ins[tmp] = false;\n            belong[tmp] = cntscc;\n        } while (cur != tmp);\n    }\n}\n\n\nint main() {\n    boost;\n    cin >> n >> m;\n    string type;\n    for (int t = 1; t <= m; t++) {\n        int a, b, c;\n        cin >> a >> b >> c >> type;\n        a++, b++;\n        if (type == \"AND\") {\n            if (c == 0) add(a, b + n), add(b, a + n);\n            else add(a + n, a), add(b + n, b);\n        } else if (type == \"OR\") {\n            if (c == 0) add(a, a + n), add(b, b + n);\n            else add(a + n, b), add(b + n, a);\n        } else {\n            if (c == 0) add(a, b), add(b, a), add(a + n, b + n), add(b + n, a + n);\n            else add(a, b + n), add(b, a + n), add(b + n, a), add(a + n, b);\n        }\n    }\n    for (int i = 1; i <= 2 * n; i++) \n        if (!dfn[i]) tarjan(i);\n    for (int i = 1; i <= n; i++)\n        if (belong[i] == belong[i + n]) {\n            cout << \"NO\" << \"\\n\";\n            return 0;\n        }\n    cout << \"YES\" << \"\\n\";\n    return 0;\n}\n```\n\n## TV Show Game K\n[题目链接](http://codeforces.com/gym/101987)\n题目大意是说每个人从 $k \\ge 3$ 盏灯 （灯的初始颜色未知）中选了 3 盏灯猜测颜色（红色或蓝色）。每个人都猜中 $\\ge 2$ 盏灯颜色即可满足。若可满足，则要求给出一种灯的颜色方案。\n\n对于一组赋值: a x b y c z 来说：\n- 若 $\\neg a$，则 $b \\wedge c$\n- 若 $\\neg b$，则 $a \\wedge c$\n- 若 $\\neg c$，则 $a \\wedge b$\n\n根据上述可得若干蕴含式，转化为 ``2-SAT`` 标准形式即可。\n\n```cpp TV Show Game K\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e4 + 4, MOD = 1e9 + 7;\n\nint n, m, tot, top, cntscc;\nvector<int> g[MAXN * 2];\nint dfn[MAXN * 2], low[MAXN * 2], stk[MAXN * 2], ins[MAXN * 2], belong[MAXN * 2];\nchar ans[MAXN];\n\nvoid add(int u, int v) { g[u].emplace_back(v); }\n\nvoid tarjan(int cur) {\n    dfn[cur] = low[cur] = ++tot;\n    stk[++top] = cur, ins[cur] = true;\n    for (const auto& to : g[cur]) {\n        if (!dfn[to]) {\n            tarjan(to);\n            low[cur] = min(low[cur], low[to]);\n        } else if (ins[to]) {\n            low[cur] = min(low[cur], dfn[to]);\n        }\n    }\n    if (dfn[cur] == low[cur]) {\n        ++cntscc;\n        int tmp;\n        do {\n            tmp = stk[top--];\n            ins[tmp] = false;\n            belong[tmp] = cntscc;\n        } while (cur != tmp);\n    }\n}\n\n\nint main() {\n    boost;\n    cin >> n >> m;\n    string c[3];\n    int l[3], p[3];\n    for (int t = 1; t <= m; t++) { // 一个人猜 3 盏灯 a b c颜色 0/1，猜对至少 2 个则可满足\n        for (int i = 0; i < 3; i++)\n            cin >> l[i] >> c[i], p[i] = c[i] == \"R\" ? 1 : 0;\n\n        add(l[0] + (1 - !p[0]) * n, l[1] + (1 - p[1]) * n);\n        add(l[1] + (1 - !p[1]) * n, l[0] + (1 - p[0]) * n);\n        add(l[0] + (1 - !p[0]) * n, l[2] + (1 - p[2]) * n);\n        add(l[2] + (1 - !p[2]) * n, l[0] + (1 - p[0]) * n);\n\n        add(l[1] + (1 - !p[1]) * n, l[0] + (1 - p[0]) * n);\n        add(l[0] + (1 - !p[0]) * n, l[1] + (1 - p[1]) * n);\n        add(l[1] + (1 - !p[1]) * n, l[2] + (1 - p[2]) * n);\n        add(l[2] + (1 - !p[2]) * n, l[1] + (1 - p[1]) * n);\n\n        add(l[2] + (1 - !p[2]) * n, l[0] + (1 - p[0]) * n);\n        add(l[0] + (1 - !p[0]) * n, l[2] + (1 - p[2]) * n);\n        add(l[2] + (1 - !p[2]) * n, l[1] + (1 - p[1]) * n);\n        add(l[1] + (1 - !p[1]) * n, l[2] + (1 - p[2]) * n);\n    }\n    for (int i = 1; i <= 2 * n; i++) \n        if (!dfn[i]) tarjan(i);\n    for (int i = 1; i <= n; i++)\n        if (belong[i] == belong[i + n]) {\n            cout << -1 << \"\\n\";\n            return 0;\n        }\n    for (int i = 1; i <= n; i++)\n        ans[i] = belong[i] < belong[i + n] ? 'R' : 'B', cout << ans[i];\n    return 0;\n}\n```\n\n## Coprime solitaire\n[链接](https://shaun-shane.vercel.app/2021/07/27/atcoder-abc-210/#f-coprime-solitaire)\n\n","tags":["2-SAT"],"categories":["图论","2-SAT"]},{"title":"AtCoder Beginner Contest 209","url":"/2021/07/17/atcoder-abc-209/","content":"[比赛链接](https://atcoder.jp/contests/abc209)\n<!-- more -->\n# C Not Equal\n## Description\n[题目链接](https://atcoder.jp/contests/abc209/tasks/abc209_c)\n## Solution\n将数组 C 从小到大排序。则序列 A 的个数为 $C_1 \\cdot \\max (C_2 - 1, 0) \\cdot \\max (C_3 - 2, 0) \\cdot ... \\cdot \\max (C_n - n + 1, 0)$。\n## Code\n```cpp Not Equal\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 2e5 + 5, MOD = 1e9 + 7;\n\nint n;\narray<int, MAXN> c;\n\nint main() {\n    boost;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> c[i];\n    sort(c.begin() + 1, c.begin() + n + 1);\n    long long ans = c[1];\n    for (int i = 2; i <= n; i++) {\n        ans = ans * max(0, c[i] - i + 1) % MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n# D Collision\n## Description\n[题目链接](https://atcoder.jp/contests/abc209/tasks/abc209_d)\n## Solution\n由题意知 ``The Kingdom of Takahashi`` 构成一颗树。\n\n任选一个节点作为根，进行 dfs 处理出每个节点的深度。容易发现，当两个节点的深度奇偶性不同时，``Takahashi`` 和 ``Aoki`` 在道路上相遇；否则在某个小镇相遇。\n## Code\n```cpp Collision\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, q;\nvector<int> g[MAXN];\narray<int, MAXN> dep;\n\nvoid dfs(int cur, int f) {\n    dep[cur] = dep[f] + 1;\n    for (auto& to : g[cur]) {\n        if (to == f) continue;\n        dfs(to, cur);\n    }\n}\n\nsigned main() {\n    boost;\n    cin >> n >> q;\n    for (int i = 1, u, v; i < n; i++) {\n        cin >> u >> v;\n        g[u].push_back(v), g[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (int i = 1, c, d; i <= q; i++) {\n        cin >> c >> d;\n        if ((dep[c] ^ dep[d]) & 1) cout << \"Road\\n\";\n        else cout << \"Town\\n\";\n    }\n    return 0;\n}\n```\n\n\n# E Shiritori\n## Description\n[题目链接](https://atcoder.jp/contests/abc209/tasks/abc209_e)\n## Solution\n将 $n$ 个单词看作一个有向图的 $n$ 条边，图的顶点为单词的前 3 和后 3 个字母，且前 3 个字母向后 3 个字母连一条有向边。则得到的图有至多 $52^3$ 个顶点和 $n$ 条边。\n\n于是问题等价于给定一个有向图，其中一个顶点上放有一颗棋子。然后两人轮流选择一条边，边的起点为棋子初始位置，然后将棋子移动到边的终点。最终不能移动棋子的玩家输。\n\n该问题可通过倒推法 (``backward induction``) 解决。首先将顶点分为 3 类，分别为 ``winning``、 ``losing``、 ``drawing``：\n- 没有出边的顶点类型为 ``losing``\n- 如果一个顶点连出去的所有边的终点类型为 ``winning``，该顶点类型为 ``losing``\n- 如果一个顶点连出去的其中一条边的终点类型为 ``losing``，该顶点类型为 ``winning``\n- 如果一个顶点类型既不是 ``winning`` 也不是 ``losing``，则顶点类型为 ``drawing``\n\n于是可通过类似拓扑排序的方法在反图上进行倒推，当一个节点类型确定后，将其入队，继续倒推。最终得到所有节点类型的时间复杂度为 $O(n)$。\n\n需要注意最后判断时，一个单词只对应一条边，需要通过边的终点类型推断起点类型。\n\n## Code\n```cpp Shiritori\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nint charToInt(int a) {\n    if (isupper(a)) return a - 'A' + 26;\n    else return a - 'a';\n}\n\nint stringToInt(char a, char b, char c) {\n    return charToInt(a) * 52 * 52 + charToInt(b) * 52 + charToInt(c);\n}\n\nconstexpr int MAXN = 2e5 + 5, MOD = 1e9 + 7, M = 52 * 52 * 52;\n\nint n;\nstring s;\nvector<int> revG[M];\narray<int, M> in, ans; // ans = 0 -> lose, 1 -> win, -1 -> draw\narray<int, MAXN> u, v;\n\nsigned main() {\n    boost;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> s;\n        u[i] = stringToInt(s[0], s[1], s[2]);\n        v[i] = stringToInt(s[s.size() - 3], s[s.size() - 2], s[s.size() - 1]);\n        in[u[i]]++;\n        revG[v[i]].push_back(u[i]);\n    }\n    queue<int> q;\n    for (int i = 0; i < M; i++) ans[i] = -1;\n    for (int i = 0; i < M; i++) if (!in[i]) ans[i] = 0, q.push(i);\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        for (const auto& to : revG[cur]) {\n            if (ans[to] == -1) {\n                in[to]--;\n                if (ans[cur] == 0) ans[to] = 1, q.push(to);\n                else if (in[to] == 0) {\n                    ans[to] = 0;\n                    q.push(to);\n                }\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        if (ans[v[i]] == -1) cout << \"Draw\\n\";\n        else if (ans[v[i]] == 0) cout << \"Takahashi\\n\";\n        else cout << \"Aoki\\n\";\n    }\n    return 0;\n}\n```\n\n\n# F Deforestation \n## Description\n[题目链接](https://atcoder.jp/contests/abc209/tasks/abc209_f)\n## Solution\n可以[证明](https://atcoder.jp/contests/abc209/editorial/2236)，要让总的 ``cost`` 最小，当且仅当砍树的顺序满足如下条件：\n- 如果 $H_i < H_{i+1}$，则第 $i+1$ 棵树需要在第 $i$ 棵树之前被砍掉\n- 如果 $H_i > H_{i+1}$，则第 $i$ 棵树需要在第 $i+1$ 棵树之前被砍掉\n\n考虑 DP，设 $dp_{i,j}$ 表示枚举到第 $i$ 棵树，且第 $i$ 棵树是第 $j$ 个被砍去的 $1 ... i$ 的全排列的个数。\n\n则有状态转移如下：\n- 如果 $H_i = H_{i+1}$，则 $dp_{i+1,j} = \\sum \\limits_{k = 1}^{i} dp_{i,k}$\n- 如果 $H_i < H_{i+1}$，则 $dp_{i+1,j} = \\sum \\limits_{k = j}^{i} dp_{i,k}$\n- 如果 $H_i > H_{i+1}$，则 $dp_{i+1,j} = \\sum \\limits_{k = 1}^{j-1} dp_{i,k}$\n\n朴素 DP 的时间复杂度为 $O(N^3)$，使用前缀和优化 DP 可做到 $O(N^2)$。\n\n## Code\n```cpp Deforestation \n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 4e3 + 3, MOD = 1e9 + 7;\n\nint n;\narray<int, MAXN> h;\nlong long dp[MAXN][MAXN], sum[MAXN][MAXN];\n\ntemplate<typename T>\nvoid add(T& a, T b) {\n    a += b;\n    if (a > MOD) a -= MOD;\n}\n\nsigned main() {\n    boost;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> h[i];\n    h[0] = h[1];\n    dp[0][0] = 1;\n    for (int i = 0; i <= n; i++) sum[0][i] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            if (h[i - 1] == h[i]) {\n                add(dp[i][j], sum[i - 1][i]);\n            } else if (h[i - 1] < h[i]) {\n                add(dp[i][j], (sum[i - 1][i] - sum[i - 1][j - 1] + MOD) % MOD);\n            } else { // i + 1 be removed after i\n                add(dp[i][j], (sum[i - 1][j - 1] - sum[i - 1][0] + MOD) % MOD);\n            }\n        }\n        for (int j = 1; j <= n; j++)\n            add(sum[i][j], (sum[i][j - 1] + dp[i][j]) % MOD);\n    }\n    long long ans = 0;\n    for (int j = 1; j <= n; j++) add(ans, dp[n][j]);\n    cout << ans << \"\\n\";\n    return 0;\n}\n```","tags":["contest"],"categories":["contest"]},{"title":"Codeforces Round 717 Div2","url":"/2021/04/30/cf-717-div2/","content":"[比赛链接](https://codeforces.com/contest/1516)\n<!-- more -->\n\n# A - Tit for Tat\n## Description\n[题目链接](https://codeforces.com/contest/1516/problem/A)\n## Solution\n显然只需要尽可能把前面的数减小，把多出来的部分移到最后。\n## Code\n```cpp Tit for Tat\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 105;\nconst int MOD = 1E9 + 7;\nint n, k, a[MAXN];\n\nvoid solve(int caseNum) {\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= n; i++) {\n        if (k == 0) break;\n        if (a[i] > 0) {\n            int tmp = min(k, a[i]);\n            a[i] -= tmp;\n            k -= tmp;\n            a[n] += tmp;\n        }\n    }\n    for (int i = 1; i <= n; i++) cout << a[i] << ' ';\n    cout << endl;\n}\n\nsigned main() {\n    int testCase = 1;\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> testCase;\n    for (int i = 1; i <= testCase; i++) solve(i);\n    return 0;\n}\n```\n\n# B - AGAGA XOOORRR\n## Description\n[题目链接](https://codeforces.com/contest/1516/problem/B)\n## Solution\n如果能通过操作使剩下的数相同，记为 $x$，那么原来所有数异或起来要么为 $0$，要么为 $x$。如果异或起来为 0，那么直接输出 YES；否则，由于题目中的操作是对相邻的数进行的，所以从左到右按异或和为 $x$ 分段，最后判断分出的段数是不是奇数即可。 \n## Code\n```cpp AGAGA XOOORRR\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E3 + 5;\nconst int MOD = 1E9 + 7;\nint n, k, a[MAXN], pre[MAXN];\n\nvoid solve(int caseNum) {\n    cin >> n;\n    int tmp = 0;\n    for (int i = 1; i <= n; i++) cin >> a[i], tmp ^= a[i];\n    bool tag = 1;\n    if (tmp == 0) {\n        cout << \"YES\" << endl;\n    } else {\n        int tot = 0, q = 0;\n        for (int i = 1; i <= n; i++) {\n            q ^= a[i];\n            if (q == tmp) tot++, q = 0;\n        }\n        if (tot > 1 && tot % 2)\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n}\n\nsigned main() {\n    int testCase = 1;\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> testCase;\n    for (int i = 1; i <= testCase; i++) solve(i);\n    return 0;\n}\n```\n\n# C - Baby Ehab Partitions Again\n## Description\n[题目链接](https://codeforces.com/contest/1516/problem/C)\n## Solution\n首先用背包判断能否选择一些数，使它们的和恰好是总和的一半。如果不能的话，答案为 0；否则只需要删除一个数就能满足题目条件，具体如下：\n\n由于此时数列的和一定为偶数，若存在一个数是奇数，删掉这个数即可；否则，该数列每一个数都是偶数，那么对原数列的划分等价于将原数列每一个数都除 2 后的划分。我们只需要不断将每个元素除以 2，直到第一次出现奇数为止，之后随便删掉一个奇数即可。\n## Code\n```cpp Baby Ehab Partitions Again\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, a[101], sum;\nbool dp[101][MAXN];\n\nsigned main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i], sum += a[i];\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n        for (int j = 0; j <= sum; j++) {\n            dp[i][j] |= dp[i - 1][j];\n            if (j >= a[i]) dp[i][j] |= dp[i - 1][j - a[i]];\n        }\n    if (sum % 2 || !dp[n][sum / 2])\n        return cout << 0, 0;\n    else {\n        cout << 1 << endl;\n        for (int k = 0; k <= 11; k++)\n            for (int i = 1; i <= n; i++)\n                if ((a[i] >> k) & 1) return cout << i, 0;\n    }\n    return 0;\n}\n```\n\n# D - Cut\n## Description\n[题目链接](https://codeforces.com/contest/1516/problem/D)\n## Solution\n$n$ 个数乘积为它们的 LCM 当且仅当它们两两互质(即每个质因子最多在所有数中出现一次)。一种分段的方法是，从 $i=1$ 开始向右扩展，沿途记录各个质因子出现的次数。如果对于第 $i$ 个数，它的某个质因子在前面出现至少一次，那么必须以 $i$ 为起始扩展新的一段。可以证明该策略是最优的。\n\n首先考虑求以 $i$ 为起始向右扩展后下一段的起始位置，记为 $nxt_i$。我们从 $n$ 到 $1$ 依次求 $nxt_{i}$。假设 $nxt_{i+1}$ 已求出，显然有 $nxt_{i} \\le nxt_{i+1}$。遍历 $a_i$ 的每一个质因子，将 $nxt_{i}$ 对所有质因子最后出现位置的最小值取 $min$ 即可。\n\n接下来考虑如何处理区间查询。对于区间 $[l,r]$, 我们从 $i=l$ 开始按 $nxt_i$ 向后跳，直到越过右端点为止，此时跳的次数即为答案。直接一次一次往后跳比较低效，我们可以用倍增优化。 \n## Code\n```cpp Cut\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\ntemplate <class T>\nvoid write(T x) {\n    if (x < 0) putchar('-'), x = -x;\n    if (x > 9) write(x / 10);\n    putchar(x % 10 + '0');\n}\n\nconst int MAXN = 1E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, a[MAXN], last[MAXN], nxt[MAXN];\nint to[MAXN][20];\n\nsigned main() {\n    read(n, m);\n    for (int i = 1; i <= n; i++) read(a[i]);\n\n    for (int i = 1; i <= n + 1; i++) nxt[i] = n + 1;\n    for (int i = 1; i <= 1E5; i++) last[i] = n + 1;\n    for (int i = n; i >= 1; i--) {\n        nxt[i] = min(nxt[i], nxt[i + 1]);\n        int tmp = a[i];\n        for (int j = 2; j <= sqrt(tmp); j++) {\n            if (tmp % j == 0) nxt[i] = min(nxt[i], last[j]), last[j] = i;\n            while (tmp % j == 0) tmp /= j;\n        }\n        if (tmp != 1) nxt[i] = min(nxt[i], last[tmp]), last[tmp] = i;\n    }\n\n    for (int i = 1; i <= n + 1; i++) to[i][0] = nxt[i];\n    for (int j = 1; j <= 19; j++)\n        for (int i = 1; i <= n + 1; i++) to[i][j] = to[to[i][j - 1]][j - 1];\n\n    for (int i = 1; i <= m; i++) {\n        int l, r;\n        read(l, r);\n        int cnt = 0;\n        for (int j = 19; ~j; j--) {\n            if (to[l][j] <= r) {\n                l = to[l][j];\n                cnt += (1 << j);\n            }\n        }\n        printf(\"%d\\n\", cnt + 1);\n    }\n    return 0;\n}\n```\n\n# E - Baby Ehab Plays with Permutations\n## Description\n[题目链接](https://codeforces.com/contest/1516/problem/E)\n## Solution\n设 $dp[i][j]$ 表示长度为 $i$，**最少**需要 $j$ 次交换能变为 $1$ ~ $i$ 的全排列的序列数。对于第 $i$ 个数，如果它等于 $i$，那么不需要对这个数进行交换操作，于是 $dp[i][j] \\leftarrow dp[i-1][j]$；否则，这个数原本的位置可能在 $1$ ~ ${i-1}$，此时有 $dp[i][j] \\leftarrow dp[i-1][j-1]*(i-1)$。设 $f[i][j]$ 表示长度为 $i$，需要恰好 $j$ 次交换能变为 $1$ ~ $i$ 的全排列的序列数，那么 $f[i][j] = dp[i][j]+dp[i][j-2]+dp[i][j-4]+...$。\n\n由于题目中交换次数最多 $k$ 次，因此最多有 $2k$ 个数位置发生变化。设位置变化的数的个数为 $i$，简单想一想答案应该为 $\\sum \\limits_{i=0}^{min(n,2k)} \\binom{n}{i}f[i][k]$。实际上，这样计算会有重复，因为根据前面的定义， $g[i][j]$ 没有保证交换后每个数不在它原来的位置。解决方法很简单，我们只需要对每个 $g[i][j]$ 容斥一下，再用容斥后的结果重新计算即可。\n\n时间复杂度 $O(n^3)$。（代码中的做法是 $O(n^4)$的，把 Comb2 预处理下就是 $O(n^3)$ 的了)\n## Code\n```cpp Baby Ehab Plays with Permutations\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define int long long\nusing namespace std;\n\nconst int MAXN = 205;\nconst int MOD = 1E9 + 7;\nint n, k;\nint dp[MAXN * 2][MAXN];  \nint g[MAXN * 2][MAXN];  \nint fac[MAXN * 2], inv[MAXN * 2];\n\nint qpow(int a, int b, int MOD) {\n    int ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nint Comb1(int n, int m) { return fac[n] * inv[m] % MOD * inv[n - m] % MOD; }\n\nint Comb2(int n, int m) {\n    int num = 1, den = 1;\n    for (int i = n - m + 1; i <= n; i++) num = num * i % MOD;\n    for (int i = 1; i <= m; i++) den = den * i % MOD;\n    return num * qpow(den, MOD - 2, MOD) % MOD;\n}\n\nvoid init(int k) {\n    fac[0] = inv[0] = 1;\n    for (int i = 1; i <= k; i++)\n        fac[i] = fac[i - 1] * i % MOD, inv[i] = qpow(fac[i], MOD - 2, MOD);\n}\n\nsigned main() {\n    cin >> n >> k;\n    init(2 * k);\n    for (int i = 0; i <= min(n, 2 * k); i++) dp[i][0] = 1;\n    for (int i = 1; i <= min(n, 2 * k); i++)\n        for (int j = 1; j <= k; j++)\n            dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1] * (i - 1) % MOD) % MOD;\n\n    for (int i = 0; i <= min(n, 2 * k); i++)\n        for (int j = 0; j <= k; j++)\n            for (int f = 0; f <= i; f++) {\n                g[i][j] += Comb1(i, f) * dp[i - f][j] * (f % 2 ? -1 : 1) % MOD;\n                g[i][j] %= MOD;\n            }\n\n    for (int x = 1; x <= k; x++) {\n        int ans = 0;\n        for (int i = 0; i <= min(n, 2 * x); i++)\n            for (int f = x; f >= 0; f -= 2) {\n                ans += Comb2(n, i) * g[i][f] % MOD;\n                ans %= MOD;\n            }\n        cout << (ans + MOD) % MOD << ' ';\n    }\n    return 0;\n}\n```\n","tags":["contest"],"categories":["contest"]},{"title":"Codeforces Round 716 Div2","url":"/2021/04/30/cf-716-div2/","content":"[比赛链接](https://codeforces.com/contest/1514)\n<!-- more -->\n\n# A - Perfectly Imperfect Array\n## Description\n[题目链接](https://codeforces.com/contest/1514/problem/A)\n## Solution\n只要一个数是非完全平方数答案就是 YES。\n## Code\n```cpp Perfectly Imperfect Array\nvoid solve(int caseNum) {\n    cin >> n;\n    bool tag = 0;\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        int tmp = sqrt(x);\n        if (tmp * tmp != x) tag = 1;\n    }\n    cout << (tag ? \"YES\" : \"NO\") << endl;\n}\n```\n\n# B - AND 0, Sum Big\n## Description\n[题目链接](https://codeforces.com/contest/1514/problem/B)\n## Solution\n要使和最大，只需要满足对于任意 $i∈[1,k]$，有且仅有 $1$ 个数第 $i$ 位为 $0$。对于每一位，我们选择一个数使它在这一位为0，其余数在这一位为 $1$，有 $n$ 种选法，一共 $k$ 位，故答案为 $n^k$。\n## Code\n```cpp AND 0, Sum Big\n#include <bits/stdc++.h>\n \n#define debug(x) cerr << #x << \" = \" << x << endl\n \nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, k;\n \nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nvoid solve(int caseNum) {\n    cin >> n >> k;\n    cout << qpow(n, k,MOD) << endl;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> testCase;\n    for (int i = 1; i <= testCase; i++) solve(i);\n    return 0;\n}\n```\n\n# C - Product 1 Modulo N\n## Description\n[题目链接](https://codeforces.com/contest/1514/problem/C)\n## Solution\n$[1,n-1]$ 与 $n$ 互质的数的乘积模 $n$ 结果要么是 $1$ 要么是 $n-1$。如果结果是 $n-1$，则只需要取 $[1,n-2]$ 与 $n$ 互质的数。\n## Code\n```cpp Product 1 Modulo N\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, T;\n\nsigned main() {\n    cin >> n;\n    vector<int> v;\n    LL pro = 1;\n    for (int i = 1; i <= n - 1; i++)\n        if (__gcd(i, n) == 1) v.push_back(i), pro = pro * i % n;\n    if (pro != 1) v.pop_back();\n    cout << v.size() << endl;\n    for (auto& val : v) cout << val << \" \";\n    return 0;\n}\n```\n\n# D - Cut and Stick\n## Description\n[题目链接](https://codeforces.com/contest/1514/problem/D)\n## Solution\n对于区间 $[l,r]$，设出现次数最多的数的出现次数为 $x$。\n\n- 若 $x \\le \\lceil \\frac{r-l+1}{2} \\rceil$，则只需要分 1 组。\n\n- 若 $x > \\lceil \\frac{r-l+1}{2} \\rceil$，显然其余 $(r-l+1)-x$ 个数的出现次数均严格小于 $\\lceil \\frac{r-l+1}{2} \\rceil$。我们只需要在出现次数最多的数中选出 $(r-l+1)-x+1$ 个分成一组，其余 $2x-(r-l+1) -1$ 个单独分组。这样一共分成 $2x-(r-l+1)$ 组。\n\n求区间出现次数最多的数的出现次数可以用莫队。参考这道题：[大爷的字符串题](https://www.luogu.com.cn/problem/P3709)\n## Code\n```cpp Cut and Stick\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int MAXN = 3e5 + 5;\nint n, m, sz, tot;\nint color[MAXN], belong[MAXN], ans[MAXN], cnt[MAXN], num[MAXN];\nvector<int> v;\n\ntemplate <class T>\nvoid read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct Query {\n    int l, r, id;\n    friend bool operator<(const Query& a, const Query& b) {\n        if (belong[a.l] == belong[b.l]) {\n            if (belong[a.l] & 1) return a.r < b.r;\n            return a.r > b.r;\n        }\n        return a.l < b.l;\n    }\n} q[MAXN];\n\nvoid Add(int x) {\n    num[cnt[x]]--;\n    cnt[x]++;\n    num[cnt[x]]++;\n    tot = max(tot, cnt[x]);\n}\n\nvoid Sub(int x) {\n    num[cnt[x]]--;\n    if (cnt[x] == tot && !num[cnt[x]]) tot--;\n    cnt[x]--;\n    num[cnt[x]]++;\n}\n\nint main() {\n    read(n), read(m);\n    sz = max(1, int(n / sqrt(m)));\n    for (int i = 1; i <= n; i++) {\n        read(color[i]);\n        belong[i] = i / sz;\n    }\n    for (int i = 1; i <= m; i++) {\n        read(q[i].l), read(q[i].r);\n        q[i].id = i;\n    }\n    sort(q + 1, q + m + 1);\n    int l = 0, r = 0;\n    num[0] = n;\n    for (int i = 1; i <= m; i++) {\n        while (l > q[i].l) Add(color[--l]);\n        while (r < q[i].r) Add(color[++r]);\n        while (l < q[i].l) Sub(color[l++]);\n        while (r > q[i].r) Sub(color[r--]);\n        ans[q[i].id] = max(1, 2 * tot - (q[i].r - q[i].l + 1));\n    }\n    for (int i = 1; i <= m; i++) printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n```\n","tags":["contest"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 197","url":"/2021/04/11/atcoder-abc-197/","content":"[比赛链接](https://atcoder.jp/contests/abc197)\n<!-- more -->\n# D Hanjo\n## Description\n[题目链接](https://atcoder.jp/contests/abc196/tasks/abc196_d)\n## Solution\n\n## Code\n```cpp Hanjo\n\n```\n\n时间复杂度为 $O(2^{\\sqrt{HW}}(HW)^3)$。\n## Code\n```cpp Hanjo\n\n```\n# E Traveler\n## Description\n\n## Solution\n\n## Code\n```cpp Traveler\nconstexpr int MAXN = 2e5 + 5, MOD = 1e9 + 7;\n#define int long long\n\nint n;\narray<long long, MAXN> x, c, l, r;\nlong long dp[MAXN][2];\n\nsigned main() {\n    boost;\n    cin >> n;\n    vector<int> vc;\n    memset(dp, 0x3f, sizeof(dp));\n    fill(l.begin(), l.end(), 2e9);\n    fill(r.begin(), r.end(), -2e9);\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> c[i];\n        l[c[i]] = min(l[c[i]], x[i]);\n        r[c[i]] = max(r[c[i]], x[i]);\n        vc.push_back(c[i]);\n    }\n    sort(vc.begin(), vc.end());\n    int cnt = unique(vc.begin(), vc.end()) - vc.begin();\n    for (int i = 0; i < cnt; i++) {\n        int co = vc[i], L = l[co], R = r[co], prePos = 0;\n        if (i == 0) {\n            if (R * L < 0) {\n                dp[0][0] = R * 2 - L; // stop at left\n                dp[0][1] = 2LL * (-L) + R;\n            } else {\n                if (R > 0) {\n                    dp[0][0] = 2LL * R - L;\n                    dp[0][1] = R;\n                } else {\n                    dp[0][0] = -L;\n                    dp[0][1] = 2LL * (-L) - R;\n                }\n            }\n        } else {\n            prePos = l[vc[i - 1]];\n            if ((R - prePos) * (L - prePos) < 0) {\n                dp[i][0] = min(dp[i][0], dp[i - 1][0] + (R - prePos) * 2 - (L - prePos));\n                dp[i][1] = min(dp[i][1], dp[i - 1][0] + 2LL * (-(L - prePos)) + (R - prePos));\n            } else {\n                if ((R - prePos) > 0) {\n                    dp[i][0] = min(dp[i][0], dp[i - 1][0] + 2LL * (R - prePos) - (L - prePos));\n                    dp[i][1] = min(dp[i][1], dp[i - 1][0] + R - prePos);\n                } else {\n                    dp[i][0] = min(dp[i][0], dp[i - 1][0] + (-(L - prePos)));\n                    dp[i][1] = min(dp[i][1], dp[i - 1][0] + 2LL * (-(L - prePos)) - (R - prePos));\n                }\n            }\n\n            prePos = r[vc[i - 1]];\n            if ((R - prePos) * (L - prePos) < 0) {\n                dp[i][0] = min(dp[i][0], dp[i - 1][1] + (R - prePos) * 2 - (L - prePos));\n                dp[i][1] = min(dp[i][1], dp[i - 1][1] + 2LL * (-(L - prePos)) + (R - prePos));\n            } else {\n                if ((R - prePos) > 0) {\n                    dp[i][0] = min(dp[i][0], dp[i - 1][1] + 2LL * (R - prePos) - (L - prePos));\n                    dp[i][1] = min(dp[i][1], dp[i - 1][1] + R - prePos);\n                } else {\n                    dp[i][0] = min(dp[i][0], dp[i - 1][1] + (-(L - prePos)));\n                    dp[i][1] = min(dp[i][1], dp[i - 1][1] + 2LL * (-(L - prePos)) - (R - prePos));\n                }\n            }\n        }\n    }\n    cout << min(dp[cnt - 1][0] + abs(l[vc.back()]), dp[cnt - 1][1] + abs(r[vc.back()]));\n    return 0;\n}\n```\n\n\n# F Construct a Palindrome\n## Description\n[题目链接](https://atcoder.jp/contests/abc197/tasks/abc197_f)\n## Solution\n\n## Code\n```cpp Construct a Palindrome\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 1e3 + 3, MOD = 1e9 + 7;\n\nint n, m, vis[MAXN][MAXN];\n\nvector<int> g[MAXN][26];\n\nstruct Node {\n    Node() = default;\n    Node(int _a, int _b, int _c) : v1(_a), v2(_b), dist(_c) {}\n\n    bool operator<(const Node& other) const {\n        return dist > other.dist;\n    }\n\n    int v1, v2, dist;\n};\n\nvoid dijkstra() {\n    priority_queue<Node> q;\n    for (int i = 1; i <= n; i++) {\n        q.push(Node(i, i, 0));\n        for (int c = 0; c < 26; c++)\n            for (auto& to : g[i][c])\n                q.push(Node(to, i, 1)), q.push(Node(i, to, 1));\n    }\n    while (!q.empty()) {\n        int x = q.top().v1, y = q.top().v2, dist = q.top().dist;\n        q.pop();\n        if (vis[x][y]) continue;\n        vis[x][y] = true;\n        if ((x == 1 && y == n) || (x == n && y == 1)) {\n            cout << dist << endl;\n            return;\n        }\n        for (int c = 0; c < 26; c++) {\n            for (auto& to1 : g[x][c]) {\n                for (auto& to2 : g[y][c]) {\n                    if (to1 != to2) {\n                        q.push(Node(to1, to2, dist + 2));\n                        q.push(Node(to2, to1, dist + 2));\n                    } else {\n                        q.push(Node(to1, to2, dist + 2));\n                    }\n                }\n            }\n        }\n    }\n    cout << -1 << endl;\n}\n\nint main() {\n    boost;\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        int u, v;\n        char c;\n        cin >> u >> v >> c;\n        g[u][c - 'a'].push_back(v);\n        g[v][c - 'a'].push_back(u);\n    }\n    dijkstra();\n    return 0;\n}\n```\n","tags":["contest"],"categories":["contest"]},{"title":"A*算法求解八数码问题","url":"/2021/04/09/8-digit-puzzle/","content":"# 八数码问题\n- 搜索/A*\n<!-- more -->\n\n# 实验说明\n使用 $A^*$ 算法求[八数码问题](https://vijos.org/p/1360)。给定初始局面和目标局面，动态演示求解方案。\n\n由于之前使用过 ``c++`` 求解八数码问题，本次实验采用的是 ``javascript`` 求解，并通过 ``html + css`` 进一步实现交互界面。效果如下:\n<center class=\"half\">\n    <img src=\"/images/8-digit-puzzle/1.png\" width=\"320\" height=\"180\"/>\n    <img src=\"/images/8-digit-puzzle/2.png\" width=\"320\" height=\"180\"/>\n    <img src=\"/images/8-digit-puzzle/3.png\" width=\"320\" height=\"180\"/>\n</center>\n\n# 算法分析\n求解八数码问题有很多方法，比如深度优先搜索、宽度优先搜索、一致代价搜索、双向搜索。其中深度优先搜索容易在较深的分支上停留很长时间，对于目标远离初始搜索分支的搜索树来说，效率是极低的; 宽度优先搜索对搜索树进行层次遍历，但是当子树极度不平很时，搜索效率也是相对较低的。\n\n总的来说，上述无差别的搜索是不太合理的，在进行搜索时很多情况下是在找不到解的路线上进行搜索。因此我们希望通过一些启发方法，能最大可能地在有最优解的路线上进行搜索，这就是 $A^*$ 算法所做的。\n\n在分析 $A^*$ 算法之前，先回顾以下优先队列 $BFS$ 算法。该算法维护了一个优先队列，不断从堆中取出**当前代价**最小的元素进行扩展。每个状态第一次从堆中取出时，就得到了从初态到该状态的最小代价。然而这样的策略不是完善的，当前搜索代价小可能会导致未来搜索花费更大的代价；当前搜索代价大，被扩展地晚，最终的代价可能更优。\n\n为了提高搜索效率，可以对未来可能产生的代价进行预估。在搜索时，仍然维护一个堆，不断从堆中取出**当前代价 + 未来估价**最小的状态进行扩展。\n\n在八数码问题中，当前代价即为空格已移动的次数。\n\n对于未来估价，由于**未来估价不能大于未来实际代价**，这里采用所有数字在当前状态 $state$ 中的位置与目标状态 $end$ 中的位置的曼哈顿距离之和，因为每次移动空格只会有一个数字位置改变，一个数字移动到目标状态的一定至少需要移动两位置的曼哈顿距离。即：\n$$f(state) = \\sum\\limits_{num=0}^{8}(|state_{x_{num}} - end_{x_{num}}| + |state_{y_{num}} - end_{y_{num}}|)$$\n\n\n# 算法设计实现\n根据上述分析可设计 ``javascript`` 估值函数：\n```js\nfunction evalute(curStep) {\n    let res = curStep;\n    let curx = new Array(9), cury = new Array(9);\n    let endx = new Array(9), endy = new Array(9);\n    for (let i = 0; i < 3; i++)\n        for (let j = 0; j < 3; j++) {\n            curx[array[i][j]] = i, cury[array[i][j]] = j;\n            endx[endArray[i][j]] = i, endy[endArray[i][j]] = j;\n        }\n    for (let i = 0; i < 9; i++) res += Math.abs(curx[i] - endx[i]) + Math.abs(cury[i] - endy[i]);\n    return res;\n}\n```\n\n为了保证 $A^*$ 算法的效率，每个状态只需要在第一次被取出时扩展一次。本题由于总共有9个格子，故可用每个状态可用 9 位数字进行简单表示(不舍弃前导零)。对于 ``c++``，可以将这些数字放在 `std::unordered_map<T, T>` 或 `std::map<T, T>` 中，在 ``javascript`` 中可以用其提供的 ``Map()`` 来存放键值对。当然还可以通过其它方法优化状态的记录，在后面的优化内容中会提到。\n\n**去重相关代码：**\n```js\nfunction _hash() { // 简单hash\n    let res = 0;\n    for (let i = 0; i < 3; i++)\n        for (let j = 0; j < 3; j++)\n            res = res * 10 + array[i][j];\n    return res;\n}\n\n//...\n\nif ((dis.get(nxtBoard.hashVal) == undefined) || dis[nxtBoard.hashVal] > dis[curBoard.hashVal] + 1) {\n    dis.set(nxtBoard.hashVal, dis.get(curBoard.hashVal) + 1);\n    pre.set(nxtBoard.hashVal, curBoard.hashVal);\n    q.queue(nxtBoard);\n}\n```\n\n在 $A^* $ 搜索函数中，我使用的是优先队列宽度优先搜索。由于本次实验重点在于 $A^*$ 算法与求解方案，故使用的是 `npm` 包中的优先队列，见[链接](https://www.npmjs.com/package/js-priority-queue)，入队出队的时间复杂度均为 $O(logn)$。\n\n**优先队列实例见下：**\n```js\nlet q = new PriorityQueue({ comparator: function(boarda, boardb) { return boarda.eval - boardb.eval; /*按估值从小到大排序*/}});\n```\n\n该优先队列中存放的是 ``Board`` 对象，对象包含九宫格状态`state`、估值 ``eval``、当前局面的哈希值 ``hashVal``，如下所示：\n```js\nfunction Board(array, curStep) {\n    this.state = copy(array); // 3 * 3状态\n    this.eval = evalute(curStep); // 估值 \n    this.hashVal = _hash(); //哈希值\n    // ...\n}\n```\n\n在进行搜索时，估值 ``eval`` 小的 ``Board`` 对象先出队，找到其九宫格状态 ``state`` 中空格的位置，对空格四个方向进行遍历得到合法的新的九宫格，通过 ``Map_dis`` 判断该状态(哈希值)是否访问过并记录该状态(哈希值)下已走的最小步数。此外，为了得到求解方案，还需一个 ``Map_pre`` 记录该状态(哈希值)的前一个状态(哈希值)。\n\n**$A^*$算法核心代码：**\n```js\nfunction aStar(sx, sy, solution) { // A*\n    let startBoard = new Board(startArray, 0);\n    let endBoard = new Board(endArray, 0);\n\n    let dx = [0, 1, 0, -1], dy = [1, 0, -1, 0];\n\n    let dis = new Map(), pre = new Map();\n    //https://www.npmjs.com/package/js-priority-queue\n    let q = new PriorityQueue({ comparator: function(boarda, boardb) { return boarda.eval - boardb.eval; }});\n    \n    q.queue(startBoard);\n    dis.set(startBoard.hashVal, 0);\n\n    while (q.length > 0) {\n        let curBoard = q.dequeue();\n        let curS = getSpacePos(curBoard); // 找到空格所在位置\n\n        if (curBoard.hashVal == endBoard.hashVal) { // 到达最终状态\n            getSolution(pre, endBoard.hashVal, solution); // 寻找路径\n            console.log(\"search Finished!\");\n            return dis.get(curBoard.hashVal);\n        }\n        \n        for (let dir = 0; dir < 4; dir++) { // 遍历 4 个方向\n            let nx = curS.x + dx[dir], ny = curS.y + dy[dir];\n            if (nx < 0 || nx > 2 || ny < 0 || ny > 2) continue;\n            curBoard.swap(curS.x, curS.y, nx, ny);\n\n            let nxtBoard = new Board(curBoard.state, dis.get(curBoard.hashVal));\n\n            if ((dis.get(nxtBoard.hashVal) == undefined) || dis[nxtBoard.hashVal] > dis[curBoard.hashVal] + 1) {\n                dis.set(nxtBoard.hashVal, dis.get(curBoard.hashVal) + 1);\n                pre.set(nxtBoard.hashVal, curBoard.hashVal);\n                q.queue(nxtBoard);\n            }\n\n            curBoard.swap(curS.x, curS.y, nx, ny);\n        }\n    }\n    console.log(\"search Finished!\");\n    return -1;\n}\n```\n\n当搜索到出队元素的状态(哈希值)等于目标状态（哈希值）时，表明已找到最优解，调用编写的 `getSolution` 函数得到路径，并返回最优解的步数。对于路径求法，简单地来讲就是从目标状态(哈希值)开始，不断求 ``Map_pre(hashVal)`` 值，并插入到可变长数组 ``Array`` 末尾。这样只要对比数组相邻两个元素之间空格位置的差异，就可以求出移动方案。\n```js\nfunction getSolution(pre, endHash, solution) {\n    let curHashVal = endHash;\n    while (curHashVal != undefined) {\n        let tmp = curHashVal.toString();\n        if (tmp.length != 9) tmp = \"0\" + tmp;\n        solution.push(tmp);\n        curHashVal = pre.get(curHashVal);\n    }\n}\n```\n\n当队列为空且仍未找到解时，返回 -1，之后再通过界面进一步交互。当然，未找到解的情况会耗费很多不必要的资源和时间，如果能在求解前能判断有没有解，能进一步提高程序效率，这也将在后面优化部分介绍。\n\n上述算法得到的 ``javascript`` 程序和已有标准 ``c++`` 程序对拍无误，能够在毫秒时间内求解。当然依旧有优化的空间，将在后面优化部分介绍。\n\n\n# 界面设计与结果演示\n## 1.界面设计\n<center class=\"half\">\n    <img src=\"/images/8-digit-puzzle/4.png\" width=\"600\" height=\"300\"/>\n</center>\n\n九宫格如上图所示，分为起始状态九宫格和目标状态九宫格。每个九宫格分为背景和 9 个 ``input`` 格子，9 个格子分为 3 行，并赋予 ``id``。通过 ``css`` 实现三行对齐排列并进行美化。\n\n起始状态九宫格中的数字需要自己输入，目标状态的九宫格中填充了默认八数码问题目标状态，当然也可以自己进行修改。输入的数码不要求正确，因为在进行求解前会判断不合法的输入，并通过 ``window.alert()`` 提示错误信息。\n\n**九宫格 html 代码：**\n```html\n<div class=\"center board\"> <!--起始状态九宫格-->\n    <div id=\"srow1\" class=\"input-row1\">\n        <input type=\"text\" id=\"s1\">\n        <input type=\"text\" id=\"s2\">\n        <input type=\"text\" id=\"s3\"><br>\n    </div>\n    <div id=\"srow2\">\n        <input type=\"text\" id=\"s4\">\n        <input type=\"text\" id=\"s5\">\n        <input type=\"text\" id=\"s6\"><br>\n    </div>\n    <div id=\"srow3\">\n        <input type=\"text\" id=\"s7\">\n        <input type=\"text\" id=\"s8\">\n        <input type=\"text\" id=\"s9\"><br>\n    </div>\n</div>\n```\n\n除此之外，还设置了 4 个交互按钮如下：\n```html\n<div class=\"center button-wrapper\">\n    <button id=\"inputs-button\">清空初态</button>\n    <button id=\"inpute-button\">清空末态</button>\n    <button id=\"calc-button\">求解</button>\n    <button id=\"reset-button\">重置</button>\n</div>\n```\n其中清空初始状态、清空末状态按钮以及重置按钮便于重新设定数码。前两个清空按钮在求解演示时不能使用，重置按钮在求解演示时选择性重置，以便立即结束求解演示重新布置数码。如下图所示：\n<center class=\"half\">\n    <img src=\"/images/8-digit-puzzle/5.png\" width=\"320\" height=\"180\"/>\n    <img src=\"/images/8-digit-puzzle/6.png\" width=\"320\" height=\"180\"/>\n</center>\n\n对于求解按钮，点击后会先调用判断函数判断输入是否合法，然后进行初始化操作，求出方案，再调用演示函数进行结果演示。\n<center class=\"half\">\n    <img src=\"/images/8-digit-puzzle/9.png\" width=\"320\" height=\"180\"/>\n</center>\n\n此外，在界面右端还有一个显示剩余步数的文本，随演示进行而变化。\n```html\n<p class=\"step-paragraph\">距离最终状态还需 <p1 class=\"step-num\" id=\"step-num\">?</p1> 步</p>\n```\n\n求解成功和失败界面：\n<center class=\"half\">\n    <img src=\"/images/8-digit-puzzle/5.png\" width=\"320\" height=\"180\"/>\n    <img src=\"/images/8-digit-puzzle/6.png\" width=\"320\" height=\"180\"/>\n</center>\n\n## 2.结果演示\n在第一部分算法设计中已提到，求解得到的路径已存放在可变长数组中。接下来就只需从后往前找到数组相邻两个元素的空格的位置。由于已设定好九宫格每个格子的 ``id`` 以及所在的行的 ``id``，所以通过空格的位置可以很方便地求得其所对应的 ``html`` 节点。\n\n最后，通过 ``javascript`` 对 ``DOM`` 的一系列操作和计时事件即可在前端显示出空格每隔一段时间移动的效果。\n\n```js\nasync function displaySolution(solution) { // 演示最短路径\n    document.getElementById(\"step-num\").innerHTML = solution.length - 1;\n    if (solution.length <= 1) {\n        running = false;\n        setTimeout(() => {\n            successMsg(\"求解完成!\");\n        }, 1000);\n        return;\n    }\n    (function myLoop(i) { // 循环递归函数\n        setTimeout(() => {\n            document.getElementById(\"step-num\").innerHTML = i - 1;\n            let id1 = \"s\" + (solution[i].indexOf(\"0\") + 1);\n            let id2 = \"s\" + (solution[i - 1].indexOf(\"0\") + 1);\n\n            let node1 = document.getElementById(id1);\n            let node2 = document.getElementById(id2);\n\n            let new1 = document.createElement(\"input\");\n            new1.type = \"text\";\n            new1.id = id1;\n            new1.value = node2.value;\n\n            let new2 = document.createElement(\"input\");\n            new2.type = \"text\";\n            new2.id = id2;\n            new2.value = node1.value;\n            new2.style.cssText = node1.style.cssText;\n                \n            let faId1 = \"srow\" + (Math.floor(solution[i].indexOf(\"0\") / 3) + 1);\n            let faId2 = \"srow\" + (Math.floor(solution[i - 1].indexOf(\"0\") / 3) + 1);\n\n            document.getElementById(faId1).replaceChild(new1, node1);\n            document.getElementById(faId2).replaceChild(new2, node2);\n\n            if ((--i) >= 1) myLoop(i);\n            else {\n                running = false;\n                setTimeout(() => {\n                    successMsg(\"求解完成!\");\n                }, 1000);\n            }\n        }, 1000);\n    })(solution.length - 1);\n}\n```\n\n# 算法优化\n## 1. 无解判断\n前面提到如果在 $A^*$ 算法搜索过程中，如果优先队列为空时仍然未找达到最终状态，则无解。但这会遍历所有可能的状态直至队列为空，空间与时间的消耗较大。如果在求解前进行判断，将会提高无解情况下的效率。\n八数码两个局面可达，当且仅当局面下网格中的数依次写成 1 行 $n^2 - 1$ 个元素时，逆序对个数的奇偶性相同。该性质的必要性很容易证明：空格左右移动时，写成的序列显然不变；空格上(下)移动时，相当于某个数与它后(前)的 2 个数交换位置，逆序对数变化是偶数。充分性证明较复杂，就不在此大篇幅讨论这样的一个数学问题。\n\n## 2. 康托展开\n前面使用的是 ``Map()`` 存储简单哈希值，效率偏低。但如果使用康托展开，则可以对全排列进行编码和解码，把 1~N 的前排列与 1~N! 之间的整数建立一一映射关系。这样就可以 $O(1)$ 时间得到一个状态的信息。\n\n## 3. IDA*\n$A^* $ 算法有一个显而易见的缺点，就是需要维护一个优先队列来存储状态以及估价，耗费空间较大，并且对优先队列进行依次操作也要花费 $O(logn)$ 的时间。$IDA^* $ 以迭代加深 $DFS$ 的搜索框架为基础，即限定一个深度，在不超过该深度的前提下执行 $DFS$，并把原来的简单的深度限制加强为：**若当前深度 + 未来估计步数 > 深度限制，则立即从当前分支回溯**。若找不到解，则扩大搜索深度，重新进行搜索。\n事实证明 $IDA^* $ 效率要优于 $A^* $，且程序实现难度低于 $A^*$。\n\n# 使用说明\n双击打开 index.html 文件即可(建议使用 Chrome、FireFox 等浏览器)，在输入起始状态和目标状态后点击**求解**按钮即可进行求解并演示方案。\n[项目github地址](https://github.com/Shaun-Shane/AStar)。\n","tags":["A*算法"],"categories":["搜索","A*"]},{"title":"轮廓线 DP 入门","url":"/2021/04/02/Borderline-DP/","content":"#\n<!-- more -->\n \n# A Hanjo\n[题目链接](https://atcoder.jp/contests/abc196/tasks/abc196_d)\n## Description\n求用 $A$ 个 $2*1$，$B$ 个 $1*1$ 的方块填满 $H*W$ 的方格的方案数。 \n## Solution\n见博客 [AtCoder Beginner Contest 196](https://shaun-shane.vercel.app/2021/03/26/atcoder-abc-196/#bonus)。\n\n# B Tiling Dominoes\n[题目链接](https://www.luogu.com.cn/problem/UVA11270)\n## Desciption \n求用 $2*1$ 的方块填满 $H*W$ 的方格的方案数。\n## Solution\n上一题的弱化版本。由于方块数目没有限制，故只需要设 $dp[i][s]$ 表示考虑前 $i$ 个方格，从这个方格开始前 $W$ 个方格填充状态为 $s$，除了这些方格外其余方格全部被填满的方案数。现在考虑第 $i+1$ 个方格，根据 $s'$，$s_u$ 和 $s_l$（和上一题题解中的定义一致），有如下转移：\n\n- $s_u = 0$，则必须竖着放一个 $2*1$ 的方块，于是有：\n$$dp[i+1][s'|1][a+1][b] \\leftarrow dp[i][s][a][b]$$\n- $s_l s_u = 01$，则可以横着放一个 $2*1$ 的方块，或者不放，从而：\n$$\n\\begin{aligned}\ndp[i+1][s'|3][a+1][b] \\leftarrow dp[i][s][a][b] \\\\\ndp[i+1][s'][a][b] \\leftarrow dp[i][s][a][b]     \\\\\n \\end{aligned}\n$$\n\n- $s_l s_u = 11$，只能不放，故有：\n$$\n\\begin{aligned}\ndp[i+1][s'][a][b] \\leftarrow dp[i][s][a][b]     \\\\\n \\end{aligned}\n$$\n\n最后答案为 $dp[H*W][(1<<W)-1]$。\n\n类似题目：[HDU1400 Mondriaan's Dream](http://acm.hdu.edu.cn/showproblem.php?pid=1400)\n## Code\n```cpp Tiling Dominoes\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nint H, W, T;\n\nvoid add(LL& a, LL b) { a = a + b; }\n\nsigned main() {\n    while (cin >> H >> W) {\n        if (W > H) swap(H, W);\n        LL dp[2][1 << W];\n        memset(dp, 0, sizeof(dp));\n        dp[0][(1 << W) - 1] = 1;\n        bool tag = 0;\n        for (int i = 1; i <= H; i++)\n            for (int j = 1; j <= W; j++) {\n                tag ^= 1;\n                memset(dp[tag], 0, sizeof(dp[tag]));\n                for (int s = 0; s < (1 << W); s++) {\n                    int nxtS = ((s << 1) & ((1 << W) - 1));\n                    int sUp = (s >> (W - 1)) | (i == 1);\n                    int sLeft = (s & 1) | (j == 1);\n                    if (!sUp)\n                        add(dp[tag][nxtS | 1], dp[tag ^ 1][s]);\n                    else if (!sLeft) {\n                        add(dp[tag][nxtS | 3], dp[tag ^ 1][s]);\n                        add(dp[tag][nxtS], dp[tag ^ 1][s]);\n                    } else\n                        add(dp[tag][nxtS], dp[tag ^ 1][s]);\n                }\n            }\n        cout << dp[tag][(1 << W) - 1] << endl;\n    }\n    return 0;\n}\n```\n\n# C Campus Design\n## Desciption \n[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=4804)\n## Solution\n限制了 $1*1$ 的方块的使用次数，同时有一些方格已被占用。虽然增加了一些约束，但解法和第一题基本相同，不再赘述。\n## Code\n```cpp Campus Design\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\n\nconst int MOD = 1E9 + 7;\nint H, W, C, D;\n\nvoid add(int& a, int b) { a = (a + b) % MOD; }\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    while (cin >> H >> W >> C >> D) {\n        int dp[2][1 << W][D + 1];\n        char c[H + 1][W + 1];\n        for (int i = 1; i <= H; i++)\n            for (int j = 1; j <= W; j++) cin >> c[i][j];\n        memset(dp, 0, sizeof(dp));\n        dp[0][(1 << W) - 1][0] = 1;\n        bool tag = 0;\n        for (int i = 1; i <= H; i++)\n            for (int j = 1; j <= W; j++) {\n                tag ^= 1;\n                memset(dp[tag], 0, sizeof(dp[tag]));\n                for (int s = 0; s < (1 << W); s++)\n                    for (int b = 0; b <= D; b++) {\n                        int nxtS = ((s << 1) & ((1 << W) - 1));\n                        int sUp = (s >> (W - 1)) | (i == 1);\n                        int sLeft = (s & 1) | (j == 1);\n                        if (!sUp) {\n                            if (c[i][j] == '1')\n                                add(dp[tag][nxtS | 1][b], dp[tag ^ 1][s][b]);\n                        } else if (!sLeft) {\n                            if (c[i][j] == '1') {\n                                add(dp[tag][nxtS | 3][b], dp[tag ^ 1][s][b]);\n                                if (b)\n                                    add(dp[tag][nxtS | 1][b],\n                                        dp[tag ^ 1][s][b - 1]);\n                            }\n                            add(dp[tag][nxtS | (c[i][j] == '0')][b],\n                                dp[tag ^ 1][s][b]);\n                        } else {\n                            if (b && c[i][j] == '1')\n                                add(dp[tag][nxtS | 1][b],\n                                    dp[tag ^ 1][s][b - 1]);\n                            add(dp[tag][nxtS | (c[i][j] == '0')][b],\n                                dp[tag ^ 1][s][b]);\n                        }\n                    }\n            }\n        int ans = 0;\n        for (int i = C; i <= D; i++) add(ans, dp[tag][(1 << W) - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n\n# D Hanjo 2\n## Desciption \n[题目链接](https://atcoder.jp/contests/abc204/tasks/abc204_f)\n## Solution\n参考 $A$ 题的做法，容易想到 $O(2^HHW)$ 的 $DP$，我们只需要根据前 $H$ 个砖块的占用情况进行状态转移，但这样不好优化，因为有换行的情况。\n\n如果我们每次都考虑一行的状态，设上一行状态 $S$，当前行状态 $T$，那么有 $dp[i][T] \\leftarrow C(T,S) * dp[i-1][S]$，其中 $C$ 是一个转移矩阵。当 $T,S$ 确定，$C(T,S)$ 也就确定了，我们可以 $O(4^H)$ 枚举 $S,T$ 来求解 $C$（为了避免重复，我们规定上一行没有被填充的部分只能用一个竖着的 2*1 的砖块填充）。求出 $C$ 后便可用矩阵快速幂在 $O(8^HlogW)$ 时间内求得 $dp[W]$。\n## Code\n```cpp Hanjo 2\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 998244353;\nint H, N;\nint f[7] = {1, 1, 2, 3, 5, 8, 13};\nLL W;\n\nstruct matrix {\n    int r, c;\n    LL m[66][66];\n\n    matrix(int a, int b) {\n        r = a, c = b;\n        for (int i = 0; i < r; i++)\n            for (int j = 0; j < c; j++) m[i][j] = 0;\n    }\n\n    LL *operator[](int i) { return m[i]; }\n    friend matrix operator*(matrix &a, matrix &b) {\n        matrix d(a.r, b.c);\n        for (int i = 0; i < a.r; i++)\n            for (int j = 0; j < b.c; j++)\n                for (int k = 0; k < a.c; k++)\n                    d[i][j] = (d[i][j] + a[i][k] * b[k][j] % MOD) % MOD;\n        return d;\n    }\n};\n\nmatrix qpow(matrix A, LL b) {\n    matrix ans(N, N);\n    for (int i = 0; i < N; i++) ans[i][i] = 1;\n    matrix base = A;\n    while (b) {\n        if (b & 1) ans = ans * base;\n        base = base * base, b >>= 1;\n    }\n    return ans;\n}\n\nsigned main() {\n    cin >> H >> W;\n    N = (1 << H);\n    matrix s0(N, 1);\n    s0[N - 1][0] = 1;\n    matrix trans(N, N);\n    for (int t = 0; t < N; t++) {      // new state\n        for (int s = 0; s < N; s++) {  // old state\n            int len = 0, tmp = 1;\n            bool ok = 1;\n            for (int i = 0, a, b; i < H; i++) {\n                a = (t >> i) & 1;\n                b = (s >> i) & 1;\n                if (!a && !b) {\n                    ok = 0;\n                    break;\n                } else if (a && b) {\n                    len++;\n                    if (i == H - 1) tmp *= f[len];\n                } else {\n                    tmp *= f[len];\n                    len = 0;\n                }\n            }\n            if (ok) trans[t][s] = tmp % MOD;\n        }\n    }\n    matrix tmp = qpow(trans, W);\n    matrix res = tmp * s0;\n    cout << res[N - 1][0] % MOD;\n    return 0;\n}\n```\n","tags":["动态规划","状压DP","轮廓线DP","矩阵快速幂"],"categories":["动态规划","状压DP","轮廓线DP"]},{"title":"AtCoder Beginner Contest 196","url":"/2021/03/26/atcoder-abc-196/","content":"[比赛链接](https://atcoder.jp/contests/abc196)\n<!-- more -->\n# D Hanjo\n## Description\n[题目链接](https://atcoder.jp/contests/abc196/tasks/abc196_d)\n## Solution\n由于数据规模很小，可以直接暴搜，搜索的时候记录每一层的状态，当这一层都被填满时才搜下一层。具体的，对于第 $i$ 行第 $j$ 列，可以放一个 $1*1$ 的，也可以横着向右放一个 $2*1$ 的，或者竖着向下放一个 $2*1$ 的。时间复杂度大概是 $O(HW2^A\\binom{HW}A)$ 吧。\n## Code\n```cpp Hanjo\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); \\\nstringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\n\nvoid err(istream_iterator<string> it) { cout << endl; }\n\ntemplate <typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << \" \";\n    err(++it, args...);\n}\n\nconstexpr int MAXN = 1e5 + 5, MOD = 1e9 + 7;\n\nint h, w, a, b, ans;\nint st[16];\n\nvoid Search(int r, int c, int a, int b) {\n    if (a < 0 || b < 0) return;\n    if (r == h) {\n        if (a || b) return;\n        for (int i = 0; i < h; i++)\n            if (st[i] != (1 << w) - 1) return;\n        ans++;\n        return;\n    }\n    if (st[r] == (1 << w) - 1) {\n        Search(r + 1, 0, a, b);\n        return;\n    }\n    if (c < w && (st[r] >> c) & 1) Search(r, c + 1, a, b);\n\n    if (b > 0) {\n        int pre = st[r];\n        st[r] |= (1 << c);\n        Search(r, c + 1, a, b - 1);\n        st[r] = pre;\n    }\n\n    if (a > 0 && c < w - 1 && !((st[r] >> (c + 1)) & 1)) {\n        int pre = st[r];\n        st[r] |= (1 << c);\n        st[r] |= (1 << (c + 1));\n        Search(r, c + 2, a - 1, b);\n        st[r] = pre;\n    }\n\n    if (a > 0 && r != h - 1 && !((st[r + 1] >> c) & 1)) {\n        int pre1 = st[r], pre2 = st[r + 1];\n        st[r] |= (1 << c);\n        st[r + 1] |= (1 << c);\n        Search(r, c + 1, a - 1, b);\n        st[r] = pre1;\n        st[r + 1] = pre2;\n    }\n}\n\nsigned main() {\n    boost;\n    cin >> h >> w >> a >> b;\n    Search(0, 0, a, b);\n    cout << ans << endl;\n    return 0;\n}\n```\n\n## Bonus\n将题目中 $HW \\le 16$ 改为 $HW \\le 140$（题解中提到 $HW$ 可以到 $200$，但我暂时没想到进一步优化的方法）。\n\n## Solution\n使用轮廓线 $DP$。不妨设 $H \\ge \\ W$，将格子按 $i*W+j$ 编号。设 $dp[i][s][a][b]$ 表示考虑前 $i$ 个方格，从这个方格开始前 $W$ 个方格填充状态为 $s$，除了这些方格外其余方格全部被填满，一共用了 $a$ 个 $2*1$ 的方块和 $b$ 个 $1*1$ 的方块的方案数。现在考虑第 $i+1$ 个方格，我们很容易根据 $s$ 获取其上方的方格和左边的方格的填充状态 $s_u$ 和 $s_l$，同时获取从方格 $i+1$ 开始前 $W$ 个方格填充状态，记为 $s'$。根据 $s_u$ 和 $s_l$ 的取值，有如下转移：\n\n- $s_u = 0$，则必须竖着放一个 $2*1$ 的方块，于是有：\n$$dp[i+1][s'|1][a+1][b] \\leftarrow dp[i][s][a][b]$$\n- $s_l s_u = 01$，则可以横着放一个 $2*1$ 的方块，或者放一个 $1*1$ 的方块，或者不放，从而：\n$$\n\\begin{aligned}\ndp[i+1][s'|3][a+1][b] \\leftarrow dp[i][s][a][b] \\\\\ndp[i+1][s'|1][a][b+1] \\leftarrow dp[i][s][a][b] \\\\\ndp[i+1][s'][a][b] \\leftarrow dp[i][s][a][b]     \\\\\n \\end{aligned}\n$$\n\n- $s_l s_u = 11$，则可以放一个 $1*1$ 的方块，也可以不放，故有：\n$$\n\\begin{aligned}\ndp[i+1][s'|1][a][b+1] \\leftarrow dp[i][s][a][b] \\\\\ndp[i+1][s'][a][b] \\leftarrow dp[i][s][a][b]     \\\\\n \\end{aligned}\n$$\n\n最后答案为 $dp[H*W][(1<<W)-1][A][B]$。\n\n注意：\n\n- $dp$ 数组第一维可以用滚动数组滚掉，从而减少空间开销。\n\n- 为了简便，我们规定第 $0$ 行和第 $0$ 列全部被填满。\n\n- 为了避免重复计算，要严格定义方块放置的方向和位置。\n\n时间复杂度为 $O(2^{min(H,W)}(HW)^3)$。\n## Code\n```cpp Hanjo\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MOD = 1E9 + 7;\nint H, W, A, B;\n\nvoid add(int& a, int b) { a = (a + b) % MOD; }\n\nsigned main() {\n    cin >> H >> W >> A >> B;\n    if (W > H) swap(H, W);\n    int dp[2][1 << W][A + 1][B + 1];\n    memset(dp, 0, sizeof(dp));\n    dp[0][(1 << W) - 1][0][0] = 1;\n    bool tag = 0;\n    for (int i = 1; i <= H; i++)\n        for (int j = 1; j <= W; j++) {\n            tag ^= 1;\n            memset(dp[tag], 0, sizeof(dp[tag]));\n            for (int s = 0; s < (1 << W); s++)\n                for (int a = 0; a <= A; a++)\n                    for (int b = 0; b <= B; b++) {\n                        int nxtS = ((s << 1) & ((1 << W) - 1));\n                        int sUp = (s >> (W - 1)) | (i == 1);\n                        int sLeft = (s & 1) | (j == 1);\n                        if (!sUp) {\n                            if (a)\n                                add(dp[tag][nxtS | 1][a][b],\n                                    dp[tag ^ 1][s][a - 1][b]);\n                        } else if (!sLeft) {\n                            if (a)\n                                add(dp[tag][nxtS | 3][a][b],\n                                    dp[tag ^ 1][s][a - 1][b]);\n                            if (b)\n                                add(dp[tag][nxtS | 1][a][b],\n                                    dp[tag ^ 1][s][a][b - 1]);\n                            add(dp[tag][nxtS][a][b], dp[tag ^ 1][s][a][b]);\n                        } else {\n                            if (b)\n                                add(dp[tag][nxtS | 1][a][b],\n                                    dp[tag ^ 1][s][a][b - 1]);\n                            add(dp[tag][nxtS][a][b], dp[tag ^ 1][s][a][b]);\n                        }\n                    }\n        }\n    cout << dp[tag][(1 << W) - 1][A][B];\n    return 0;\n}\n```\n# E Filters\n## Description\n[题目链接](https://atcoder.jp/contests/abc196/tasks/abc196_e)\n## Solution\n记 $F(x) = f_n(...f_2(f_1(x))...)$，猜想 $F(x)$ 可以表示成 $min(p,max(q,x+r))$，接下来进行证明：\n\n- $f(x)$ 可以表示成 $min(p_1,max(q_1,x+r_1))$，具体如下：\n    \n    - $t_i = 1$，则 $f(x) = min(+\\infty,max(-\\infty,x+a_i))$。\n    - $t_i = 2$，则 $f(x) = min(+\\infty,max(a_i,x+0))$。\n    - $t_i = 3$，则 $f(x) = min(a_i,max(-\\infty,x+0))$。\n    \n- 设 $g(x) = min(p_2,max(q_2,x+r_2))$，则有：\n    $$\n    \\begin{aligned}\n    g(f(x)) &= \\min(p_2, \\max(q_2, \\min(p_1, \\max(q_1, x + r_1)) + r_2))\\\\\n    &= \\min(p_2, \\max(q_2, \\min(p_1 + r_2, \\max(q_1 + r_2, x + r_1 + r_2))))\\\\\n    &= \\min(\\min(p_2, \\max(q_2, p_1 + r_2)), \\max(\\max(q_2, \\min(p_1 + r_2, q_1 + r_2)), x + (r_1 + r_2))),\\\\\n    \\end{aligned}\n    $$\n\n设 $f_0(x) = x$，按照上面的式子做 $n$ 次复合运算即可得到 $F(x)$，之后便可 $O(1)$ 实现单次查询。\n## Code\n```cpp Filters\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst LL INF = 1E15;\nint n, q;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    LL c = INF, b = -INF, a = 0;\n    LL c2, b2, a2;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        LL v, t;\n        cin >> v >> t;\n        switch (t) {\n            case 1:\n                c2 = INF, b2 = -INF, a2 = v;\n                break;\n            case 2:\n                c2 = INF, b2 = v, a2 = 0;\n                break;\n            case 3:\n                c2 = v, b2 = -INF, a2 = 0;\n                break;\n            default:\n                break;\n        }\n        b = max(b2, min(c + a2, b + a2));\n        c = min(c2, max(b2, c + a2));\n        a = a + a2;\n    }\n    cin >> q;\n    for (int i = 1; i <= q; i++) {\n        LL x;\n        cin >> x;\n        cout << min(c, max(b, x + a)) << endl;\n    }\n    return 0;\n}\n```\n\n\n# F Substring 2\n## Description\n[题目链接](https://atcoder.jp/contests/abc196/tasks/abc196_f)\n## Solution\n$FFT$ 处理子串匹配板子题，只需要对 $0$ 和 $1$ 分别求匹配数。记 $m[i][0/1]$ 表示 $S_{i...i+|T|-1}$ 与 $T_{0...|T|-1}$ 中字符 $0/1$ 的匹配次数，那么有 $m[i][0/1] = \\sum \\limits_{k=0}^{|T|-1} (S[i+k]==0/1)(T[k]==0/1)$，把 $T$ 翻转后求卷积即可，一共需要 $4/6$ 次 $dft$。最后答案为 $\\max \\limits_{0 \\le i \\le |S|-|T|} {|T|-m[i][0]-m[i][1]}$。\n\n另外，我们也可以直接对每个起始位置 $i$ 求未匹配数 (同样需要将 $T$ 翻转)，即 $\\sum \\limits_{k=0}^{|T|-1} (S[i+k]-T[T.size()-k-1])^2$。把平方打开后求一次卷积以及两次平方和即可，这样只需要 $2/3$ 次 $dft$。\n## Code\n```cpp Substring 2\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst double PI = acos(-1.0);\n\nstruct Complex {\n    double x, y;\n    Complex(double _x = .0, double _y = .0) : x(_x), y(_y) {}\n    Complex operator*(Complex other) {\n        return Complex(x * other.x - y * other.y, x * other.y + y * other.x);\n    }\n    Complex operator+(Complex other) {\n        return Complex(x + other.x, y + other.y);\n    }\n    Complex operator-(Complex other) {\n        return Complex(x - other.x, y - other.y);\n    }\n};\n\nvoid expand(int &sz) {\n    if (__builtin_popcount(sz) != 1) sz = 1 << (1 + (int)log2(sz));\n}\n\nint rev(int x, int sz) {\n    int ans = 0;\n    for (int i = 0; i < sz; i++)\n        if ((x >> i) & 1) ans |= (1 << (sz - i - 1));\n    return ans;\n}\n\nint R[4000001];\nvoid dft(Complex a[], int sz, int type) {\n    for (int i = 0; i < sz; i++)\n        if (i < R[i]) swap(a[i], a[R[i]]);\n    for (int m = 2; m <= sz; m <<= 1) {\n        Complex wm(cos(2 * PI / m), type * sin(2 * PI / m));\n        for (int k = 0; k < sz; k += m) {\n            Complex w(1);\n            for (int j = 0; j < m / 2; j++) {\n                Complex t = w * a[k + j + m / 2];\n                Complex u = a[k + j];\n                a[k + j] = u + t;\n                a[k + j + m / 2] = u - t;\n                w = w * wm;\n            }\n        }\n    }\n}\n\nint main() {\n    char c[] = {'0', '1'};\n    string s, t;\n    cin >> s >> t;\n    int n = s.size(), m = t.size();\n    int N = n;\n    expand(N);\n    Complex a[N];\n    for (int i = 0; i < N; i++) R[i] = rev(i, log2(N));\n    int matched[n] = {0};\n    for (int type = 0; type < 2; type++) {\n        int f[n] = {0};\n        for (int i = 0; i < m; i++) a[i].x = (t[i] == c[type]);\n        for (int i = 0; i < n; i++)\n            if (s[i] == c[type]) f[i] = 1;\n        for (int i = 0; i < n; i++) a[i].y = f[n - i - 1];\n        dft(a, N, 1);\n        for (int i = 0; i < N; i++) a[i] = a[i] * a[i];\n        dft(a, N, -1);\n        for (int i = 0; i < n - m + 1; i++)\n            matched[i] += int(a[i + m - 1].y / 2.0 / N + 0.5);\n        for (int i = 0; i < N; i++) a[i].x = a[i].y = 0;\n    }\n    int ans = 1E9;\n    for (int i = 0; i < n - m + 1; i++) ans = min(ans, m - matched[i]);\n    cout << ans << endl;\n    return 0;\n}\n```\n\n```cpp 做法2\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e6 + 5, MOD = 1e9 + 7;\n\nnamespace NTT {\n    constexpr int NR = 1 << 22, g = 3, gi = 332748118, mod = 998244353;\n\n    long long qpow(long long a, long long b) {\n        long long res = 1;\n        while (b) {\n            if (b & 1) res = res * a % mod;\n            a = a * a % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    int R[4000001];\n    void init(int& sz) {\n        if (__builtin_popcount(sz) != 1) sz = 1 << (1 + (int)log2(sz));\n        for (int i = 0; i < sz; i++) R[i] = (R[i >> 1] >> 1) | ((i & 1) ? (sz >> 1) : 0);\n    }\n\n    void dft(long long a[], int sz, int type) {\n        for (int i = 0; i < sz; i++)\n            if (i < R[i]) swap(a[i], a[R[i]]);\n        for (int m = 2; m <= sz; m <<= 1) {\n            long long gn = qpow(type == 1 ? g : gi, (mod - 1) / m); // 单位原根 g_n\n            for (int k = 0; k < sz; k += m) {\n                long long g0(1);\n                for (int j = 0; j < m / 2; j++) {\n                    long long t = g0 * a[k + j + m / 2] % mod;\n                    long long u = a[k + j];\n                    a[k + j] = (u + t) % mod;\n                    a[k + j + m / 2] = (u - t + mod) % mod;\n                    g0 = g0 * gn % mod;\n                }\n            }\n        }\n        if (type == -1) {\n            long long inv = qpow(sz, mod - 2);\n            for (int i = 0; i < sz; i++) a[i] = a[i] * inv % mod;\n        }\n    }\n}\n\nnamespace Polynomial {\n    using namespace NTT;\n\n    void Convolution(int n, int m, int a[], int b[], int c[]) { // a[0, n] b[0, m]\n        int N = n + m + 1;\n        init(N);\n        long long f[N], g[N];\n        for (int i = 0; i < N; i++) f[i] = g[i] = 0;\n        for (int i = 0; i <= n; i++) f[i] = a[i];\n        for (int i = 0; i <= m; i++) g[i] = b[i];\n        dft(f, N, 1), dft(g, N, 1);\n        long long res[N];\n        for (int i = 0; i < N; i++) res[i] = 0;\n        for (int i = 0; i < N; i++) res[i] = f[i] * g[i] % mod;\n        dft(res, N, -1);\n        for (int i = 0; i <= n + m; i++) c[i] = res[i];\n    }\n};\n\nstring s, t;\nint a[MAXN], b[MAXN], c[MAXN << 1], f[MAXN], pres[MAXN], pret[MAXN];\n\nint main() {\n    boost;\n    cin >> s >> t, reverse(t.begin(), t.end());\n    int n = s.size(), m = t.size();\n    for (int i = 1; i <= n; i++) a[i] = s[i - 1] - '0', pres[i] = pres[i - 1] + a[i];\n    for (int i = 1; i <= m; i++) b[i] = t[i - 1] - '0', pret[i] = pret[i - 1] + b[i];\n    Polynomial::Convolution(n, m, a, b, c);\n    int ans(INT_MAX);\n    for (int i = 1; i <= n - m + 1; i++) {\n        f[i] = -2 * c[i + m] + (pres[i + m - 1] - pres[i - 1]) + (pret[m]);\n        ans = min(ans, f[i]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n```\n","tags":["动态规划","轮廓线DP","contest","FFT"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 194","url":"/2021/03/10/atcoder-abc-194/","content":"[比赛链接](https://atcoder.jp/contests/abc194)\n<!-- more -->\n# D Journey\n## Description\n[题目链接](https://atcoder.jp/contests/abc194/tasks/abc194_d)\n## Solution\n如果一个实验成功的概率为 $\\frac{1}{p}$，那么重复实验直到实验成功的期望实验次数为 $p$。对于 $N$ 个节点的图，设已经联通了 $i$ 个点，要联通 $i+1$ 个点，则会从不在当前联通块中的 $N-i$ 个点中随机选取一个，其概率为 $\\frac{N-i}{N}$，期望次数为 $\\frac{N}{N-i}$。把 $i=1...N-1$ 的各个阶段的期望加起来即可得答案为 $\\sum \\limits_{i=1}^{N-1} \\frac{N}{i}$。\n## Code\n```cpp Journey\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nint n;\ndouble ans;\n\nsigned main() {\n    cin >> n;\n    for (int i = 1; i <= n - 1; i++) ans += 1.0 * n / i;\n    cout << setprecision(6) << fixed << ans;\n    return 0;\n}\n```\n\n# E Mex Min\n## Description\n[题目链接](https://atcoder.jp/contests/abc194/tasks/abc194_e)\n## Solution\n静态区间 $mex$ 参考这道题目：[题目链接](https://www.luogu.com.cn/problem/P4137)\n\n如果不强制在线的话，可以对区间按 $r$ 排序后，用值域线段树记录每个数最后出现的位置，区间 $mex$ 最后出现位置应该小于 $l$。如果强制在线的话把值域线段树换成可持久化线段树即可。\n\n实际上，本题还有一个比较简单的做法。转化一下题意，题目即求最小的数，使得存在一个长度大于等于 $m$ 的区间不包含这个数。因此我们对每个数维护一个 $vector$，记录其所有出现的位置，同时对每个 $vector$ 插入 $0$ 和 $n+1$。接下来按数值从小到大遍历每个 $vector$，判断是否有前一个位置和后一个位置差大于 $m$ 即可。 \n## Code\n```cpp Mex Min\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1.5E6 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, a[MAXN];\nvector<int> v[MAXN];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i = 0; i <= n; i++) v[i].push_back(0);\n    for (int i = 1; i <= n; i++) cin >> a[i], v[a[i]].push_back(i);\n    for (int i = 0; i <= n; i++) v[i].push_back(n + 1);\n    for (int i = 0; i <= n; i++)\n        for (int j = 1; j < v[i].size(); j++)\n            if (v[i][j] - v[i][j - 1] > m) return cout << i, 0;\n    return 0;\n}\n```\n\n\n# F Digits Paradise in Hexadecimal\n## Description\n[题目链接](https://atcoder.jp/contests/abc194/tasks/abc194_f)\n## Solution\n设 $dp[i][j]$ 表示考虑前 $i$ 位，能构造的满足以下约束条件的数的个数：\n- 恰由 $j$ 个不同的数构成。\n- 不全为 $0$。\n- 严格小于 $N$ 的前 $i$ 位。\n\n考虑第 $i+1$ 位，有如下两种情况：\n- 选自前 $i$ 位中的某一个，有 $dp[i+1][j] \\leftarrow dp[i][j]*j$。\n- 和前 $i$ 位都不同，有 $dp[i+1][j+1] \\leftarrow dp[i][j]*(16-j)$。\n\n由定义可知，$dp[i+1][j+1]$ 和 $dp[i+1][j]$ 仍满足约束条件。\n\n容易发现，有两种情况未包含在上述状态转移方程中，即：\n-  前 $i$ 位全为 $0$，则第 $i+1$ 位可以在 $1$ 到 $F$ 任取，此时有 $dp[i+1][1] \\leftarrow 15$。\n-  前 $i$ 位等于 $N$ 的前 $i$ 位，则第 $i+1$ 位应小于 $N$ 的第 $i+1$ 位。容易统计出前 $i$ 位中有多少个不同的数，记为 $tot$，那么对于小于 $N_{i+1}$ 的每一个数，如果它在之前没有出现过，则有 $dp[i+1][tot+1] \\leftarrow 1$；否则有 $dp[i+1][tot] \\leftarrow 1$。\n## Code\n```cpp Digits Paradise in Hexadecimal\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, k, tot;\nchar c[MAXN];\nLL dp[MAXN][17];\nint cnt[17], vis[17];\n\nint f(char c) { return ((c >= 'A' && c <= 'F') ? c - 'A' + 10 : c - '0'); }\n\nvoid add(LL& a, LL b) { a = ((a + b) % MOD + MOD) % MOD; }\n\nsigned main() {\n    scanf(\"%s%d\", c + 1, &k);\n    n = strlen(c + 1);\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= 16; j++) {\n            add(dp[i][j], dp[i - 1][j] * j);\n            if (j >= 2) add(dp[i][j], dp[i - 1][j - 1] * (16 - j + 1));\n        }\n        if (i >= 2) add(dp[i][1], 15);\n        if (tot) add(dp[i][tot], cnt[f(c[i])]);\n        if (f(c[i])) add(dp[i][tot + 1], f(c[i]) - cnt[f(c[i])] - (i == 1));\n        if (!vis[f(c[i])]) {\n            vis[f(c[i])] = 1;\n            tot++;\n            for (int j = f(c[i]) + 1; j <= 16; j++) cnt[j]++;\n        }\n    }\n    add(dp[n][k], tot == k);\n    printf(\"%lld\", dp[n][k]);\n    return 0;\n}\n```\n","tags":["动态规划","contest","数学期望","数位DP"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 191","url":"/2021/02/22/atcoder-abc-191/","content":"[比赛链接](https://atcoder.jp/contests/abc191)\n<!-- more -->\n# C Digital Graffiti\n## Description\n[题目链接](https://atcoder.jp/contests/abc191/tasks/abc191_c)\n## Solution\n可以发现 $(x, y)$ 为顶点当且仅当 $(S_{x, y}, S_{x, y}, S_{x, y}, S_{x, y})$ 中有一个或者三个为 #。于是二重循环枚举判断即可。\n## Code\n```cpp Digital Graffiti\n#include <bits/stdc++.h>\n\nusing namespace std;\n \nint main(){\n    int H, W;\n    cin >> H >> W;\n    vector<string> S(H);\n    for(auto& s : S) cin >> s;\n    int ans = 0;\n    for(int i = 0; i < H - 1; i++) for(int j = 0; j < W - 1; j++)\n        if(S[i][j] ^ S[i][j + 1] ^ S[i + 1][j] ^ S[i + 1][j + 1]) ans++;\n    cout << ans << endl;\n}\n```\n\n# D Circle Lattice Points\n## Description\n[题目链接](https://atcoder.jp/contests/abc191/tasks/abc191_d)\n## Solution\n为防止浮点误差，将读入的小数乘以 10000 (注意不能乘 10000 后强制转化为整型)。然后枚举 $x$，求出 $y$ 对应的取值范围，从而求出坐标为 $x$ 且在圆内的整数点的个数。求 y 的范围时涉及 $sqrt$ 开根号，也会产生误差，考虑加一个偏移区间，求出 $y$ 的正确上下界。\n\n也有直接求的做法 [Submission](https://atcoder.jp/contests/abc191/submissions/20048678);\n## Code\n```cpp Circle Lattice Points\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m;\n\nLL get(LL val) {\n    LL tmp = val % 10000;\n    if (val >= 0)\n        return val - tmp;\n    else\n        return val - tmp - (tmp == 0 ? 0 : 10000);\n}  //返回小于等于的第一个能模10000的数\n\nvoid solve(int testNum) {\n    // type your code here\n    string aa, bb, rr;\n    LL a = 0, b = 0, r = 0;\n    cin >> aa >> bb >> rr;\n    int cnta = 4, cntb = 4, cntr = 4;\n    bool taga = 0, tagb = 0, tagr = 0;\n    for (int i = 0; i < aa.size(); i++) {\n        if (taga) cnta--;\n        if (aa[i] != '.')\n            a = a * 10 + aa[i] - '0';\n        else\n            taga = 1;\n    }\n    while (cnta) a *= 10, cnta--;\n\n    for (int i = 0; i < bb.size(); i++) {\n        if (tagb) cntb--;\n        if (bb[i] != '.')\n            b = b * 10 + bb[i] - '0';\n        else\n            tagb = 1;\n    }\n    while (cntb) b *= 10, cntb--;\n\n    for (int i = 0; i < rr.size(); i++) {\n        if (tagr) cntr--;\n        if (rr[i] != '.')\n            r = r * 10 + rr[i] - '0';\n        else\n            tagr = 1;\n    }\n    while (cntr) r *= 10, cntr--;\n    LL ans = 0;\n    for (LL y = get(b - r); y <= get(b + r); y += 10000) {\n        LL res = r * r - (y - b) * (y - b);\n        if (res > 0) {\n            LL tmp = sqrt(res);\n            LL k1 = get(-tmp + a) - 100000, k2 = get(tmp + a) + 1000000;\n            while ((k1 - a) * (k1 - a) > res) k1+=10000;\n            while ((k2 - a) * (k2 - a) > res) k2-=10000;\n            ans += (k2 - k1) / 10000 + 1;\n        } else if (res == 0 && a % 10000 == 0)\n            ans++;\n    }\n    cout << ans;\n}\n\nsigned main() {\n    int testCase = 1;\n    for (int i = 1; i <= testCase; i++) solve(i);\n    return 0;\n}\n```\n\n# E Come Back Quickly\n## Description\n[题目链接](https://atcoder.jp/contests/abc191/tasks/abc191_e)\n## Solution\n- 询问在有向图中从起点出发回到起点的最短回路。\n\n- 先求出单源最短路，由于 $dist_start$ 初始值为0，故需枚举每个点 $i$，答案为 $dist_i + w_{i, start}$ 的最小值。\n\n## Code\n```cpp Come Back Quickly\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 2002, MOD = 1e9 + 7;\n\nint n, m;\nvector<pair<int, int>> g[MAXN];\narray<int, MAXN> dis, inq, self;\n\nvoid spfa(int st) {\n    for (int i = 1; i <= n; i++) dis[i] = 1e9, inq[i] = false;\n    queue<int> q;\n    q.push(st), inq[st] = true;\n    dis[st] = 0;\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        inq[cur] = false;\n        for (auto& e : g[cur]) {\n            int to = e.first, w = e.second;\n            if (dis[to] > dis[cur] + w) {\n                dis[to] = dis[cur] + w;\n                if (!inq[to]) {\n                    q.push(to);\n                    inq[to] = true;\n                }\n            }\n        }\n    }\n    int ans = 1e9;\n    for (int i = 1; i <= n; i++) {\n        for (auto & e : g[i]) {\n            if (e.first == st) {\n                ans = min(ans, dis[i] + e.second);\n            }\n        }\n    }\n    if (ans != 1e9) cout << ans << \"\\n\";\n    else cout << \"-1\\n\";\n}\n\n\nsigned main() {\n    boost;\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        g[u].push_back({v, w});\n    }\n    for (int i = 1; i <= n; i++) spfa(i);\n    return 0;\n}\n```\n\n# F GCD or MIN\n## Description\n[题目链接](https://atcoder.jp/contests/abc191/tasks/abc191_f)\n## Solution\n- 经过一系列操作后结果一定小于等于 $min(A_i)$。\n\n- 小于 $min(A_i)$ 的数是通过 $A$ 数组中的一些数取 $gcd$ 再取最小值得到，即是一些数的约数。于是可以 $O(n * max(sqrt(A_i)))$ 求出小于 $min(A_i)$ 的约数，然后求出其在 $A$ 数组中的倍数，判断它们的 $gcd$ 是否为该约数。\n\n- 由于 $n$ 个数的不同约数个数大概为 $n * log(n)$，故总时间复杂度为 $O(n * max(sqrt(A_i)) + n^2 * log(n))$。\n\n## Code\n```cpp GCD or MIN\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, mn;\narray<int, MAXN> a;\nvector<int> divs;\n\nint main() {\n    boost;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    mn = *min_element(a.begin() + 1, a.begin() + n + 1);\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= sqrt(a[i]); j++) {\n            if (a[i] % j == 0) divs.push_back(j), divs.push_back(a[i] / j);\n        }  \n    }\n    sort(divs.begin(), divs.end());\n    auto ed = unique(divs.begin(), divs.end());\n    int ans = 0;\n    for (auto it = divs.begin(); it != ed; ++it) {\n        if (*it >= mn) continue;\n        vector<int> vec;\n        for (int i = 1; i <= n; i++) if (a[i] % (*it) == 0) vec.push_back(a[i]);\n        if (vec.size() <= 1) continue;\n        int gcd = vec.front();\n        for (int i = 1; i < vec.size(); i++)\n            gcd = __gcd(gcd, vec[i]);\n        if (gcd == *it) ans++;\n    }\n    cout << ans + 1 << \"\\n\";\n    return 0;\n}\n```\n","tags":["contest"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 192","url":"/2021/02/22/atcoder-abc-192/","content":"[比赛链接](https://atcoder.jp/contests/abc192)\n<!-- more -->\n# E Train\n## Description\n[题目链接](https://atcoder.jp/contests/abc192/tasks/abc192_e)\n## Solution\n设 $dis_i$ 表示从起点到 $i$ 的最短时间。设当前节点 $now$，$dis_{now}$ 已求出，节点 $now$ 的后继节点为 $to$，所连边编号为 $i$，则有 $dis_{to} = min(dis_{to},dis_{now+} \\lceil  \\frac{dis_{now}}{k_i} \\rceil*k_i+t_i）$。用 $Dijkstra$ 算法跑一遍最短路即可。\n## Code\n```cpp Train\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define int long long\n\nusing namespace std;\ntypedef long long LL;\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\nstruct Edge {\n    int to, k, t;\n};\n\nconst int MAXN = 1E5 + 5;\n\nvector<Edge> G[MAXN];\n\nint n, m, dis[MAXN], vis[MAXN], x, y;\n\nvoid solve(int caseNum) {\n    read(n, m, x, y);\n    for (int i = 1; i <= m; i++) {\n        int u, v, k, t;\n        read(u, v, t, k);\n        G[u].push_back(Edge{v, k, t});\n        G[v].push_back(Edge{u, k, t});\n    }\n    for (int i = 1; i <= n; i++) dis[i] = 1e18;\n    priority_queue<pair<int, int>, vector<pair<int, int> >,\n                   greater<pair<int, int> > >\n        q;\n    dis[x] = 0;\n    q.push({0, x});\n    while (!q.empty()) {\n        int now = q.top().second;\n        q.pop();\n        if (vis[now]) continue;\n        vis[now] = 1;\n        for (auto& e : G[now]) {\n            int to = e.to;\n            int k = e.k;\n            int t = e.t;\n            int tmp =\n                (dis[now] % k == 0 ? dis[now] / k : dis[now] / k + 1) * k + t;\n            if (dis[to] > tmp) {\n                dis[to] = tmp;\n                q.push({dis[to], to});\n            }\n        }\n    }\n    if (dis[y] == 1e18)\n        cout << -1;\n    else\n        cout << dis[y];\n}\n\nsigned main() {\n    int testCase = 1;\n    for (int i = 1; i <= testCase; i++) solve(i);\n    return 0;\n}\n```\n\n# F Potion\n## Description\n[题目链接](https://atcoder.jp/contests/abc192/tasks/abc192_f)\n## Solution\n设选了 $c$ 种材料，那么对于某个固定的 $C$，要使达到魔法值 $X$ 的时间最小，我们需要让选择材料的魔法值的和尽可能大，且该和与 $X$ 模 $C$ 同余。设 $dp[i][j][k]$ 表示在前 $i$ 种材料中选了 $j$ 个，这些材料魔法值的和模 $C$ 余 $k$ 时能得到的最大魔法值。那么有$dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-1)[((k - A[i]) \\% C + C) \\% C]+A_i)$，于是答案即为 $\\min\\limits_{1 \\le C \\le N} \\frac{X-dp[N][C][X \\% C]}{C}$。注意状态转移时只从合法的状态转移，对于不合法的状态，我们设其 $dp$ 值为 $-1$，遇到这些状态应直接跳过。\n## Code\n```cpp Potion\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define int long long\n\nusing namespace std;\n\nconst int MAXN = 101;\nconst int MOD = 1E9 + 7;\nint n, x, a[MAXN], dp[MAXN][MAXN][MAXN], ans = 1E18;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> x;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int c = 1; c <= n; c++) {\n        memset(dp, -1, sizeof(dp));\n        for (int i = 0; i <= n; i++) dp[i][0][0] = 0;\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= i; j++) {\n                for (int k = 0; k < c; k++) {\n                    dp[i][j][k] = dp[i - 1][j][k];\n                    if (dp[i - 1][j - 1][((k - a[i]) % c + c) % c] != -1)\n                        dp[i][j][k] = max(\n                            dp[i][j][k],\n                            dp[i - 1][j - 1][((k - a[i]) % c + c) % c] + a[i]);\n                }\n            }\n        if (dp[n][c][x % c] != -1) ans = min(ans, (x - dp[n][c][x % c]) / c);\n    }\n    cout << ans;\n    return 0;\n}\n```\n","tags":["动态规划","最短路","contest"],"categories":["contest"]},{"title":"Codeforces Round 701 Div2","url":"/2021/02/21/cf-701-div2/","content":"[比赛链接](https://codeforces.ml/contest/1485)\n<!-- more -->\n# A - Add and Divide\n## Description\n[题目链接](https://codeforces.ml/contest/1485/problem/A)\n## Solution\n由于 $\\lfloor \\frac{a}{b+1} \\rfloor \\le \\frac{a}{b}$，故先对 $b$ 增值再进行除法运算更优，因此暴力枚举 $b$ 增值的次数再计算做除法的次数即可。容易证明操作次数最少时 $b$ 增值的次数不会超过 $10$ 次。 \n## Code\n```cpp Add and Divide\nvoid solve() {\n    LL a, b;\n    cin >> a >> b;\n    LL ans = INT_MAX;\n    for (int j = 0; j <= 10; j++) {\n        if (j == 0 && b == 1) continue;\n        LL tmp = 0;\n        while (qpow(b + j, tmp) <= a) tmp++;\n        ans = min(ans, tmp + j);\n    }\n    cout << ans << endl;\n}\n```\n\n# B - Replace and Keep Sorted\n## Description\n[题目链接](https://codeforces.ml/contest/1485/problem/B)\n## Solution\n对于数组 $b$ 的第 $i$ 位，其取值在 $[a_{i-1}+1,a_i)∪(a_i,a_{i+1}-1]$ 内，共 $f_{i} = a_{i+1}-a_{i-1}-2$ 个。对于区间 $[l,r]$，能生成的不同的数组 $b$ 共有 $\\sum \\limits_{l \\le i \\le r} f_i = a_{r+1}+a_{r}-a_{l}-a_{l-1}-2*(r-l+1)$ 个，其中规定 $a_{r+1}=k+1$，$a_{l-1} = 0$。\n## Code\n```cpp Replace and Keep Sorted\nconst int MAXN = 1E5 + 5;\nint n, q, k, a[MAXN];\n \nvoid solve() {\n    cin >> n >> q >> k;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    a[0] = 0, a[n + 1] = k + 1;\n    for (int i = 1; i <= q; i++) {\n        int l, r;\n        cin >> l >> r;\n        cout << k + 1 + a[r] - a[l] - 2 * (r - l + 1) << endl;\n    }\n}\n```\n\n# C - Floor and Mod\n## Description\n[题目链接](https://codeforces.ml/contest/1485/problem/C)\n## Solution\n设 $a=kb+r$，由 $\\lfloor \\frac{a}{b} \\rfloor = a \\mod b$ 解得 $k=r$，即 $a = k(b+1)$，且 $b>k$。因为 $k^2 \\le kb+k \\le x$， 故 $k \\le \\sqrt{x}$。又由于 $1\\le kb+k \\le x$，故有 $k < b \\le \\frac{x}{k}-1$。我们在 $\\sqrt{x}$ 内枚举 $k$，对每一个 $k$ 容易求出满足条件的 $b$ 的个数。\n## Code\n```cpp Floor and Mod\nvoid solve(int testNum) {\n    int x, y;\n    cin >> x >> y;\n    LL ans = 0;\n    for (int k = 1; k <= sqrt(x); k++) ans += max(0, min(y, x / k - 1) - k);\n    cout << ans << endl;\n}\n```\n\n# D - Multiples and Power Differences\n## Description\n[题目链接](https://codeforces.ml/contest/1485/problem/D)\n## Solution\n$1,2,....,16$ 的最小公倍数是 $720720$，因此先将每个数变为 $720720$，对于 $i+j$ 是偶数的位置，再加上 $a_{i,j}^2$ 即可。\n## Code\n```cpp Multiples and Power Differences\nconst int MAXN = 505;\nint n, m, a[MAXN][MAXN];\n\nvoid solve() {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++) {\n            cin >> a[i][j];\n            if ((i + j) % 2 == 0)\n                a[i][j] = 720720 + pow(a[i][j], 4);\n            else\n                a[i][j] = 720720;\n        }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) cout << a[i][j] << \" \";\n        cout << endl;\n    }\n}\n```\n\n# E - Move and Swap\n## Description\n[题目链接](https://codeforces.ml/contest/1485/problem/E)\n## Solution\n设 $dp[i]$ 表示红色硬币在节点 $i$，以该节点为起点继续移动能获得的最大分数。我们按层次从大到小进行状态转移，设当前为第 $l$ 层，第 $[l+1,d]$ 层节点的结果已求出，该层红色硬币位于节点 $i$，蓝色硬币位于节点 $p$。考虑这两个硬币接下来的移动，由题意有如下两种情况：\n\n- 红蓝硬币不交换位置，则红色硬币下一步移向 $i$ 节点的所有儿子中能获得分数最大的那一个，蓝色硬币相应地移至下一层能使得分最大的节点，此时有 $dp_i = \\max \\limits_{j∈Son_i} {dp_j}+|a_i-a_p|$。\n\n- 红蓝硬币交换位置，则红色硬币下一步移向 $p$ 节点的所有儿子中能获得分数最大的那一个，此时有 $dp_i = \\max \\limits_{j∈Son_p} {dp_j}+|a_i-a_p|$。根据 $a_p$ 和 $a_i$ 的大小关系有如下两种情况：\n  \n  - $a_p \\le a_i$，则 $dp_i = a_i + (\\max \\limits_{j∈Son_p} {dp_j} - a_p)$\n  \n  - $a_p \\ge a_i$，则 $dp_i = -a_i + (\\max \\limits_{j∈Son_p} {dp_j} + a_p)$ \n\n将每一层的节点按 $a$ 从小到大排序。要使 $dp_i$ 最大，对于第一种情况，$a_p$ 为该层最大值或最小值；对于第二种情况，将排序后的节点扫一遍，对 $\\max \\limits_{j∈Son_p} {dp_j} - a_p$ 记录前缀最大值，对 $\\max \\limits_{j∈Son_p} {dp_j} + a_p$ 记录后缀最大值即可。\n## Code\n```cpp Move and Swap\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define int long long\n\nusing namespace std;\ntypedef long long LL;\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, d, dp[MAXN], a[MAXN], mxSonVal[MAXN], fa[MAXN];\nint pre[MAXN], pos[MAXN];\nvector<int> G[MAXN];\nvector<pair<int, int> > v[MAXN];\n\nvoid dfs1(int now, int f, int level) {\n    v[level].push_back(make_pair(a[now], now));\n    fa[now] = f;\n    d = max(d, level);\n    for (auto& to : G[now])\n        if (to != f) dfs1(to, now, level + 1);\n}\n\nvoid levelDp() {\n    for (int level = d; level >= 0; level--) {\n        int cnt = v[level].size();\n        for (int i = 0; i < cnt; i++) {\n            int node = v[level][i].second;\n            dp[node] =\n                max(dp[node],\n                    mxSonVal[node] + max(a[node] - v[level][0].first,\n                                         v[level][cnt - 1].first - a[node]));\n        }\n        for (int i = 0; i < cnt; i++) {\n            int node = v[level][i].second;\n            if (i == 0)\n                pre[i] = -a[node] + mxSonVal[node];\n            else\n                pre[i] = max(pre[i - 1], -a[node] + mxSonVal[node]);\n        }\n        for (int i = cnt - 1; i >= 0; i--) {\n            int node = v[level][i].second;\n            if (i == cnt - 1)\n                pos[i] = a[node] + mxSonVal[node];\n            else\n                pos[i] = max(pos[i + 1], a[node] + mxSonVal[node]);\n        }\n        for (int i = 0; i < cnt; i++) {\n            int res = 0;\n            int node = v[level][i].second;\n            res = max({res, pre[i] + a[node], pos[i] - a[node]});\n            dp[node] = max(dp[node], res);\n            mxSonVal[fa[node]] = max(mxSonVal[fa[node]], dp[node]);\n        }\n    }\n}\n\nvoid solve(int caseNum) {\n    read(n);\n    for (int i = 2; i <= n; i++) {\n        int v;\n        read(v);\n        G[i].push_back(v);\n        G[v].push_back(i);\n    }\n    for (int i = 2; i <= n; i++) read(a[i]);\n    dfs1(1, 1, 0);\n    for (int i = 1; i <= n; i++) sort(v[i].begin(), v[i].end());\n    levelDp();\n    printf(\"%lld\\n\", dp[1]);\n    for (int i = 0; i <= n; i++) {\n        G[i].clear(), v[i].clear();\n        dp[i] = 0, mxSonVal[i] = 0;\n    }\n    d = 0;\n}\n\nsigned main() {\n    int testCase = 1;\n    read(testCase);\n    for (int i = 1; i <= testCase; i++) solve(i);\n    return 0;\n}\n```\n\n# F - Copy or Prefix Sum\n## Description\n[题目链接](https://codeforces.ml/contest/1485/problem/F)\n## Comment\n题解中提到的做法很有意大利风格...\n## Solution\n设 $dp_{i,j}$ 表示满足题目条件的长度为 $i$，和为 $j$ 的数列 $a$ 的个数。如果 $b_i = a_i$，那么对 $\\forall j \\neq 0,dp_{i+1,j+b_i}=dp_{i,j}$；如果 $b_i = \\sum \\limits_{j=1}^{i}a_j$，则对 $\\forall j, dp_{i+1,b_i} = \\sum dp_{i,j}$。我们用一个 $map$ 维护 $dp$，每一次更新实际上是对 $map$ 中所有元素的第一关键字加一个值，第二关键字不变，之后再修改某一个元素的第二关键字为所有元素第二关键字的和。上述过程用 [Venice Technique](https://codeforces.ml/blog/entry/58316) 便可轻松实现。\n## Code\n```cpp Copy or Prefix Sum\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define int long long\n\nusing namespace std;\ntypedef long long LL;\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\nconst int MOD = 1E9 + 7;\nint n, T;\n\nstruct VeniceSet {\n    map<int, int> dp;\n    int waterLevel = 0;\n    int sumDp = 1;\n    VeniceSet(int v) { dp[v] = 1; }\n    void addSum(int v) { sumDp = (sumDp + v) % MOD; }\n    void change(int v, int res) { dp[v + waterLevel] = res % MOD; }\n    int get(int v) { return dp[v + waterLevel]; }\n    void remove(int v) { dp[v + waterLevel] = 0; }\n    void updateAll(int v) { waterLevel += v; }\n    int size() { return dp.size(); }\n};\n\nsigned main() {\n    read(T);\n    while (T--) {\n        read(n);\n        int b;\n        read(b);\n        VeniceSet mySet(b);\n        for (int i = 2; i <= n; i++) {\n            read(b);\n            mySet.updateAll(-b);\n            int tmp = mySet.get(b);\n            mySet.change(b, mySet.sumDp);\n            mySet.addSum(-tmp + mySet.sumDp);\n        }\n        printf(\"%lld\\n\", (mySet.sumDp + MOD) % MOD);\n    }\n    return 0;\n}\n```\n\n\n","tags":["contest"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 189","url":"/2021/02/09/atcoder-abc-189/","content":"[比赛链接](https://atcoder.jp/contests/abc189)\n<!-- more -->\n# D Logical Expression\n## Description\n[题目链接](https://atcoder.jp/contests/abc189/tasks/abc189_d)\n## Solution\n设 $dp[i][0 / 1]$ 表示前 $i + 1(i > 0)$ 个变量进行逻辑运算后结果为 false 或 true 的方案数。边界条件为 $dp[0][0] = dp[0][1] = 1$。 状态转移显然。\n## Code\n```cpp Logical Expression\n#include <bits/stdc++.h>\n \n#define debug(x) cerr << #x << \" = \" << x << endl\n \nusing namespace std;\ntypedef long long LL;\n \nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nLL n;\nstring s;\nLL dp[64][2];\n \nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    dp[0][1] = dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        cin >> s;\n        if (s == \"AND\") {\n            dp[i][1] = dp[i - 1][1];\n            dp[i][0] = dp[i - 1][1] + dp[i - 1][0] * 2;\n        } else {\n            dp[i][1] = dp[i - 1][1] * 2 + dp[i - 1][0];\n            dp[i][0] = dp[i - 1][0];\n        }\n    }\n    cout << dp[n][1];\n    return 0;\n}\n```\n\n# E Rotate and Flip\n## Description\n[题目链接](https://atcoder.jp/contests/abc189/tasks/abc189_e)\n## Solution\n首先需要离线处理。对于第 $A_i$ 操作，可将待询问的棋子编号与询问编号存放到 $A_i$ 对应的 vector 中。\n设棋子的坐标为 (x, y)，那么进行一次操作后的坐标可以用 (x, y) 表示出来，进而可得到若干操作后最终的坐标:\n  - 顺时针旋转 90 度，坐标为 (-x, y)\n  - 逆时针旋转 90 度，坐标为 (-y, x)\n  - 关于直线 x = p 对称，坐标为 (2 * p - x, y)\n  - 关于直线 y = p 对称，坐标为 (x, 2 * p - y)\n\n于是可以维护 x、y 坐标的符号标记 signx, signy；增量标记 addx, addy 以及 x、y 的交换标记。若有交换标记，则将 (x, y) 变换为 (y, x)，然后判断符号以及加上对应增量，即可得到某次操作后的点的坐标。\n## Code\n```cpp Rotate and Flip\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 2e5 + 5, MOD = 1e9 + 7;\n\nint n, m, q;\nint revx, revy;\nint addx, addy;\nint swapxy;\narray<int, MAXN> x, y, a, b;\narray<int, MAXN> op, p, ansx, ansy;\nvector<pair<int, int>> vec[MAXN];\n\nsigned main() {\n    boost;\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n    cin >> m;\n    for (int i = 1; i <= m; i++) {\n        cin >> op[i];\n        if (op[i] > 2) cin >> p[i];\n    }\n    cin >> q;\n    for (int i = 1; i <= q; i++) {\n        cin >> a[i] >> b[i];\n        vec[a[i]].emplace_back(b[i], i);\n    }\n    for (auto& i : vec[0]) {\n        ansx[i.second] = x[i.first];\n        ansy[i.second] = y[i.first];\n    }\n    for (int i = 1; i <= m; i++) {\n        if (op[i] == 1) {\n            swapxy ^= 1, revx ^= 1, addx *= -1;\n            swap(revx, revy), swap(addx, addy);\n        } else if (op[i] == 2) {\n            swapxy ^= 1, revy ^= 1, addy *= -1;\n            swap(revx, revy), swap(addx, addy);\n        } else if (op[i] == 3) {\n            revx ^= 1, addx *= -1;\n            addx += p[i] * 2;\n        } else {\n            revy ^= 1, addy *= -1;\n            addy += p[i] * 2;\n        }\n        for (auto& ii : vec[i]) {\n            ansx[ii.second] = x[ii.first];\n            ansy[ii.second] = y[ii.first];\n            if (swapxy) swap(ansx[ii.second], ansy[ii.second]);\n            if (revx) ansx[ii.second] *= -1;\n            if (revy) ansy[ii.second] *= -1;\n            ansx[ii.second] += addx;\n            ansy[ii.second] += addy;\n        }\n    }\n    for (int i = 1; i <= q; i++)\n        cout << ansx[i] << \" \" << ansy[i] << \"\\n\";\n    return 0;\n}\n```\n\n# F Sugoroku2\n## Description\n[题目链接](https://atcoder.jp/contests/abc189/tasks/abc189_f)\n## Solution\n设 $f_i$ 表示从 $i$ 到 $n$ 的期望步数。则有\n$$\nf_{i} =\n\\begin{cases}\n0 & i > n\\\\\nf_0 & 如果会从 i 传送到 0\\\\\n1 / M * (f_{i+1} + ... + f_{i + M}) + 1 & 其它\\\\\n\\end{cases}\n$$\n于是发现 $f_i$ 可以表示为 $A_i * f_0 + B_i$ 的形式，最终 $f(0) = A_0 * f_0 + B_0$，解出 $f_0$ 即为从起点到终点的步数。 (通过后缀和分别求出 $A_i$ 和 $B_i$，注意分母为 0 时无解)\n## Code\n```cpp Sugoroku2\n#include <bits/stdc++.h>\n#define double long double\n\nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, m, k;\narray<int, 11> a;\narray<double, MAXN * 2> sufa, sufb;\n\nint main() {\n    boost;\n    cin >> n >> m >> k;\n    cout << setprecision(4) << fixed;\n    set<int> s;\n    for (int i = 1; i <= k; i++) cin >> a[i], s.insert(a[i]);\n    for (int i = n - 1; i >= 0; i--) {\n        if (s.count(i)) {\n            sufa[i] = sufa[i + 1] + 1;\n            sufb[i] = sufb[i + 1];\n            continue;\n        }\n        double tmpa = (sufa[i + 1] - sufa[i + m + 1]) / m;\n        double tmpb = (sufb[i + 1] - sufb[i + m + 1]) / m + 1;\n        sufa[i] = sufa[i + 1] + tmpa;\n        sufb[i] = sufb[i + 1] + tmpb;\n        if (i == 0) {\n            if (abs(1.0 - tmpa) > 1e-15)cout << tmpb / (1.0 - tmpa) << endl;\n            else cout << -1 << endl;\n        }\n    }   \n    return 0;\n}\n```","tags":["contest"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 190","url":"/2021/02/09/atcoder-abc-190/","content":"[比赛链接](https://atcoder.jp/contests/abc190)\n<!-- more -->\n# D Staircase Sequences\n## Description\n[题目链接](https://atcoder.jp/contests/abc190/tasks/abc190_d)\n## Solution\n设首项为 $a$，项数为 $n$，那么有 $n*(2a+n-1)=2N$。由于 $n$ 为正整数，$a$ 为整数，因此 $n$ 为 $2N$ 的因数，且 $\\frac{2N}{n}-n+1$ 是偶数。不同的 $n$ 对应不同的数列，因此答案为满足上述条件的 $n$ 的个数。\n## Code\n```cpp Staircase Sequences\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nLL n;\n\nsigned main() {\n    cin >> n;\n    n *= 2;\n    LL ans = 0;\n    for (int x = 1; x <= sqrt(n); x++) {\n        if (n % x == 0) {\n            LL tmp = n / x + 1 - x;\n            if (tmp % 2 == 0) ans++;\n        }\n    }\n    cout << ans * 2;\n    return 0;\n}\n```\n\n\n# E Magical Ornament\n## Description\n[题目链接](https://atcoder.jp/contests/abc190/tasks/abc190_e)\n## Solution\n称必须包括的 $K$ 种宝石为关键宝石，本题实际上是求对这些宝石进行排列的代价。我们只需要考虑关键宝石两两之间间接相连中间至少要通过几个宝石，之后便容易用状压 $dp$ 求解。具体的，我们分别以这 $K$ 个关键宝石为起点跑 $K$ 次最短路，同时记录从起点到其余关键宝石的最短距离，并用数组 $dis$ 记录。设 $dp[i][j]$ 表示当前宝石集合为 $i$，最后一个加入的为第 $j$ 个关键宝石所需的最少宝石数目，那么有 $dp[i][j] = dp[i⊕(1<<j)][k] +dis[k][j]$，于是答案即为 $\\min \\limits_{1 \\le i \\le K}dp[(1<<K)-1][i]$。\n\n上述做法时间复杂度为 $O(K(N+M)+K^22^K))$。\n## Code\n```cpp Magical Ornament\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1E5 + 5;\nconst int MAXS = (1 << 17);\nconst int MOD = 1E9 + 7;\nint n, m, k;\nvector<int> G[MAXN];\nint dis[17][17], dp[MAXS][17];\nint tag[MAXN], vis[MAXN], d[MAXN], c[18];\n\nvoid bfs(int s) {\n    for (int i = 1; i <= n; i++) d[i] = 1e9, vis[i] = 0;\n    queue<int> q;\n    q.push(s);\n    d[s] = 0;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        if (vis[now]) continue;\n        vis[now] = 1;\n        for (auto& to : G[now]) {\n            if (d[to] > d[now] + 1) {\n                d[to] = d[now] + 1;\n                q.push(to);\n            }\n            if (tag[to])\n                dis[tag[s] - 1][tag[to] - 1] = dis[tag[to] - 1][tag[s] - 1] =\n                    d[to];\n        }\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        int u, v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    cin >> k;\n    for (int i = 1; i <= k; i++) {\n        cin >> c[i];\n        tag[c[i]] = i;\n    }\n    for (int i = 0; i < k; i++)\n        for (int j = 0; j < k; j++) dis[i][j] = 1e9;\n    for (int i = 1; i <= k; i++) bfs(c[i]);\n\n    for (int i = 0; i < (1 << k); i++)\n        for (int j = 0; j < k; j++) dp[i][j] = 1e9;\n    for (int i = 0; i < k; i++) dp[1 << i][i] = 1;\n    for (int s = 1; s < (1 << k); s++)\n        if (__builtin_popcount(s) != 1)\n            for (int i = 0; i < k; i++) {\n                if ((s >> i) & 1)\n                    for (int j = 0; j < k; j++)\n                        if ((s >> j) & 1)\n                            dp[s][i] =\n                                min(dp[s][i], dp[s ^ (1 << i)][j] + dis[i][j]);\n            }\n    int ans = 1e9;\n    for (int i = 0; i < k; i++) ans = min(ans, dp[(1 << k) - 1][i]);\n    cout << (ans == 1e9 ? -1 : ans);\n    return 0;\n}\n```\n\n# F Shift and Inversions\n## Description\n[题目链接](https://atcoder.jp/contests/abc190/tasks/abc190_f)\n## Solution\n初始序列的答案即为数列中逆序对个数，而每把一个数 $a_i$ 移到数列最后，答案就会加上 $2*\\sum \\limits_{i \\neq j}[a_j>a_i]-n+1$。用值域线段树或树状数组可实现对 $\\sum \\limits_{i \\neq j}[a_j>a_i]$ 的快速求解。\n## Code\n```cpp Shift and Inversions\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 3E5 + 5;\nconst int MOD = 1E9 + 7;\n\nint n, a[MAXN];\n\nstruct BIT {  // Binary Index Trees, 1based\n    int lowbit(int x) { return x & (~x + 1); }\n    /* O(n) build tree*/\n    BIT() {\n        for (int i = 1; i <= n; i++) c[i] = 0;\n    }\n    void build() {\n        for (int i = 1; i <= n; i++) {\n            int j = i + lowbit(i);  // j is father of i\n            if (j <= n) c[j] += c[i];\n        }\n    }\n    /*@param x the position to add val*/\n    void add(int x, LL val) {\n        while (x <= n) c[x] += val, x += lowbit(x);\n    }\n    /*range [1, x] sum query*/\n    LL query(int x, LL res = 0) {\n        while (x) res += c[x], x -= lowbit(x);\n        return res;\n    }\n    array<LL, MAXN> c;\n} bit[3];\n/*range [l, r] add val*/\ninline void add(int l, int r, LL val) {\n    if (l > r) return;\n    bit[1].add(l, val), bit[1].add(r + 1, -val);\n    bit[2].add(l, val * l), bit[2].add(r + 1, -val * (r + 1));\n}\n/*range [l, r] sum query*/\ninline LL query(int l, int r, LL res = 0) {\n    if (l > r) return 0;\n    res = bit[0].query(r) + bit[1].query(r) * (r + 1) - bit[2].query(r);\n    res -= bit[0].query(l - 1) + bit[1].query(l - 1) * l - bit[2].query(l - 1);\n    return res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    LL ans = 0;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        a[i]++;\n        ans += query(a[i] + 1, n);\n        add(a[i], a[i], 1);\n    }\n    cout << ans << \"\\n\";\n    for (int i = 1; i <= n - 1; i++) {\n        ans += 2 * query(a[i] + 1, n) - n + 1;\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```","tags":["动态规划","状压DP","contest","树状数组"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 187","url":"/2021/01/31/atcoder-abc-187/","content":"[比赛链接](https://atcoder.jp/contests/abc187)\n<!-- more -->\n# D Choose Me\n## Description\n[题目链接](https://atcoder.jp/contests/abc187/tasks/abc187_d)\n## Solution\n记 $Takahashi$ 和 $Aoki$ 的选票数差为 $\\Delta$。如果 $Takahashi$ 不在任何城市演讲，则 $\\Delta = -\\sum A_i$。假设 $Takahashi$ 在城市 $i$ 演讲，则 $\\Delta$ 会增大 $2A_i+B_i$。题目要求选择最少的城市使 $\\Delta>0$，因此只需要对城市按 $2A_i+B_i$ 降序排列即可。\n## Code\n```cpp Choose Me\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, T;\nLL pre[MAXN], pos[MAXN];\n\nstruct City {\n    LL a, b, c;\n    friend bool operator<(const City& a, const City& b) {\n        return 2 * a.a + a.b > 2 * b.a + b.b;\n    }\n} ct[MAXN];\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\nsigned main() {\n    read(n);\n    for (int i = 1; i <= n; i++)\n        read(ct[i].a, ct[i].b), ct[i].c = ct[i].a + ct[i].b;\n    sort(ct + 1, ct + n + 1);\n    for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + ct[i].c;\n    for (int i = n; i >= 1; i--) pos[i] = pos[i + 1] + ct[i].a;\n    for (int i = 1; i <= n; i++)\n        if (pre[i] > pos[i + 1]) {\n            cout << i;\n            break;\n        }\n    return 0;\n}\n```\n\n\n# E Through Path\n## Description\n[题目链接](https://atcoder.jp/contests/abc187/tasks/abc187_e)\n## Solution\n设节点 $a$ 深度大于节点 $b$，那么对于第二种操作，相当于对树上所有节点加上 $x$，将 $a$ 的子树中所有节点减去 $x$；对于第一种操作，只需要将 $a$ 的子树中所有节点加上 $x$ 即可。对于子树修改，可以考虑使用 $dfs$ 序加树状数组。由于本题无动态查询，因此只需要在树上进行差分，最后再跑一遍 $dfs$ 统计答案。\n## Code\n```cpp Through Path\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nint n, m, q, T;\nvector<int> G[MAXN];\narray<int, MAXN> in, out, depth;\nLL tot;\n\nstruct Edge {\n    int a, b;\n} e[MAXN];\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\nstruct BIT {  // Binary Index Trees, 1based\n    int lowbit(int x) { return x & (~x + 1); }\n    /* O(n) build tree*/\n    BIT() {\n        for (int i = 1; i <= n; i++) c[i] = 0;\n    }\n    void build() {\n        for (int i = 1; i <= n; i++) {\n            int j = i + lowbit(i);  // j is father of i\n            if (j <= n) c[j] += c[i];\n        }\n    }\n    /*@param x the position to add val*/\n    void add(int x, LL val) {\n        while (x <= n) c[x] += val, x += lowbit(x);\n    }\n    /*range [1, x] sum query*/\n    LL query(int x, LL res = 0) {\n        while (x) res += c[x], x -= lowbit(x);\n        return res;\n    }\n    array<LL, MAXN> c;\n} bit[3];\n/*range [l, r] add val*/\ninline void add(int l, int r, LL val) {\n    bit[1].add(l, val), bit[1].add(r + 1, -val);\n    bit[2].add(l, val * l), bit[2].add(r + 1, -val * (r + 1));\n}\n/*range [l, r] sum query*/\ninline LL query(int l, int r, LL res = 0) {\n    res = bit[0].query(r) + bit[1].query(r) * (r + 1) - bit[2].query(r);\n    res -= bit[0].query(l - 1) + bit[1].query(l - 1) * l - bit[2].query(l - 1);\n    return res;\n}\n\nvoid dfs(int now, int fa) {\n    static int times = 1;\n    depth[now] = depth[fa] + 1, in[now] = times++;\n    for (auto& to : G[now]) {\n        if (to != fa) dfs(to, now);\n    }\n    out[now] = times;\n}\n\nsigned main() {\n    read(n);\n    for (int i = 1; i <= n - 1; i++) {\n        read(e[i].a, e[i].b);\n        G[e[i].a].push_back(e[i].b);\n        G[e[i].b].push_back(e[i].a);\n    }\n    dfs(1, 1);\n    read(q);\n    for (int i = 1; i <= q; i++) {\n        int type, ei, x;\n        read(type, ei, x);\n        if (type == 1) {\n            if (depth[e[ei].a] > depth[e[ei].b])\n                add(in[e[ei].a], out[e[ei].a] - 1, x);\n            else {\n                tot += x;\n                add(in[e[ei].b], out[e[ei].b] - 1, -x);\n            }\n        } else {\n            if (depth[e[ei].a] < depth[e[ei].b])\n                add(in[e[ei].b], out[e[ei].b] - 1, x);\n            else {\n                tot += x;\n                add(in[e[ei].a], out[e[ei].a] - 1, -x);\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) printf(\"%lld\\n\", query(in[i], in[i]) + tot);\n    return 0;\n}\n```\n\n# F Close Group\n## Description\n[题目链接](https://atcoder.jp/contests/abc187/tasks/abc187_f)\n## Solution\n设 $dp[i]$ 表示点集为 $i$ 时的答案。设当前点集为 $S$，若这些点能构成完全图，那么答案显然为 $1$；否则，可以将点集 $S$ 可以分为两个非空真子集，于是有 $dp[S] = \\min \\limits_{T⊂S}{dp[T]+dp[S-T]}$。因此对于每个集合，二进制枚举其非空真子集即可。由二项式定理可证枚举非空真子集的时间复杂度为 $O(3^N)$，而对于每个点集，判断其能否构成完全图的时间复杂度为 $O(N^2)，$因此总的时间复杂度为 $O(N^22^N+3^N)$。\n\n## Code\n```cpp Close Group\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = (1 << 18);\nint n, m;\nbool e[18][18], good[MAXN];\nint dp[MAXN];\n\nbool check(int x) {\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            if (j != i)\n                if (((x >> i) & 1) && ((x >> j) & 1) && !e[i][j])\n                    return false;\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        e[a][b] = e[b][a] = 1;\n    }\n    memset(dp, 0x3f3f3f3f, sizeof(dp));\n    dp[0] = 0;\n    for (int i = 1; i < (1 << n); i++)\n        if (check(i)) good[i] = 1, dp[i] = 1;\n    for (int i = 1; i < (1 << n); i++) {\n        if (good[i]) continue;\n        for (int j = i; j; j = (j - 1) & i)\n            dp[i] = min(dp[i], dp[j] + dp[i ^ j]);\n    }\n    cout << dp[(1 << n) - 1];\n    return 0;\n}\n```","tags":["contest"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 184","url":"/2020/11/24/atcoder-abc-184/","content":"[比赛链接](https://atcoder.jp/contests/abc184)\n<!-- more -->\n# C Super Ryuma\n## Description\n[题目链接](https://atcoder.jp/contests/abc184/tasks/abc184_c)\n## Solution\n观察可得最多移动三次即可从起点到终点。\n分情况讨论：\n  - 起点和终点重合，总步数为 0\n  - 共对角线或者曼哈顿距离不超过 3，总步数为 1\n  - 走两次对角线，即与起点曼哈顿距离为偶数，总步数为 2\n  - 起点的近邻点，即与起点曼哈顿距离不超过 6，总步数为 2\n  - 与对角线的距离曼哈顿距离不超过 3，总步数为 2\n  - 其它情况，总步数为 3\n## Code\n```cpp Super Ryuma\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nint a, b, c, d;\n\nsigned main() {\n    cin >> a >> b >> c >> d;\n    if (a == c && b == d) cout << 0 << endl;\n    else if (a + b == c + d || a - b == c - d || (abs(a - c) + abs(b - d) <= 3)) {\n        cout << 1 << endl;\n    } else if ((abs(a - c) + abs(b - d)) & 1){\n        if (abs(a + b - c - d) <= 3) cout << 2 << endl;\n        else if (abs(a - b - c + d) <= 3) cout << 2 << endl;\n        else if (abs(a - c) + abs(b - d) <= 6) cout << 2 << endl;\n        else cout << 3 << endl;\n    } else cout << 2 << endl;\n    return 0;\n}\n```\n\n# D increment of coins\n## Description\n[题目链接](https://atcoder.jp/contests/abc184/tasks/abc184_d)\n## Solution\n解法一：动态规划逆推\n  问题相当于\n## Code\n```cpp increment of coins\n\n```\n\n# E Valid payments\n## Description\n[题目链接](https://atcoder.jp/contests/abc184/tasks/abc184_e)\n## Solution\n\n## Code\n```cpp Valid payments\n\n```\n# F Valid payments\n## Description\n[题目链接](https://atcoder.jp/contests/abc184/tasks/abc184_f)\n## Solution\n\n## Code\n```cpp Valid payments\n\n```\n\n","tags":["contest"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 182","url":"/2020/11/13/atcoder-abc-182/","content":"[比赛链接](https://atcoder.jp/contests/abc182)\n<!-- more -->\n# D Wandering\n## Description\n[题目链接](https://atcoder.jp/contests/abc182/tasks/abc182_d)\n## Solution\n设当前是第 $i$ 次行动，第 $i-1$ 次行动后完成后位置为 $p$, 那么第 $i$ 次行动中能抵达的最大位置是 $p+\\max\\limits_{1 \\le j \\le i}{\\sum\\limits_{k=1}^{j}a[k]}$，因此记录前缀和和前缀最大值即可。时间复杂度 $O(n)$。\n## Code\n```cpp Wandering\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 1E9 + 7;\nLL n, m, a[MAXN], sum[MAXN], last, mx[MAXN];\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\nsigned main() {\n    read(n);\n    LL ans = 0;\n    for (int i = 1; i <= n; i++) mx[i] = -1e18;\n    for (int i = 1; i <= n; i++) {\n        read(a[i]);\n        sum[i] = sum[i - 1] + a[i];\n        mx[i] = max(mx[i - 1], sum[i]);\n        ans = max(ans, mx[i] + last);\n        last = last + sum[i];\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n# E Akari\n## Description\n[题目链接](https://atcoder.jp/contests/abc182/tasks/abc182_e)\n## Solution\n对于 $N$ 个 $bulb$，如果仅向四个方向搜索，直到遇到边界或 $block$ 为止，最后统计被照亮的区域，那么由于每次最多访问 $(H + W)$ 个格子，时间复杂度为 $N * (H + W)$。\n\n上述操作过程中 $bulb$ 之间的区域会被访问多次。如果搜索时遇到其它 $bulb$ 即停止，两个 $bulb$ 之间的区域只会被访问 2 次。时间复杂度 $O(HW)$。\n## Code\n```cpp Akari\n#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 2e3 + 3, MOD = 1e9 + 7;\n\nint h, w, a, b, g[MAXN][MAXN], bulb[MAXN][MAXN], block[MAXN][MAXN], ans;\nbool vis[MAXN][MAXN], light[MAXN][MAXN];\n\nvoid dfs(int x, int y, int dx, int dy) {\n    if (block[x][y]) return;\n    if (x < 1 || x > h || y < 1 || y > w) return;\n    light[x][y] = true;\n    if (bulb[x + dx][y + dy]) return;\n    dfs(x + dx, y + dy, dx, dy);\n}\n \nint main() {\n    boost;\n    cin >> h >> w;\n    cin >> a >> b;\n    for (int i = 1; i <= a; i++) {\n        int u, v;\n        cin >> u >> v;\n        bulb[u][v] = 1;\n    }\n    for (int i = 1; i <= b; i++) {\n        int u, v;\n        cin >> u >> v;\n        block[u][v] = 1;\n    }\n    for (int i = 1; i <= h; i++)\n        for (int j = 1; j <= w; j++)\n            if (bulb[i][j]) {\n                dfs(i, j, 0, 1);\n                dfs(i, j, 0, -1);\n                dfs(i, j, -1, 0);\n                dfs(i, j, 1, 0);\n            }\n    for (int i = 1; i <= h; i++)\n        for (int j = 1; j <= w; j++)\n            if (light[i][j]) ans++;\n    cout << ans << endl;\n    return 0;\n}\n```\n\n# F Valid payments\n## Description\n[题目链接](https://atcoder.jp/contests/abc182/tasks/abc182_f)\n## Solution\n首先，由于收付款过程中使用货币种类最少，因此任意金额都可以通过尽可能先支付面值大的货币来唯一表示。同时，对于货币 $i$, 有 $cnt_i <  \\frac{a_{i+1}}{a_i}$，否则产生进位，用 1 个 $a_{i+1}$ 面值的货币比用 $\\frac{a_{i+1}}{a_i}$ 个 $a_i$ 面值的货币更优。\n\n题目问付款的方案数，等价于求找零的方案数。将 $X$ 按上述方法唯一分解后，设第 $i$ 种货币用了 $g_i$ 个，同时第 $i$ 种货币使用次数得上限为 $lim_i = \\frac{a_{i+1}}{a_i} - 1$。由于找零和支付不能使用同一种货币，因此对于某一种货币 $i$, 要么不找，要么找 $lim_i-g_i$ （$g_i \\neq 0$）个产生进位将这种货币消去使得支付时不会用这种货币。于是，容易想到设 $dp[i][0]$ 表示在第 $i$ 到第 $n-1$ 位中至少选了 1 位，第 $i$ 位没有得到来自上一位 (第 $i-1$ 位) 进位的方案数，$dp[i][0]$ 表示获得了上一位进位的方案数。接下来分三种情况讨论：\n\n- $g_i = 0$ : 如果上一位没有进位，此时一定不选第 $i$ 位，下一位也不会有进位，有 $dp[i][0] = dp[i+1][0]$; 否则，有三种选择：\n    - 不选第 $i$ 位，下一位不产生进位，有 $dp[i+1][0]$ 种方案。\n    - 只选第 $i$ 位，有 1 种方案。\n    - 选了第 $i$ 位，下一位产生进位，在第 $i+1$ 到 $n-1$ 位至少选一位，有 $dp[i+1][1]$ 种方案。 \n\n- $g_i = lim_i - 1$ ：若上一位产生进位，则这一位直接被消去，在下一位产生进位，此时有 $dp[i][1] = dp[i+1][1]$。否则，有三种选择：\n    - 不选第 $i$ 位，有 $dp[i+1][0]$ 种方案。\n    - 只选第 $i$ 位，有 1 种方案。\n    - 选了第 $i$ 位，下一位产生进位，在第 $i+1$ 到 $n-1$ 位至少选一位，有 $dp[i+1][1]$ 种方案。\n\n- $1 < g_i < lim_i - 1$：不论上一位有没有进位，都有三种选择：\n    - 不选第 $i$ 位，有 $dp[i+1][0]$ 种方案。\n    - 只选第 $i$ 位，有 1 种方案。\n    - 选了第 $i$ 位，下一位产生进位，在第 $i+1$ 到 $n-1$ 位至少选一位，有 $dp[i+1][1]$ 种方案。\n\n最后答案为 $dp[1][0]+1$，即至少选一位加上直接支付 $X$ 元不找零的方案数。时间复杂度 $O(n)$。\n## Code\n```cpp Valid payments\n#include <bits/stdc++.h>\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 55;\nconst int MOD = 1E9 + 7;\nLL n, x, a[MAXN], g[MAXN], dp[MAXN][2];\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\nsigned main() {\n    read(n, x);\n    for (int i = 1; i <= n; i++) read(a[i]);\n    for (int i = n; i >= 1; i--) {\n        if (!x) break;\n        g[i] = x / a[i], x %= a[i];\n    }\n    for (int i = n - 1; i >= 1; i--) {\n        LL lim = a[i + 1] / a[i];\n        if (g[i] == 0) {\n            dp[i][0] = dp[i + 1][0];\n            dp[i][1] = dp[i + 1][1] + dp[i + 1][0] + 1;\n        } else if (g[i] == lim - 1) {\n            dp[i][0] = dp[i + 1][0] + dp[i + 1][1] + 1;\n            dp[i][1] = dp[i + 1][1];\n        } else {\n            dp[i][1] = dp[i + 1][1] + dp[i + 1][0] + 1;\n            dp[i][0] = dp[i + 1][0] + dp[i + 1][1] + 1;\n        }\n    }\n    cout << dp[1][0] + 1;\n    return 0;\n}\n```\n","tags":["contest"],"categories":["contest"]},{"title":"Codeforces Round 679 Div2, based on Technocup 2021 Elimination Round 1","url":"/2020/11/01/cf-679-div2/","content":"[比赛链接](https://codeforces.ml/contest/1435)\n<!-- more -->\n# C - Perform Easily\n## Description\n[题目链接](https://codeforces.ml/contest/1435/problem/C)\n## Solution\n对于每一个 $b_i$，将 $<b_i - a[j], i>(1 \\le j \\le 6)$ 求出并按第一关键字排序。\n\n遍历排序后的二元组，对于当前二元组 $i$，向右找到第一个 $j$ 使得它们之间二元组的第二关键字有 $n$ 种，那么这样的 $i$、$j$ 的第一关键字对应的区间可以被计入答案。\n\n由于 $i$ 单增时 $j$ 也是单增的，故可用双指针扫描。判断第二关键字是否有 $n$ 种可用 ``map<int, int> cnt`` 获取 ``size()`` 来实现，当一个数的 $cnt$ 变为 0 时，将其从 $map$ 中 ``erase`` 即可 (似乎只用数组就够了)。\n## Code\n```cpp Perform Easily\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e5 + 5, MOD = 1e9 + 7;\n\nint n, ans = 1e9;\narray<int, 7> a;\narray<int, MAXN> b;\n\nvector<pair<int, int>> vec;\nunordered_map<int, int> cnt;\n\nint main() {\n    boost;\n    for (int i = 1; i <= 6; i++) cin >> a[i];\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> b[i];\n        for (int j = 1; j <= 6; j++) vec.push_back({b[i] - a[j], i});\n    }\n    sort(vec.begin(), vec.end());\n\n    int r = 0;\n    for (int l = 0; l < vec.size(); l++) {\n        if (cnt.size() < n && r + 1 == vec.size()) break;\n        while (cnt.size() < n && r < vec.size()) {\n            cnt[vec[r].second]++;\n            r++;\n        }\n\n        if (cnt.size() == n)\n            ans = min(ans, vec[r - 1].first - vec[l].first);\n\n        cnt[vec[l].second]--;\n        if (!cnt[vec[l].second]) cnt.erase(vec[l].second);\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n# D - Shurikens\n## Description\n[题目链接](https://codeforces.ml/contest/1435/problem/D)\n## Solution\n按事件发生的相反顺序考虑。由于每次拿走的 $shuriken$ 的价格是最小的，故遇到 '-' 事件时，将对应价格插入 $MinHeap$；否则从 $MinHeap$ 中弹出堆顶元素并压入栈，那么剩下的元素一定在这个事件发生之前就有了。\n\n不合法情况：当前事件为 '+' 且堆为空；或者当前事件为 '-'，对应的价格大于堆顶元素 (也就是拿走的价格不是最小的)。\n\n最后输出栈中元素即可。\n## Code\n```cpp Shurikens\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 2e5 + 5, MOD = 1e9 + 7;\n\nint n, val[MAXN];\nstack<int> ans;\nchar type[MAXN];\npriority_queue<int, vector<int>, greater<int>> q;\n\nint main() {\n    boost;\n    cin >> n;\n    for (int i = 1; i <= 2 * n; i++) {\n       cin >> type[i];\n       if (type[i] == '-') cin >> val[i];\n    }\n\n    for (int i = 2 * n; i; i--) {\n        if (type[i] == '+') {\n            if (q.empty()) {\n                cout << \"NO\\n\";\n                return 0;\n            }\n            ans.push(q.top());\n            q.pop();\n        } else {\n            if (q.empty()) {\n                q.push(val[i]);\n                continue;\n            }\n            if (val[i] > q.top()) {\n                cout << \"NO\\n\";\n                return 0;\n            }\n            q.push(val[i]);\n        }\n    }\n    cout << \"YES\\n\";\n    while (!ans.empty()) {\n        cout << ans.top() << \" \";\n        ans.pop();\n    }\n    return 0;\n}\n```\n\n# E - Solo mid Oracle\n## Description\n[题目链接](https://codeforces.ml/contest/1435/problem/E)\n## Solution\n首先如果 $a > b * c$，那么无论生命值为多少都可以击杀。\n\n然后画图分析可得，设初始生命值为 $st$，第 $x$ 次使用技能，则使用技能时的血量为 $st - a * (x + 1) + x * (x + 1) / 2 * b * d$。\n\n当 $x > \\frac{c}{d}$ 时，不会出现比 $x <= \\frac{c}{d}$ 中更小的结果。故只需考虑 $0 \\le x \\le \\frac{c}{d}$，然后对单谷函数三分求极值即可。\n## Code\n```cpp Solo mid Oracle\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n#define boost ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\nconstexpr int MAXN = 1e5 + 5, MOD = 1e9 + 7;\n\nint tc, a, b, c, d;\n\ninline int f(int x) {\n    return -a * (x + 1) + x * (x + 1) / 2 * b * d;\n}\n\ninline void tripartition() {\n    int l = 0, r = c / d, ans = 1e18;\n    while (r - l >= 3) {\n        int lmid = (l + l + r) / 3;\n        int rmid = (l + r + r) / 3;\n        int lval = f(lmid), rval = f(rmid);\n        if (lval < rval) r = rmid;\n        else l = lmid;\n    }\n    for (int i = l; i <= r; i++) {\n        ans = min(ans, f(i));\n    }\n    cout << -ans << \"\\n\";\n}\n\nsigned main() {\n    boost;\n    cin >> tc;\n    while (tc--) {\n        cin >> a >> b >> c >> d;\n        if (a > b * c) cout << -1 << \"\\n\";\n        else tripartition();\n    }\n    return 0;\n}\n```\n","tags":["contest"],"categories":["contest"]},{"title":"Codeforces Round 411 Div2","url":"/2020/10/24/cf-411-div2/","content":"[比赛链接](https://codeforces.ml/contest/805)\n<!-- more -->\n# D - Minimum number of steps\n## Description\n将只含 $a$、$b$的字符串中的 $ab$ 全部替换为 $bba$ 需要多少次操作\n## Solution\n字符串最终会变为 $bbbb....aaa....$。将 $ab$ 替换为 $bba$ 后 $a$ 的个数不变，前面的结果对后面没有影响，所以 $b$ 前有多少 $a$ 就要操作 $2^{num_a} - 1$ 次。\n## Code\n```cpp Minimum number of steps\nusing namespace std;\n\n#define LL long long\n#define MOD 1000000000 + 7\n\nchar str[1000005];\n\nint main() {\n    while (~scanf(\"%s\", str)) {\n        LL ans = 0, x = 1;\n        for (int i = 0; str[i] != '\\0'; i++) {\n            if (str[i] == 'a') {\n                x *= 2;\n                x %= MOD;\n            } else {\n                ans += x - 1;\n                ans %= MOD;\n            }\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n```\n\n# E - Ice cream coloring\n## Description\n[题目链接](https://codeforces.ml/contest/805/problem/E)\n## Solution\n首先按照题意，同一个节点上的 $ice cream$ 构成完全图，它们必须染上不同的颜色。注意题目中有这样一句话：\"Vertices which have the i-th (1 ≤ i ≤ m) type of ice cream form a connected subgraph\"，也就是说对于树上的一个节点 $u$，与其相邻的节点才有和它相同的 $ice cream$，否则会产生环，那么树上 $dfs$ 染色不会产生染色冲突。\n如何染色：对于一个树上节点，从 1 开始将这个节点上的 $ice cream$ 染色，如果某种类型的 $ice cream$ 被染过色则跳过(可用 $std::set$ 等判断)。最后没有被染色的 $ice cream$ 的颜色都赋为 1。\n## Code\n```cpp Ice cream coloring\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 3e5 + 5;\n\nint n, m, c[MAXN], cnt = 1;\nvector<int> G[MAXN], s[MAXN];\n\nvoid dfs(int cur, int fa) {\n    int color = 1;\n\n    set<int> tmp;\n    for (auto& i : s[cur])\n        if (c[i]) tmp.insert(c[i]);\n    \n    for (auto& i : s[cur]) {\n        if (c[i]) continue;\n        while (tmp.count(color)) color++;\n        c[i] = color++;\n        cnt = max(cnt, c[i]);\n    }\n\n    for (auto& to : G[cur]) {\n        if (to == fa) continue;\n        dfs(to, cur);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        int sz;\n        cin >> sz;\n        for (int j = 1; j <= sz; j++) {\n            int tmp;\n            cin >> tmp;\n            s[i].push_back(tmp);\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        cin >> u >> v;\n        G[u].push_back(v), G[v].push_back(u);\n    }\n    dfs(1, 0);\n    for (int i = 1; i <= m; i++)\n        if (!c[i]) c[i] = 1;\n    cout << cnt << \"\\n\";\n    for (int i = 1; i <= m; i++) cout << c[i] << \" \";\n    return 0;\n}\n```\n\n# F - Expected diameter of a tree\n## Description\n给出一个森林，m 次询问，每次给出节点 $a$, $b$，将 $a$ 所在的树与 $b$ 所在的树连一条边，求连接后的树的直径的期望(每次操作相互独立)。\n## Solution\n先预处理出每个点属于哪一棵树，每棵树的 $size$、直径，以及树上每个点到最远点的距离 (可以证明，树上一点的最远点一定是树的直径的端点)。\n\n可以二次 $dfs$ 求出树的直径和端点，再从端点出发，求出到每一点的最远距离 $dis[]$。\n\n然后枚举 $a$ 所在树的点 $i$，二分 $b$ 所在树的点 $j$，求出 $dis_i + dis_j + 1 > max(diameter_{belong_i}, diameter_{belong_j})$ (需要提前将 $dis[]$ 排序)。\n\n然后小于 $j$ 的部分，树的直径都是 $max(diameter_{belong_i}, diameter_{belong_j})$，剩余部分的直径和通过前缀和求出 (前缀和需要 $dis[]$ 排序后预处理)。\n\n但这样的时间复杂度为 $O(nmlog_n)$，可用 $map$ 记忆化，时间复杂度 $O(m\\sqrt{n}log_n)$ (按两个块中小的那一个块的大小大于 $\\sqrt{n}$ 和 小于 $\\sqrt{n}$ 讨论一下即可)。\n\n## Code\n```cpp Expected diameter of a tree\n#include <bits/stdc++.h>\n \nusing namespace std;\n \nconstexpr int MAXN = 3e5 + 5;\n \nint n, m, q, diameter;\narray<int, MAXN> sz, belong, dis, dia;\nvector<int> G[MAXN], vec[MAXN];\nvector<long long> sum[MAXN];\n\nvoid dfs1(int cur, int fa, int& p) { //二次 dfs 求直径 p 是端点\n    for (auto& to : G[cur]) {\n        if (to == fa) continue;\n        dis[to] = dis[cur] + 1;\n        if (dis[to] > diameter) diameter = dis[to], p = to;\n        dfs1(to, cur, p);\n    }\n}\n \nvoid dfs2(int cur, int fa, int tot) { //求树的 sz，以及每个节点属于哪一棵树\n    sz[tot]++, belong[cur] = tot;\n    for (auto& to : G[cur]) {\n        if (to == fa) continue;\n        dfs2(to, cur, tot);\n    }\n}\n \nvoid dfs3(int cur, int fa, int d) { //求点到最远点的距离\n    dis[cur] = max(dis[cur], d);\n    for (auto& to : G[cur]) {\n        if (to == fa) continue;\n        dfs3(to, cur, d + 1);\n    }\n}\n \nmap<pair<int, int>, double> mp;\nvoid query(int u, int v) {\n    if (u == v) {\n        cout << \"-1\\n\";\n        return;\n    }\n    if (sz[u] > sz[v]) swap(u, v);\n \n    if (mp.count({u, v})) {\n        cout << mp[{u, v}] << \"\\n\";\n        return;\n    }\n    double res = 0;\n    int tmp = max(dia[u], dia[v]);\n    for (auto& i : vec[u]) {\n        int pos = upper_bound(vec[v].begin(), vec[v].end(), tmp - 1 - i) - vec[v].begin();\n        res += 1LL * tmp * pos;\n        res += 1LL * (i + 1) * (sum[v].size() - pos);\n        res += sum[v][sum[v].size() - 1] - (pos ? sum[v][pos - 1] : 0);\n    }\n    res /= 1LL * sz[u] * sz[v];\n    cout << (mp[{u, v}] = res) << \"\\n\";\n}\n \nvoid init() {\n    int tot = 0;\n    for (int i = 1; i <= n; i++) {\n        if (!belong[i]) {\n            int st = i, ed = i;\n            diameter = 0, dis[i] = 0, dfs1(i, 0, st);\n            diameter = 0, dis[st] = 0, dfs1(st, 0, ed);\n            dfs2(i, 0, ++tot), dia[tot] = diameter;\n            dfs3(st, 0, 0), dfs3(ed, 0, 0); //预处理出直径、dis\n        }\n    }\n    for (int i = 1; i <= n; i++) vec[belong[i]].push_back(dis[i]);\n    for (int i = 1; i <= tot; i++) { //排序求前缀和\n        sort(vec[i].begin(), vec[i].end());\n        sum[i].resize(vec[i].size());\n        sum[i][0] = vec[i][0];\n        for (int j = 1; j < vec[i].size(); j++)\n            sum[i][j] = sum[i][j - 1] + vec[i][j];\n    }\n}\n \nint main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << setprecision(6) << fixed;\n    cin >> n >> m >> q;\n    for (int i = 1, u, v; i <= m; i++) {\n        cin >> u >> v;\n        G[u].push_back(v), G[v].push_back(u);\n    }\n    init();\n    for (int i = 1, u, v; i <= q; i++) {\n        cin >> u >> v;\n        query(belong[u], belong[v]);\n    }\n    return 0;\n}\n```\n","tags":["contest"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 180","url":"/2020/10/23/atcoder-abc-180/","content":"\n[比赛链接](https://atcoder.jp/contests/abc180)\n<!-- more -->\n# F Unbranched\n## Description\n$n$ 个**不同的点** $m$ 条边构成一张图，满足图中每个连通块要么是环（无自环），要么是链，且最大的联通块的大小恰好为 $l$，问这样的图有多少个。\n## Solution\n先考虑这样一个问题：\n- 求将 $\\left\\{ 1,2,...,n \\right\\}$ 分组，每组不空的方案数。\n\n这个问题可以用 $dp$ 求解。设 $dp[i]$ 表示将 $i$ 个数分组的方案数，那么有 $dp[i] = \\sum\\limits_{j=0}^{i-1}dp[j]*C_{i-1}^{i-1-j}$。这里可以理解为从前 $i-1$ 个数中选 $i-j-1$ 个数和 $i$ 凑成一组，再对剩下的 $j$ 个数分组。时间复杂度为 $O(n^2)$。\n\n<br/>\n\n进一步考虑：\n- 求将 $\\left\\{ 1,2,...,n \\right\\}$ 分组，最大的一组大小恰好为 $l$ ($1\\le l \\le n$) 的方案数。\n\n容易想到设 $dp[i][j]$ 表示将前 $i$ 个数分组，最大的一组大小恰为 $j$ 的方案数。那么有 $dp[i][max(sz,i-j)] = \\sum\\limits_{j=max(0,i-l)}^{i-1}dp[j][sz]*C_{i-1}^{i-1-j},sz ∈ [0,min(l,j)]$，最后答案为 $dp[n][l]$。该解法时间复杂度为 $O(n^3)$，可以优化。\n\n设 $dp[i][j]$ 表示将前 $i$ 个数分组，最大的一组大小不超过 $j$ 的方案数，易得状态转移方程 $dp[i][l] = \\sum\\limits_{j=max(0,i-l)}^{i-1}dp[j][l]*C_{i-1}^{i-1-j}$，那么让最大组大小恰为 $l$ 的方案数为 $dp[i][l]-dp[i][l-1]$。这里第二维实际上是多余的。设大小限制为 $k$, 那么 $dp[i] = \\sum\\limits_{j=max(0,i-k)}^{i-1}dp[j]*C_{i-1}^{i-1-j}$，因此对 $k=l$ 和 $k=l-1$ 的情况分别做一次 $dp$ 将答案相减即可。时间复杂度为 $O(n^2)$。\n\n<br/>\n\n回到本题，这题其实就是在前一个问题的基础上加上了边数限制和组内部的顺序问题。由于有 $m$ 条边，因此一定会构成 $n-m$ 条链（一个点也算链的情况），其余的都是大小至少为 2 的环。设 $dp[i][j]$ 表示将 $i$ 个点构成一个由 $j$ 条链组成，最大连通块大小不超过 $l$ 的图方案数。对于一个新的状态，要么增加一条链，要么增加一个环，同时还要乘上构成指定长度的链或环的方案数。其中，$n(n \\ge 2)$ 个不同的点构成一条链的方案数为 $n!/2$，$n(n \\ge 3)$ 个不同的点构成一个环的方案数为 $(n-1)!/2$。对于大小限制为 $l-1$ 的情况可类似处理，时间复杂度为 $O(n^3)$。\n\n## Code\n```cpp Unbranched\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 303;\nconst int MOD = 1E9 + 7;\nint n, m, l;\nLL dp[MAXN][MAXN], chainNum[MAXN], cycleNum[MAXN], C[MAXN][MAXN];\n\ntemplate <class T>\nvoid read(T& x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\ntemplate <class T, class... Args>\nvoid read(T& x, Args&... args) {\n    read(x), read(args...);\n}\n\nLL qpow(LL a, LL b, LL MOD) {\n    LL ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nvoid add(LL& a, LL b) { a = (a + b) % MOD; }\n\nvoid init() {\n    for (int i = 0; i <= 300; i++) C[i][0] = 1;\n    for (int i = 1; i <= 300; i++)\n        for (int j = 1; j <= i; j++)\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;\n    chainNum[1] = chainNum[2] = 1;\n    for (int i = 3; i <= 300; i++) chainNum[i] = chainNum[i - 1] * i % MOD;\n    cycleNum[2] = cycleNum[3] = 1;\n    for (int i = 4; i <= 300; i++)\n        cycleNum[i] = cycleNum[i - 1] * (i - 1) % MOD;\n}\n\nint solve(int n, int l, int m) {\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n        for (int p = i - l; p <= i - 1; p++) {\n            for (int chain = max(0, n - m - (n - p)); chain <= min(p, n - m);\n                 chain++) {//注意剩下 n - p 个点不可能构成超过 n - p 条链\n                add(dp[i][chain], dp[p][chain] * C[i - 1][i - p - 1] % MOD *\n                                      cycleNum[i - p] % MOD);\n                add(dp[i][chain + 1], dp[p][chain] * C[i - 1][i - p - 1] % MOD *\n                                          chainNum[i - p] % MOD);\n            }\n        }\n    return dp[n][n - m];\n}\n\nsigned main() {\n    init();\n    read(n, m, l);\n    cout << ((solve(n, l, m) - solve(n, l - 1, m)) % MOD + MOD) % MOD;\n    return 0;\n}\n```","tags":["动态规划","contest","图论"],"categories":["contest"]},{"title":"AtCoder Regular Contest 104","url":"/2020/10/10/atcoder-arc-104/","content":"[比赛链接](https://atcoder.jp/contests/arc104)\n<!-- more -->\n# B - DNA Sequence\n## Description\n给出一个长为 $N$ 的字符串，问 **A 的个数等于 T 的个数** 且 **C 的个数等于 G 的个数** 的子串有多少个。\n## Solution\n由于 $N \\le 5000$，因此可以 $N^2$ 枚举子串的左右端点，利用前缀和容易判断是否满足 $A=T∧C=G$。\n\n另外，这题可以利用 $map$ 优化，对每个位置记录前缀 $A$ 与 $T$ 的个数差 $x$、$C$ 与 $G$ 的个数差 $y$，那么以当前位置结尾的合法子串的开头减 1 处有相同的 $(x,y)$，所以每次在 $map$ 中查询二元组 $(x,y)$ 的数量即可。时间复杂度 $O(NlogN)$。\n\n## Code\n```cpp DNA Sequence\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring s;\nint ans, n;\nmap<pair<int, int>, int> mp;\n\nsigned main() {\n    cin >> n >> s;\n    mp[make_pair(0, 0)] = 1;\n    int x = 0, y = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'A')\n            x++;\n        else if (s[i] == 'T')\n            x--;\n        else if (s[i] == 'C')\n            y++;\n        else\n            y--;\n        ans += mp[make_pair(x, y)];\n        mp[make_pair(x, y)]++;\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n\n# C - Fair Elevator\n## Description\n1 个 $2N$ 层的建筑中有 $N$ 个人搭乘电梯，需要满足以下两个条件：\n- 设每个人上下电梯的楼层为 $A_i,B_i$，且 $A_1,B_1,A_2,B_2...A_N,B_N$ 互不相同。\n- 同一时刻在电梯中的人 $B_i-A_i$ 都相同。\n\n现给出 $A,B$ 数组，但其中有一部分信息丢失（用 -1 表示），且有可能存在错误信息，问补上丢失的信息后是否有可能满足上述条件。\n## Solution\n首先特判有重复楼层或者 $A_i>B_i(A_i,B_i \\neq -1)$ 的情况，这两种情况无解。\n\n设一个人在第 $x$ 层上，在 $x+k$ 层下，且在 $x$ 层时电梯中只有这一人，那么对 $\\forall v∈[x+1,x+k-1]$，都存在 $A_i=v ∧ B_i=A_i+k$，即楼层 $[x,x+2k-1]$ 的上下电梯情况都能被确定。\n\n由上述分析可知，存在合法情况当且仅当可以将楼层分成若干个长度为偶数（设为 $2k$ ）的段，每段满足恰有 $k$ 个人在这个段的前半部分的不同楼层上电梯，并在 $k$ 层之后下电梯。设 $dp[i]$ 表示前 $i$ 层（$i$ 为偶数）能否满足条件，枚举长度 $2k$，如果区间 $[i+1,i+2k]$ 合法且 $dp[i]=1$，那么 $dp[i+2k] =1$。最后如果 $dp[2n]=0$ 则无解。  \n\n上述状态转移的时间复杂度为 $O(n^3)$\n\n## Code\n```cpp Fair Elevator\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 105;\n\nint n, a[MAXN], b[MAXN];\nbool vis[MAXN * 2], dp[MAXN * 2];\n\nsigned main() {\n    cin >> n;\n    bool tag = 1;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i] >> b[i];\n        if (a[i] != -1) vis[a[i]] ? tag = 0 : vis[a[i]] = 1;\n        if (b[i] != -1) vis[b[i]] ? tag = 0 : vis[b[i]] = 1;\n        if (a[i] > b[i] && b[i] != -1) tag = 0;\n    }\n    if (!tag) return cout << \"No\", 0;\n    dp[0] = 1;\n    for (int i = 0; i <= 2 * n; i += 2) {\n        for (int len = 2; i + len <= 2 * n; len += 2) {\n            bool tag = 1;\n            int halflen = len / 2;\n            int f[MAXN * 2] = {0};\n            for (int j = 1; j <= n; j++) {\n                if (b[j] != -1) {\n                    if (i + 1 <= b[j] && b[j] <= i + halflen) {\n                        tag = 0;\n                        break;\n                    } else if (i + 1 + halflen <= b[j] && b[j] <= i + len) {\n                        if (f[b[j]] || f[b[j] - halflen]) {\n                            tag = 0;\n                            break;\n                        } else\n                            f[b[j]] = f[b[j] - halflen] = j;\n                    }\n                }\n                if (a[j] != -1) {\n                    if (i + 1 + halflen <= a[j] && a[j] <= i + len) {\n                        tag = 0;\n                        break;\n                    } else if (i + 1 <= a[j] && a[j] <= i + halflen) {\n                        if ((f[a[j]] && f[a[j]] != j) ||\n                            (f[a[j] + halflen] && f[a[j] + halflen] != j)) {\n                            tag = 0;\n                            break;\n                        } else\n                            f[a[j]] = f[a[j] + halflen] = j;\n                    }\n                }\n            }\n            if (dp[i] && tag) dp[i + len] = 1;\n        }\n    }\n    cout << (dp[2 * n] ? \"Yes\" : \"No\");\n    return 0;\n}\n```\n\n\n# D - Multiset Mean \n## Description\n求用 $1$ 到 $N$ 之间的数，每个数使用次数不超过 $K$，构成平均值为 $x(1 \\le x \\le N$) 的非空可重集的方案数。答案对 $M$ 取模。 \n## Solution\n设 $cnt_i$ 表示数 $i,i∈[1,N]$ 被选的次数，那么集合中数的平均值为 $x$ 等价于 $\\sum\\limits_{i=1}^{N}(i-x)cnt_i=0$。因此问题转变为从 $[1,x-1]$ 和 $[1,N-x]$ 这两个区间中分别选择一些数，每个数被选择次数不超过 $K$，使得从这两个区间中选出的数的和相等。\n\n设 $dp[i][s]$ 表示从 $[1,i]$ 选取一些数，每个数被选择次数不超过 $k$，且和为 $s$ 的方案数，那么使平均值为 $x$ 的方案数为 $\\sum\\limits_{s=0}^{MaxSum} k*dp[x-1][s]*dp[N-x][s]$。接下来考虑如何求 $dp[i][s]$。显然有 $dp[i][s]=\\sum\\limits_{j=0}^{k}dp[i-1][s-j*i]$。由于 $MaxSum$ 是 $n^2k$ 数量级的，直接枚举 $j$ 的话复杂度是 $O(n^3k^2)$的，时限 $4s$ 卡卡常还是能过的。注意到 $\\sum\\limits_{j=0}^{k}dp[i-1][s-j*i]$ 可用前缀和维护，因此不用枚举 $j$，从而时间复杂度降至 $O(n^3k)$。\n## Code\n```cpp Multiset Mean\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 101;\n\nint n, m;\nLL k, f[101][130005], sum[130005];\nLL ans[101];\n\nvoid add(LL& a, LL b) { a = ((a + b) % m + m) % m; }\n\nsigned main() {\n    cin >> n >> k >> m;\n    ans[1] = k;\n\n    f[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        memset(sum, 0, sizeof(sum));\n        int lim = min((n + 1) / 2 - 1, i);\n        lim = k * (1 + lim) * lim / 2;\n        for (int s = 0; s <= lim; s++)\n            add(sum[s], (s - i >= 0 ? sum[s - i] : 0) + f[i - 1][s]);\n        for (int s = 0; s <= lim; s++)\n            add(f[i][s],\n                sum[s] - (s - (k + 1) * i >= 0 ? sum[s - (k + 1) * i] : 0));\n    }\n\n    for (int x = 2; x <= (n + 1) / 2; x++) {\n        int lim = k * x * (x - 1) / 2;\n        for (int i = 1; i <= lim; i++)\n            add(ans[x], f[x - 1][i] * f[n - x][i] % m * (k + 1));\n        add(ans[x], k);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (i <= (n + 1) / 2)\n            cout << ans[i] << endl;\n        else\n            cout << ans[n - i + 1] << endl;\n    }\n    return 0;\n}\n\n```\n\n# E - Random LIS\n## Desciption\n$N$ 个数的序列，第 $i$ 个整数在 $[1,A_i]$ 间等概率随机选取，求该序列最长上升子序列长度的期望\n## Solution\n设 $cnt_i$ 表示使最长公共子序列的长度为 $i$ 的方案数，显然答案为 $\\frac{\\sum\\limits_{i=1}^{N}cnt_i*i}{\\prod\\limits_{i=1}^{N}A_i}$。\n\n对于分子，我们可以 $O(N^N)$ 暴搜处理 $N$ 个数的相对大小关系（$N \\le 6$ 时不同的相对大小关系不超过 4683 个），根据相对大小关系容易求得最长上升子序列的长度，接下来只需考虑求构成该相对大小关系的方案数。\n\n设相对大小最大为 $k$, 第 $i$ 个数相对大小为 $r_i$， $lim_r$ 表示相对大小为 $r$ 的数能取到的最大值，则 $lim_i = \\min\\limits_{r_j=i}A_j$。现在问题转化成求长度为 $k$, 且 $val_i \\le lim_i(1 \\le i \\le k)$ 的严格上升序列的个数。这是一个经典问题，可以用动态规划求解。\n\n具体的，将 $lim$ 按值域分成 $m$ 段，每段的右端点对应一个 $lim$ 值，同时设 $lim_i$ 属于第 $seg_i$ 段（$seg_0=0$）。设 $dp[i][j]$ 表示将前 $i$ 项构成严格上升序列，最后某几项选择的值属于第 $j$ 段的方案数。显然答案为 $\\sum\\limits_{i=1}^{seg_k}dp[k][i]$, 且有 $dp[0][0]=1$。接下来考虑状态转移，易得 $dp[i][j]=\\sum\\limits_{p=0}^{i-1}\\sum\\limits_{q=0}^{min(seg_p,j-1)}dp[p][q]*C_{len_j}^{i-p}$，这里需要满足 $\\forall p'∈[p+1,i],seg_{p'}>=j$。直接转移的话时间复杂度为 $O(N^4)$，本题数据小可以通过。另外，我们可以通过对第二维记录前缀和将时间复杂度降至 $O(N^3)$，代码中 $dp[i][j]$ 表示将前 $i$ 项构成严格上升序列，最后某几项选择的值不超过第 $j$ 段的方案数。\n\n\n## Code\n```cpp Random LIS\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconst int MOD = 1E9 + 7;\nint n, a[7], x[7];\nint tot(1), ans(0);\nbool vis[654325];\n\nint qpow(int a, int b) {\n    int ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nvoid add(int& a, int b) { a = (a + b) % MOD; }\n\nint getLIS(int* rank) {\n    int f[7] = {0}, len = 0;\n    for (int i = 1; i <= n; i++) {\n        int id = lower_bound(f + 1, f + len + 1, rank[i]) - f;\n        f[id] = rank[i];\n        len = max(len, id);\n    }\n    return len;\n}\n\nint Comb(int n, int m) {\n    if (n < m) return 0;\n    int num = 1, dem = 1;\n    for (int i = n - m + 1; i <= n; i++) num = (num * i) % MOD;\n    for (int i = 1; i <= m; i++) dem = (dem * i) % MOD;\n    return num * qpow(dem, MOD - 2) % MOD;\n}\n\nint seg[7], l[7], r[7];\n\nint DP(int k) {\n    int dp[7][7] = {0};\n    for (int i = 0; i <= k; i++) dp[0][i] = 1;\n    for (int i = 1; i <= k; i++)\n        for (int j = 1; j <= seg[i]; j++) {\n            for (int p = i - 1; p >= 0; p--) {\n                add(dp[i][j], dp[p][min(seg[p], j - 1)] *\n                                  Comb(r[j] - l[j] + 1, i - p) % MOD);\n                if (seg[p] < j) break;\n            }\n            add(dp[i][j], dp[i][j - 1]);\n        }\n    return dp[k][seg[k]];\n}\n\nint solve() {\n    int rank[7] = {0}, lim[7] = {0}, state = 0;\n    vector<int> v;\n    for (int i = 1; i <= n; i++) rank[i] = x[i], v.push_back(rank[i]);\n    sort(v.begin(), v.end());\n    auto last = unique(v.begin(), v.end());\n    for (int i = 1; i <= n; i++) {\n        rank[i] = lower_bound(v.begin(), last, rank[i]) - v.begin() + 1,\n        state = state * 10 + rank[i];\n        lim[rank[i]] = lim[rank[i]] ? min(lim[rank[i]], a[i]) : a[i];\n    }\n    if (vis[state]) return 0;\n    vis[state] = 1;\n\n    int k = last - v.begin();\n    v.clear();\n    for (int i = 1; i <= k; i++) v.push_back(lim[i]);\n    sort(v.begin(), v.end());\n    last = unique(v.begin(), v.end());\n    for (int i = 1; i <= k; i++) {\n        int id = lower_bound(v.begin(), last, lim[i]) - v.begin();\n        seg[i] = id + 1;\n        l[id + 1] = ((id > 0) ? v[id - 1] : 0) + 1;\n        r[id + 1] = v[id];\n    }\n    return DP(k) * getLIS(rank) % MOD;\n}\n\nvoid dfs(int now) {\n    if (now == n + 1) {\n        add(ans, solve());\n        return;\n    }\n    for (int i = 1; i <= n; i++) {\n        x[now] = i;\n        dfs(now + 1);\n    }\n}\n\nsigned main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i], tot = tot * a[i] % MOD;\n    tot = qpow(tot, MOD - 2);\n    dfs(1);\n    cout << ans * tot % MOD;\n    return 0;\n}\n```\n\n\n# F - Visibility Sequence\n## Description\n$n$ 个数，每个数 $H_i$ 的取值在 $[1,X_i]$。设 $P_i$ 表示 $i$ 左侧第一个大于 $H_i$ 的位置，没有为 -1。问能构成多少个不同的数列 $P$ 。\n## Solution\n\n考虑一个由 $i$ 向 $P_i$ 连边构成的图，有下面两种情况：\n\n1. 设对于区间 $[l,r]$，满足 $\\forall j∈[l+1,r], H_l>H_j$，同时 $H_l \\le H_{r+1}$，那么下标在 $[l+1,r]$ 的点都会直接或间接地向 $l$ 连边。对于区间 $[l+1,r]$ 可以继续划分出一系列满足上述条件的子区间，这些子区间彼此不交，并起来是 $[l+1,r]$。最后，我们可以得到以 $l$ 为根的树，每个节点的子树对应一段连续的区间。同时，对于每个节点，其值严格大于其儿子的值。\n\n2. 设区间 $[l,r]$ 的最大值为 $x$，那么该区间可以按 $x$ 划分为多个 1 中描述的区间。每个区间对应一棵树，那么我们得到一个森林，森林中每颗树的根的权值不超过 $x$。\n\n设 $dpTree[l][r][x]$ 表示将 $[l,r]$ 组织成一棵树，$l$ 为根，其权值为 $x$ 的方案数，$dpForest[l][r][x]$ 表示将 $[l,r]$ 组织成一片森林，每棵树是一段子区间，所有树根的权值的最大值为 $x$ 的方案数。显然，不同的 $P$ 对应不同的森林，那么问题转化为求将 $[1,n]$ 组织成一片森林的方案数, 即 $\\sum\\limits_{x=1}^{n}dp[1][n][x]$。这里 $x$ 上限为 $n$ 是因为我们只需要将叶子节点设为 1，之后每往上一层节点的值都加 1，最后每个节点的值都不超过 $n$。显然，我们可以选择更大的值，但这样做并不会增加方案数，因此贪心地对每个节点设置最小值即可。此外，不妨设每个节点的儿子对应数组中下标递增，那么它们的值从左往右不降，否则会连边。\n\n根据前面的分析容易推出如下状态转移方程：\n\n1. $dpTree[l][r][x]=dpForest[l+1][r][x-1]$\n\n2. $dpForest[l][r][x]=dpTree[l][r][x]+\\sum\\limits_{k=l}^{r-1}\\sum\\limits_{m=1}^{x}dpForest[l][k][m]*dpTree[k+1][r][x]+\\sum\\limits_{k=l}^{r-1}\\sum\\limits_{m=1}^{x-1}dpForest[l][k][x]*dpTree[k+1][r][m]$ (两种情况，一种是增加一颗树，另一种是接到最右边的树上)\n\n直接转移时间复杂度是 $O(n^5)$ 的，但可以通过前缀和将时间复杂度降至 $O(n^4)$。\n## Code\n```cpp Visibility Sequence\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MOD = 1E9 + 7;\nconst int MAXN = 105;\n\nint n, h[MAXN];\nLL dpTree[MAXN][MAXN][MAXN], dpForest[MAXN][MAXN][MAXN];\nLL sumTree[MAXN][MAXN][MAXN], sumForest[MAXN][MAXN][MAXN];\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> h[i], h[i] = min(h[i], n);\n    for (int i = 1; i <= n; i++) {\n        dpTree[i][i][1] = dpForest[i][i][1] = 1;\n        for (int j = 1; j <= n; j++) sumTree[i][i][j] = sumForest[i][i][j] = 1;\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int l = 1; l + len - 1 <= n; l++) {\n            int r = l + len - 1;\n            for (int x = 1; x <= h[l]; x++)\n                dpTree[l][r][x] = dpForest[l + 1][r][x - 1];\n            for (int x = 1; x <= n; x++) {\n                dpForest[l][r][x] = dpTree[l][r][x];\n                for (int k = l + 1; k <= r; k++) {\n                    if (x > h[k]) continue;\n                    dpForest[l][r][x] =\n                        (dpForest[l][r][x] +\n                         dpForest[l][k - 1][x] * sumTree[k][r][x - 1] +\n                         sumForest[l][k - 1][x] * dpTree[k][r][x]) %\n                        MOD;\n                }\n                sumTree[l][r][x] =\n                    (sumTree[l][r][x - 1] + dpTree[l][r][x]) % MOD;\n                sumForest[l][r][x] =\n                    (sumForest[l][r][x - 1] + dpForest[l][r][x]) % MOD;\n            }\n        }\n    }\n    cout << sumForest[1][n][n];\n    return 0;\n}\n```\n\n\n","tags":["contest"],"categories":["contest"]},{"title":"Borůvka算法笔记","url":"/2020/10/08/Boruvka/","content":"\n#  \n\n<!-- more -->\n求最小生成树常用算法有 $Kruskal$ 和 $Prime$ 算法，下面介绍第三种求最小生成树的算法 —— $Borůvka$。\n\n算法的执行流程如下：\n1.  对每一个连通块，记录不在生成树中，从这个块出发，能到达别的联通块的长度最小的边。（注：长度相同选编号小的边，保证两个联通块互连时选的边是一致的，否则有可能出现环）\n\n1. 将上一步选中的边加入最小生成树。\n\n1. 重复上述步骤，直到没有边可以加入。\n\n\n![动图](https://upload.wikimedia.org/wikipedia/commons/2/2e/Boruvka%27s_algorithm_%28Sollin%27s_algorithm%29_Anim.gif)\n\n$Borůvka$ 算法演示动图如上（源：Wikimedia)\n\n由于每次合并的时间复杂度为 $O(M+N)$，每次合并后，连通块的个数减少一半，因此总的时间复杂度是 $O((M+N)logN)$ 的。\n\n# 例题\n## P3366 模板-最小生成树\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P3366)\n### Solution\n用并查集容易实现上述过程。对于图的连通性的判断，可以开一个变量记录加入边的总数，如果总数不是 $n-1$ 说明图不连通。\n### Code\n```cpp 模板-最小生成树\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, u, v, fa[5005], miEdge[5005];\nbool used[200005];\n\ntemplate <class T>\nvoid read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct Egde {\n    int to, from, len;\n} e[200005];\n\nint find(int x) {\n    if (fa[x] != x) fa[x] = find(fa[x]);\n    return fa[x];\n}\n\nvoid Boruvka() {\n    int merged = 0;\n    long long sum = 0;\n    for (int i = 1; i <= n; i++) fa[i] = i;\n\n    bool tag = true;\n    while (tag) {\n        tag = false;\n        fill(miEdge + 1, miEdge + n + 1, 0);\n        for (int i = 1; i <= m; i++) {\n            if (used[i]) continue;\n            int r1 = find(e[i].from), r2 = find(e[i].to);\n            if (r1 == r2) continue;\n            if (!miEdge[r1] || e[i].len < e[miEdge[r1]].len) miEdge[r1] = i;\n            if (!miEdge[r2] || e[i].len < e[miEdge[r2]].len) miEdge[r2] = i;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (miEdge[i] && !used[miEdge[i]]) {\n                tag = true;\n                merged++;\n                int eid = miEdge[i];\n                sum += e[eid].len;\n                used[eid] = 1;\n                fa[find(e[eid].from)] = find(e[eid].to);\n            }\n        }\n    }\n    if (merged == n - 1)\n        cout << sum;\n    else\n        cout << \"orz\";\n}\n\nint main() {\n    read(n), read(m);\n    for (int i = 1; i <= m; i++) read(e[i].from), read(e[i].to), read(e[i].len);\n    Boruvka();\n    return 0;\n}\n```\n\n## CF888G Xor-MST\n[题目链接](https://codeforces.ml/problemset/problem/888/G)\n### Description\n给出完全图 $K_n$，任意两点 $i,j$ 的边权为 $a_i ⊕ a_j$，求该图的最小生成树。\n### Solution\n由于边有 $n*(n+1)/2$ 条，因此考虑使用 $Borůvka$ 算法，同时设法快速找到不在生成树中，从这各个联通块出发能到达别的联通块的长度最小的边。\n\n对所有节点建立一个全局 $trie$，同时对每个联通块各自维护一个 $trie$。求不属于某一联通块的最小的边可以通过在全局 $trie$ 和当前连通块的 $trie$ 上对 $size$ 作差贪心地求得，而加入一条边就是将两个 $trie$ 合并。上述解法时间复杂度是 $O(nlog{n}log{\\max\\limits_{i=1}^{n}a[i]})$。\n### Code\n```cpp Xor-MST\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 2E5 + 5;\nint n, m, a[MAXN], fa[MAXN], root[MAXN], minEdge[MAXN], nxt[MAXN];\n\ntemplate <class T>\nvoid read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct Trie {\n    int son[2], sz, id;\n    Trie() { son[0] = son[1] = sz = id = 0; }\n} tr[MAXN * 31 * 2];\n\nvoid insert(int root, int id) {\n    static int cntNode = n + 1;\n    int cur = root;\n    for (int i = 30; ~i; i--) {\n        int to = (a[id] >> i) & 1;\n        if (!tr[cur].son[to]) tr[cur].son[to] = ++cntNode;\n        cur = tr[cur].son[to];\n        tr[cur].sz++;\n    }\n    tr[cur].id = id;\n}\n\nint merge(int root1, int root2) {\n    if (!root1 || !root2) return root1 + root2;\n    tr[root1].sz += tr[root2].sz;\n    for (int i = 0; i < 2; i++)\n        tr[root1].son[i] = merge(tr[root1].son[i], tr[root2].son[i]);\n    return root1;\n}\n\nint query(int root1, int root2, int val) {\n    for (int i = 30; ~i; i--) {\n        int to = (val >> i) & 1;\n        if (tr[tr[root1].son[to]].sz > tr[tr[root2].son[to]].sz)\n            root1 = tr[root1].son[to], root2 = tr[root2].son[to];\n        else\n            root1 = tr[root1].son[to ^ 1], root2 = tr[root2].son[to ^ 1];\n    }\n    return tr[root1].id;\n}\n\nint find(int x) {\n    if (fa[x] != x) fa[x] = find(fa[x]);\n    return fa[x];\n}\n\nvoid Boruvka() {\n    long long sum = 0;\n    for (int i = 1; i <= n; i++) fa[i] = i, insert(root[i], i);\n    bool tag = true;\n    while (tag) {\n        tag = false;\n        fill(minEdge + 1, minEdge + n + 1, -1);\n        for (int i = 1; i <= n; i++) {\n            int r1 = find(i);\n            int id = query(root[0], root[r1], a[i]);\n            if (!id) continue;\n            int len = a[id] ^ a[i];\n            int r2 = find(id);\n            if (minEdge[r1] == -1 || len < minEdge[r1])\n                minEdge[r1] = len, nxt[r1] = r2;\n            if (minEdge[r2] == -1 || len < minEdge[r2])\n                minEdge[r2] = len, nxt[r2] = r1;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (minEdge[i] != -1 && find(i) != find(nxt[i])) {\n                tag = true;\n                merge(root[find(i)], root[find(nxt[i])]);\n                sum += minEdge[i];\n                fa[find(nxt[i])] = i;\n            }\n        }\n    }\n    cout << sum;\n}\n\nint main() {\n    read(n);\n    for (int i = 1; i <= n; i++) read(a[i]);\n    sort(a + 1, a + n + 1);\n    for (int i = 0; i <= n; i++) root[i] = i + 1;\n    for (int i = 1; i <= n; i++) insert(root[0], i);\n    Boruvka();\n    return 0;\n}\n```","tags":["最小生成树","Borůvka"],"categories":["图论","最小生成树","Borůvka"]},{"title":"Codeforces Round 649 Div2","url":"/2020/10/03/cf-649-div2/","content":"[比赛链接](https://codeforces.ml/contest/1379)\n<!-- more -->\n# A\n## Solution\n## Code\n```cpp\n\n```\n\n# B\n## Solution\n## Code\n```cpp\n\n```\n\n# C\n## Solution\n## Code\n```cpp\n\n```\n\n# D\n## Solution\n## Code\n```cpp\n\n```\n\n# E\n## Solution\n## Code\n```cpp\n\n```\n\n# F\n## Solution\n## Code\n```cpp\n\n```\n\n","tags":["contest"],"categories":["contest"]},{"title":"Codeforces Round 666 Div2","url":"/2020/10/01/cf-666-div2/","content":"[比赛链接](https://codeforces.ml/contest/1397)\n<!-- more -->\n# A Juggling Letters\n## Description\n[题目链接](https://codeforces.ml/contest/1397/problem/A)\n## Solution\n每个字母出现次数需要是 $n$ 的倍数。\n## Code\n```cpp Juggling Letters\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, n;\nstring s;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> T;\n    while (T--) {\n        cin >> n;\n        int cnt[26] = {0};\n        for (int i = 1; i <= n; i++) {\n            cin >> s;\n            for (int j = 0; j < s.size(); j++) cnt[s[j] - 'a']++;\n        }\n        bool tag = 1;\n        for (int i = 0; i < 26; i++)\n            if (cnt[i] % n) tag = 0;\n        cout << (tag ? \"YES\\n\" : \"NO\\n\");\n    }\n    return 0;\n}\n```\n\n# B Power Sequence\n## Description\n[题目链接](https://codeforces.ml/contest/1397/problem/B)\n## Solution\n首先证明将序列调整为升序最优。\n\n证: 若存在有序对 $(a_i,a_j)$，满足 $i<j$ 且 $a_i>a_j$。\n  \n由 $|x|+|y|=max(|x+y|,|x-y|)$，可知 \n\n$|a_i-c^i|+|a_j-c^j|=max(|(a_i+a_j)-(c^i+c^j)|,|(a_i-a_j)-(c^i-c^j)|)$\n   \n$\\ge max(|(a_j+a_i)-(c^j+c^i)|,|(a_j-a_i)-(c^i-c^j)|)$\n   \n$=|a_j-c^i|+|a_i-c^j|$\n\n故将序列调整为升序会使总代价最小。\n\n接下来考虑求 $f(x)=\\sum|a_i-x^i|$ 最小值。假设最小值在 $x=c$ 时取到，那么显然有 $c^{n-1}-a_{n-1}<=f(c)<=f(1)$，即 $c^{n-1}<=f(1)+a_{n-1}$。所以只需要从 1 到 $\\sqrt[n-1]{f(1)+a_{n-1}}$ 枚举 $x$，对答案取 $min$ 即可。\n\n## Code\n```cpp Power Sequence\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1E5 + 5;\n\nint T, n;\nLL a[MAXN];\n\nLL qpow(LL a, LL b) {\n    LL ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base;\n        b >>= 1, base = base * base;\n    }\n    return ans;\n}\n\nLL f(LL x) {\n    LL sum = 0;\n    for (int i = 0; i < n; i++) sum += abs(qpow(x, i) - a[i]);\n    return sum;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a + n);\n    int lim = llround(pow(f(1) + a[n - 1], 1.0 / (n - 1)));\n    LL ans = LONG_LONG_MAX;\n    for (int i = 1; i <= lim; i++) ans = min(ans, f(i));\n    cout << ans;\n    return 0;\n}\n```\n\n\n# C Multiples of Length\n## Description\n[题目链接](https://codeforces.ml/contest/1397/problem/C)\n## Solution\n第一步，选择区间 $[1,n-1]$，将每个数加上 $(n-1)*a_i$。\n\n第二步, 选取区间 $[n,n]$，将 $a_n$ 加上 $(n-1)*a_n$。\n\n经过前两步操作后每个数变为 $n*a[i]$。\n\n第三步，选择区间 $[1,n]$，将每个数减去 $n*a_i$ 。\n\n注：当 $n=1$ 时不存在区间 $[1,n-1]$，需要单独讨论。\n## Code\n```cpp Multiples of Length\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1E5 + 5;\n\nLL n, a[MAXN];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    if (n == 1) {\n        cout << 1 << \" \" << 1 << endl;\n        cout << 0 << endl;\n        cout << 1 << \" \" << 1 << endl;\n        cout << 0 << endl;\n        cout << 1 << \" \" << 1 << endl;\n        cout << -a[1] << endl;\n        return 0;\n    }\n    cout << 1 << \" \" << n - 1 << endl;\n    for (int i = 1; i < n; i++) {\n        cout << a[i] * (n - 1) << \" \";\n        a[i] += a[i] * (n - 1);\n    }\n    cout << endl;\n\n    cout << n << \" \" << n << endl;\n    cout << (n - 1) * a[n] << endl;\n    a[n] *= n;\n\n    cout << 1 << \" \" << n << endl;\n    for (int i = 1; i <= n; i++) cout << -a[i] << \" \";\n    return 0;\n}\n```\n# D Stoned Game\n## Description\n[题目链接](https://codeforces.ml/contest/1397/problem/D)\n## Solution\n如果只有一堆，或者存在某一堆的石子数比其余堆的石子数之和还大，那么先手选这一堆必胜。否则，两个玩家一定会避免自己操作后产生前面两种局面，那么他们一定会轮流选择当前能选择的数目最大的那一堆，最后石子一定会被取完，即当石子总数为奇数时先手必胜。\n## Code\n```cpp Stoned Game\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, x, T;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> T;\n    while (T--) {\n        cin >> n;\n        int sum = 0, mx = 0;\n        for (int i = 1; i <= n; i++) cin >> x, sum += x, mx = max(mx, x);\n        if (n == 1) {\n            cout << \"T\\n\";\n            continue;\n        }\n        if (mx > sum - mx)\n            cout << \"T\\n\";\n        else {\n            if (sum & 1)\n                cout << \"T\\n\";\n            else\n                cout << \"HL\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n# E Monster Invaders\n## Description\n[题目链接](https://codeforces.ml/contest/1397/problem/E)\n## Solution\n由于 $r_1<=r_2<=r_3$，那么如果 BOSS 只剩一滴血的话，选择用手枪击杀 BOSS 耗时最少。\n\n易知当玩家第一次进入每一层时有如下选择：\n- 用手枪打死所有小怪，用 AWF 打 BOSS，进入下一层。\n- 用手枪打死所有小怪，再用手枪打 BOSS，此时有两种选择：\n  - 进入下一层后返回补刀。\n  - 回到上一层补刀，再回到这一层补刀。\n- 用镭射抢打 BOSS 和小怪，此时有两种选择：\n  - 进入下一层后返回补刀。\n  - 回到上一层补刀，再回到这一层补刀。\n\n容易证明没有比上述选择更优的选择。\n\n设 $dp[i][0]$ 表示打完前 $i-1$ 层的 BOSS，第 $i$ 层的 BOSS 剩 1 滴血所需的最少时间， $dp[i][1]$ 表示打完前 $i$ 层的 BOSS所需的最少时间。根据前面的分析容易推出状态转移方程。需要注意的是，游戏不一定在最后一层结束，即玩家打死第 $n$ 层的 BOSS 后，可能回到第 $n-1$ 层补刀，不需要再回到第 $n$ 层，因此当 $i=n$ 时要单独讨论。\n## Code\n```cpp Monster Invaders\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1E6 + 5;\nLL n, d, r1, r2, r3, a[MAXN], dp[MAXN][2];\n\ntemplate <class T>\nvoid read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nsigned main() {\n    read(n), read(r1), read(r2), read(r3), read(d);\n    for (int i = 1; i <= n; i++) read(a[i]);\n    dp[1][0] = min(a[1] * r1 + r1, r2), dp[1][1] = a[1] * r1 + r3;\n    for (int i = 2; i <= n; i++) {\n        dp[i][0] = min(dp[i - 1][0] + 3 * d + min(a[i] * r1 + r1, r2) + r1,\n                       dp[i - 1][1] + d + min(a[i] * r1 + r1, r2));\n        dp[i][1] = min(dp[i - 1][1] + d + a[i] * r1 + r3,\n                       dp[i - 1][0] + 3 * d + min(a[i] * r1 + r1, r2) + 2 * r1);\n        if (i == n)\n            dp[i][1] =\n                min(dp[i][1], dp[i - 1][0] + 2 * d + a[i] * r1 + r3 + r1);\n    }\n    cout << dp[n][1] << endl;\n    return 0;\n}\n```","tags":["contest"],"categories":["contest"]},{"title":"Codeforces Round 665 Div2","url":"/2020/10/01/cf-665-div2/","content":"[比赛链接](https://codeforces.ml/contest/1401)\n<!-- more -->\n# A Distance and Axis\n## Solution\n列出式子把绝对值拆开分类讨论即可。\n## Code\n```cpp Distance and Axis\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 2e5 + 5, MOD = 1e9 + 7;\n\nint tc, n, m;\narray<int, MAXN> a;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> tc;\n    while (tc--) {\n        int n, k;\n        cin >> n >> k;\n        if ((n + k) % 2 == 0 && n >= k) cout << 0 << \"\\n\";\n        else if (n < k) {\n            cout << k - n << \"\\n\";\n        } else {\n            cout << 1 << \"\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n# B Ternary Sequence\n考虑 $a$ 序列，$a$ 的 2 优先和 $b$ 的 1 匹配，若有剩余再和 $b$ 的 2 匹配。然后 2 和 0， 0 和 2 匹配。最后只能 2 和 1 匹配。\n```cpp Ternary Sequence\n#include <bits/stdc++.h>\n#define int long long\n \nusing namespace std;\n \nconstexpr int MAXN = 2e5 + 5, MOD = 1e9 + 7;\n \nint tc, n, m, x[2], y[2], z[2];\n \nsigned main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> tc;\n    while (tc--) {\n        int ans = 0;\n        cin >> x[0] >> y[0] >> z[0];\n        cin >> x[1] >> y[1] >> z[1];\n        int tmp = min(z[0], y[1]); //2 1\n        ans += 2LL * tmp;\n \n        z[0] -= tmp, y[1] -= tmp; // 2 2\n        tmp = min(z[0], z[1]);\n        z[0] -= tmp, z[1] -= tmp;\n \n        tmp = min(z[0], x[1]); //2 0\n        z[0] -= tmp, x[1] -= tmp;\n \n        tmp = min(z[1], x[0]); //0 2\n        z[1] -= tmp, x[0] -= tmp;\n \n        tmp = min(z[0], y[1]);\n        ans -= 2LL * tmp;\n \n        tmp = min(z[1], y[0]);\n        ans -= 2LL * tmp;\n    \n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n# C Mere Array\n## Solution\n设最小值为 $mi$，则一定可以通过 $mi$ 让 $mi$ 的倍数排成有序的。把 $mi$ 的倍数先取出排序，再放回原序列，再判断整个序列是否升序。\n## Code\n```cpp Mere Array\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 2e5 + 5, MOD = 1e9 + 7;\n\nint tc, n, m;\narray<int, MAXN> a, to;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> tc;\n    while (tc--) {\n        cin >> n;\n        int mi = 0x3f3f3f3f;\n        vector<int> tmp;\n        for (int i = 1; i <= n; i++) cin >> a[i], mi = min(mi, a[i]);\n        if (n == 1) cout << \"YES\\n\";\n        else {\n            for (int i = 1; i <= n; i++)\n                if (a[i] % mi == 0) tmp.push_back(a[i]), a[i] = 0;\n            sort(tmp.begin(), tmp.end());\n\n            int id = 0;\n            for (int i = 1; i <= n; i++)\n                if (a[i] == 0) a[i] = tmp[id++];\n\n            bool judge = true;\n            for (int i = 1; i <= n; i++)\n                if (a[i] < a[i - 1]) judge = false;\n\n            judge ? cout << \"YES\\n\" : cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n# D Maximum Distributed Tree\n## Solution\n首先对于一条边，它会被计算**两端的子树大小的乘积**次。要让答案最大，那么被计算次数最多的边的边权应为最大的约数，依此类推。注意如果质因数个数超过 $n - 1$，则将最大的几个质因子乘起来，分配给被计算最多的边。\n## Code\n```cpp Maximum Distributed Tree\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconstexpr int MAXN = 1e5 + 5, MOD = 1e9 + 7;\n\nint tc, n, m;\nvector<int> G[MAXN], cnt;\narray<int, MAXN> w, sz;\n\nvoid dfs(int cur, int fa) {\n    sz[cur] = 1;\n    for (auto& to : G[cur]) {\n        if (to == fa) continue;\n        dfs(to, cur);\n        sz[cur] += sz[to];\n    }\n    cnt.push_back(sz[cur] * (n - sz[cur]));\n}\n\nsigned main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> tc;\n    while (tc--) {\n        cin >> n;\n        for (int i = 1; i <= n; i++) G[i].clear();\n        cnt.clear();\n        for (int i = 1, u, v; i < n; i++) {\n            cin >> u >> v;\n            G[u].push_back(v), G[v].push_back(u);\n        }\n        cin >> m;\n        for (int i = 1; i <= m; i++) cin >> w[i];\n        for (int i = m + 1; i <= n - 1; i++) w[i] = 1;\n        sort(w.begin() + 1, w.begin() + max(n, m + 1)), reverse(w.begin() + 1, w.begin() + max(m + 1, n));\n        dfs(1, 0);\n        sort(cnt.begin(), cnt.end()), reverse(cnt.begin(), cnt.end());\n        int ans = 0;\n        if (n - 1 >= m) {\n            for (int i = 0; i < n - 1; i++)\n                (ans += cnt[i] % MOD * w[i + 1] % MOD) %= MOD;\n        }\n        else {\n            for (int i = 1; i < n - 1; i++) {\n                (ans += cnt[i] % MOD * w[m - n + 2 + i] % MOD) %= MOD;\n            }\n            int tmp = 1;\n            for (int i = 1; i <= m - n + 2; i++)\n                (tmp *= w[i]) %= MOD;\n            (ans += tmp * cnt[0] % MOD) %= MOD;\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n```\n\n# E Divide Square\n## Solution\n有两种情况会使答案加一：贯穿整个矩形的直线，或两条直线相交。\n\n求直线交点：可以将水平线段按左端点排序，左端点相同按右端点排序。并将竖直线段的 $x$ 坐标也加入，若 $x$ 坐标与水平线段左端点相同，优先考虑水平线段。\n\n统计交点数：可以通过树状数组对 $y$ 进行区间 $[y_l, y_r]$ 查询，加入或删除水平线则对水平线的 $y$ 单点修改。\n\n加入或删除水平线可通过队列实现，如果右端点小于当前竖直线的 $x$，则出队，并通过树状数组对 $y$ 进行单点修改。\n\n注意：树状数组不是 0 based 的，需将坐标都加 1。\n## Code\n```cpp Divide Square\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 1e6 + 6, MOD = 1e9 + 7, MAXZ = 1e5 + 5;\n\nint n, m, tmp[MAXZ], y[MAXZ], l1[MAXZ], r1[MAXZ], x[MAXZ], l2[MAXZ], r2[MAXZ];\nLL ans(1);\n\nstruct BIT {\n    int lowbit(int x) { return x & (-x); }\n\n    void add(int x, LL val) {\n        while (x < MAXN) c[x] += val, x += lowbit(x);\n    }\n\n    LL query(int x, int res = 0) {\n        while (x) res += c[x], x -= lowbit(x);\n        return res;\n    }\n    array<LL, MAXN> c;\n} bit[3];\n/*range [l, r] add val*/\ninline void add(int l, int r, LL val) {\n    bit[1].add(l, val), bit[1].add(r + 1, -val);\n    bit[2].add(l, val * l), bit[2].add(r + 1, -val * (r + 1));\n}\n/*range [l, r] sum query*/\ninline LL query(int l, int r, LL res = 0) {\n    res = bit[0].query(r) + bit[1].query(r) * (r + 1) - bit[2].query(r);\n    res -= bit[0].query(l - 1) + bit[1].query(l - 1) * l - bit[2].query(l - 1);\n    return res;\n}\n\nstruct Node {\n    Node() = default;\n    Node(int _type, int _l, int _r, int _x) :\n        type(_type), l(_l), r(_r), x(_x) {}\n\n    friend inline bool operator<(const Node& lhs, const Node& rhs) {\n        if (lhs.l == rhs.l) {\n            if (lhs.type == rhs.type) return lhs.r < rhs.r;\n            return lhs.type < rhs.type; \n        }\n        return lhs.l < rhs.l;\n    }\n\n    int type, l, r, x; //type == 0 horizontal ==1 vertical\n};\nvector<Node> vec;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        cin >> y[i] >> l1[i] >> r1[i];\n        y[i]++, l1[i]++, r1[i]++;\n        if (l1[i] == 1 && r1[i] == 1000001) ans++;\n        vec.emplace_back(0, l1[i], r1[i], y[i]);\n    }\n    for (int i = 1; i <= m; i++) {\n        cin >> x[i] >> l2[i] >> r2[i];\n        x[i]++, l2[i]++, r2[i]++;\n        if (l2[i] == 1 && r2[i] == 1000001) ans++;\n        vec.emplace_back(1, x[i], l2[i], r2[i]);\n    }\n    sort(vec.begin(), vec.end());\n    queue<int> q;\n    for (int i = 0; i < vec.size(); i++) {\n        if (vec[i].type == 0) {\n            add(vec[i].x, vec[i].x, 1);\n            q.push(i);\n        } else {\n            while (!q.empty() && vec[q.front()].r < vec[i].l) {\n                add(vec[q.front()].x, vec[q.front()].x, -1);\n                q.pop();\n            }\n            ans += query(vec[i].r, vec[i].x);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n```\n\n# F Reverse and Swap\n## Solution\n考虑线段树维护，设线段树从上往下是第 0 层，第 1 层，第 2 层，...，第 n 层。那么 $swap(k)$ 操作就是给第 $n - k + 1$ 层所有节点打上交换标记，$reverse(k)$ 操作就是给第 $n - k$ 到 $n$ 层的所有节点打上标记。\n\n一种做法是用 $tag[]$ 记录每一层的交换标记，然后每个节点也有一个 $tag$ 标记，如果节点的 $tag$ 和节点对应层的 $tag[depth]$ 不同，则交换其左右儿子，并修改 tag。\n注：当区间翻转的是一个整区间时才能用线段树交换左右儿子，其次结构体中不建议保存节点 $l, r$ 信息（不方便交换左右儿子，因为左右儿子的 $l, r$ 都要变），可以直接作为函数参数。\n\n另一种做法是根据层标记确定往左二子还是右儿子走，同时计算变化后的区间。\n\n## Code\n```cpp Reverse and Swap method1\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 3e5 + 5, MOD = 1e9 + 7;\n\ntemplate<typename T>\ninline void read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nint bit, n, q, a[MAXN], tag[19], tot;\n\nstruct SegTree {\n    SegTree* lson, *rson;\n    int tag, depth;\n    long long sum;\n} *root, tree[MAXN << 1];\n\ninline void update(SegTree* root) {\n    root->sum = root->lson->sum + root->rson->sum;\n}\n\ninline void build(SegTree*& root, int L, int R, int depth) {\n    root = &tree[tot++], root->depth = depth;\n    if (L == R) { root->sum = a[L]; return; }\n    int mid = (L + R) >> 1;\n    build(root->lson, L, mid, depth + 1);\n    build(root->rson, mid + 1, R, depth + 1);\n    update(root);\n}\n\ninline void checkTag(SegTree* root) {\n    if (root->tag != tag[root->depth]) {\n        root->tag = tag[root->depth];\n        swap(root->lson, root->rson);\n    }\n}\n\ninline void modify(SegTree* root, int pos, int val, int L = 1, int R = n) {\n    if (L == pos && R == pos) {\n        root->sum = val;\n        return;\n    }\n    checkTag(root);\n    int mid = (L + R) >> 1;\n    if (pos <= mid) modify(root->lson, pos, val, L, mid);\n    else modify(root->rson, pos, val, mid + 1, R);\n    update(root);\n}\n\ninline long long query(SegTree* root, int l, int r, int L = 1, int R = n) {\n    if (l <= L && R <= r) return root->sum;\n    checkTag(root);\n    int mid = (L + R) >> 1;\n    long long res = 0;\n    if (l <= mid) res += query(root->lson, l, r, L, mid);\n    if (r > mid) res += query(root->rson, l, r, mid + 1, R);\n    update(root);\n    return res;\n}\n\nint main() {\n    read(bit), read(q), n = pow(2, bit);\n    for (int i = 1; i <= n; i++) read(a[i]);\n    build(root, 1, n, 0);\n    while (q--) {\n        int opt, x, k, l, r;\n        read(opt);\n        if (opt == 1) read(x), read(k), modify(root, x, k);\n        else if (opt == 2) {\n            read(k);\n            for (int i = bit - k; i <= bit; i++) tag[i] ^= 1;\n        } else if (opt == 3) read(k), tag[bit - k - 1] ^= 1;\n        else read(l), read(r), printf(\"%lld\\n\", query(root, l, r));\n    }\n    return 0;\n}\n```\n\n```cpp Reverse and Swap method2\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 3E5;\nint n, q, a[MAXN], x, k, l, r, tag[19];\n\ntemplate <class T>\nvoid read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct Node {\n    Node* son[2];\n    int l, r;\n    LL sum;\n} * root;\n\nvoid update(Node* cur) { cur->sum = cur->son[0]->sum + cur->son[1]->sum; }\n\nvoid build(Node*& cur, int l, int r) {\n    cur = new Node;\n    cur->l = l, cur->r = r;\n    if (l == r) {\n        cur->sum = a[l];\n        return;\n    }\n    int mid = l + r >> 1;\n    build(cur->son[0], l, mid);\n    build(cur->son[1], mid + 1, r);\n    update(cur);\n}\n\nvoid replace(Node* cur, int x, int val, int layer) {\n    if (cur->l == x && cur->r == x) {\n        cur->sum = val;\n        return;\n    }\n    int mid = cur->l + cur->r >> 1;\n    int st = tag[layer];\n    int len = st ? (cur->r - cur->l + 1) >> 1 : 0;\n    if (x <= mid)\n        replace(cur->son[st], x + len, val, layer + 1);\n    else\n        replace(cur->son[!st], x - len, val, layer + 1);\n    update(cur);\n}\n\nLL sum(Node* cur, int l, int r, int layer) {\n    if (cur->l == l && cur->r == r) return cur->sum;\n    int mid = cur->l + cur->r >> 1;\n    int st = tag[layer];\n    int len = st ? (cur->r - cur->l + 1) >> 1 : 0;\n\n    if (r <= mid)\n        return sum(cur->son[st], l + len, r + len, layer + 1);\n    else if (l > mid)\n        return sum(cur->son[!st], l - len, r - len, layer + 1);\n    else\n        return sum(cur->son[st], l + len, mid + len, layer + 1) +\n               sum(cur->son[!st], mid + 1 - len, r - len, layer + 1);\n}\nint main() {\n    read(n), read(q);\n    for (int i = 1; i <= 1 << n; i++) read(a[i]);\n    build(root, 1, 1 << n);\n    while (q--) {\n        int type;\n        read(type);\n        switch (type) {\n            case 1:\n                read(x), read(k);\n                replace(root, x, k, 0);\n                break;\n            case 2:\n                read(k);\n                for (int i = n - k; i <= n; i++) tag[i] ^= 1;\n                break;\n            case 3:\n                read(k);\n                tag[n - k - 1] ^= 1;\n                break;\n            case 4:\n                read(l), read(r);\n                printf(\"%lld\\n\", sum(root, l, r, 0));\n                break;\n            default:\n                break;\n        }\n    }\n    return 0;\n}\n```","tags":["contest"],"categories":["contest"]},{"title":"Stone Game II","url":"/2020/09/30/Stone-Game-II/","content":"[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=4388)\n<!-- more -->\n\n# Description\n给出 $N$ 堆石子，现有两个人轮流取石子。假设当前这堆石子个数为 $n$，那么一个人进行一次操作后，剩余石子数 $k$ 必须满足： $0<k<n$ 且 $n⊕k<n$。完成此次操作后会新增一堆数量为 $n⊕k$ 的石子。\n除此之外，每个人有一次进行特殊操作的机会，使增加的一堆的石子数从 $n⊕k$ 变为 $2n⊕k$ 。问是否先手必胜。\n# Solution\n考虑每一次操作。经过一次操作（先不考虑特殊操作），一堆 $n$ 个石子会变成数目为 $k$ 和 $k⊕n$ 的两堆，且这两堆都小于 $n$，同时，分开后的两堆数石子在二进制下 1 的个数总和与 $n$ 在二进制下 1 的个数的奇偶性相同。\n\n容易发现，当每一堆石子个数都是 2 的次幂则无法继续操作，当前操作者输。设一堆 $n$ 个石子被拆成 $m$ 堆，每堆都不可再分，则每堆二进制下都只有 1 个 1， 即 $n$ 在二进制下 1 的个数和 $m$ 同奇偶。又因为分成 $m$ 堆需要 $m-1$ 次操作，那么操作次数和 $n$ 在二进制下 1 的个数的奇偶性是相反的，也就是说如果 $n$ 在二进制下的 1 的个数是偶数，则会进行奇数次操作，即先手必胜。\n\n对于特殊操作，$2k$ 和 $2k⊕n$ 这两堆二进制下 1 的个数之和与 $n$ 在二进制下 1 的个数同奇偶，而 $2k=k<<1$ 和 $k$ 在二进制下 1 的个数相同，因此对总的操作次数没有影响。\n# Code\n```cpp Stone Game II\n#include <bits/stdc++.h>\n\nusing namespace std;\nint T, n, x;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> T;\n    while (T--) {\n        static int cntCase = 1;\n        cin >> n;\n        int cntOpt = 0;\n        for (int i = 1; i <= n; i++) {\n            cin >> x;\n            for (int i = 17; ~i; i--)\n                if ((x >> i) & 1) cntOpt ^= 1;\n            cntOpt ^= 1;\n        }\n        printf(\"Case %d: %s\\n\", cntCase++, cntOpt & 1 ? \"Yes\" : \"No\");\n    }\n    return 0;\n}\n```\n","tags":["博弈论"],"categories":["博弈论"]},{"title":"CODE FESTIVAL 2016 Grand Final C - Cheating Nim","url":"/2020/09/29/Cheating-Nim/","content":"[题目链接](https://atcoder.jp/contests/cf16-exhibition-final/tasks/cf16_exhibition_final_c)\n<!-- more -->\n\n# Description\n两个人玩 $Nim$ 游戏，但后手打算在开始游戏前作弊，选择某几堆各拿走一颗石子，从而使自己必胜。问后手最少要拿走几颗石子。若后手无论如何也不能必胜，输出 -1。\n# Solution\n如果不提前拿走石子，那么当 $a_1⊕a_2⊕…⊕a_n=ans=0$ 时后手必胜。 设从第 $i$ 堆拿出一个石子，那么对应项 $a_i$ 变为 $a_i-1$，相当于等式两边异或上 $a_i⊕(a_i-1)$。\n\n注意到 $a_i⊕(a_i-1)$ 一定形如 $2^k-1$，即每一位都是 1。要让 $ans$ 为 0，即二进制下每一位都是 0，考虑从高位到低位枚举 $ans$ 在二进制下为 1 的位 $k$，如果存在 $i$ 使得 $a_i⊕(a_i-1)$ 恰好有 $k$ 位，那么一定从第 $i$ 堆石子拿走一个，等价于使 $ans$ 异或上 $a_i⊕(a_i-1)$，这样 $ans$ 第 $k$ 位就变为 0。最后，如果无法使 $ans=0$ 则后手必败。\n\n# Code\n```cpp Cheating Nim\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 1E5 + 5;\nint n, a[MAXN], sum, f[31], cnt;\n\ntemplate <class T>\nvoid read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nint main() {\n    read(n);\n    for (int i = 1; i <= n; i++) {\n        read(a[i]);\n        sum ^= a[i];\n        a[i] ^= a[i] - 1;\n        for (int j = 30; ~j; j--)\n            if ((a[i] >> j) & 1) {\n                f[j] = 1;\n                break;\n            }\n    }\n    for (int i = 30; ~i; i--)\n        if ((sum >> i) & 1)\n            if (f[i]) sum ^= (1 << (i + 1)) - 1, cnt++;\n    printf(\"%d\\n\", sum ? -1 : cnt);\n    return 0;\n}\n```\n","tags":["Nim游戏与SG函数","位运算"],"categories":["博弈论","Nim游戏与SG函数"]},{"title":"AtCoder Beginner Contest 179","url":"/2020/09/22/atcoder-abc-179/","content":"[比赛链接](https://atcoder.jp/contests/abc179)\n<!-- more -->\n# D Leaping Tak\n## Description\n[题目链接](https://atcoder.jp/contests/abc179/tasks/abc179_d)\n## Solution\n设 $dp[i]$ 表示抵达位置 $i$ 的方案数，显然有 $dp[1]=1$。考虑直接转移，则 $dp[i]=\\sum\\limits_{s=1}^{k}\\sum\\limits_{j=i-R_s}^{i-L_s}dp[j]$，这么做最坏情况下复杂度为 $O(kn^2)$。容易发现，内层求和可以用前缀和维护，从而使时间复杂度降至$O(kn)$。\n## Code\n```cpp Leaping Tak\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\nconst int MOD = 998244353;\n\nint n, k;\nint l[11], r[11];\nLL dp[MAXN], sum[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n >> k;\n    for (int i = 1; i <= k; i++) cin >> l[i] >> r[i];\n    dp[1] = 1, sum[1] = 1;\n    for (int i = 2; i <= n; i++)\n        for (int j = 1; j <= k; j++) {\n            if (i - l[j] >= 0) {\n                dp[i] += sum[i - l[j]] - sum[max(0, i - r[j] - 1)];\n                dp[i] = (dp[i] % MOD + MOD) % MOD;\n            }\n            sum[i] = (sum[i - 1] + dp[i]) % MOD;\n        }\n    cout << dp[n];\n    return 0;\n}\n```\n\n# E Sequence Sum\n## Description \n[题目链接](https://atcoder.jp/contests/abc179/tasks/abc179_e)\n## Solution\n显然有 $A_{n+1}=A_{n}*A_{n} \\mod M$，那么 $A_2,A_3……A_n$ 关于模 $M$ 乘构成循环群，因此可在 $O(M)$ 时间内求得循环节并通过前缀和求得$\\sum\\limits_{i=1}^{n}A_i$。\n## Code\n```cpp Sequence Sum\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\n\nLL n, x, m;\nLL sum[MAXN], a[MAXN], last[MAXN], st, ed;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n >> x >> m;\n    a[1] = x, sum[1] = a[1];\n    for (int i = 2; i <= n; i++) {\n        a[i] = a[i - 1] * a[i - 1] % m;\n        if (!a[i]) {\n            cout << sum[i - 1];\n            return 0;\n        }\n        sum[i] = sum[i - 1] + a[i];\n        if (last[a[i]]) {\n            st = last[a[i]];\n            ed = i - 1;\n            break;\n        }\n        last[a[i]] = i;\n    }\n    if (!ed)\n        cout << sum[n];\n    else {\n        LL len = ed - st + 1;\n        LL cycleSum = sum[ed] - sum[st - 1];\n        LL ans = sum[st - 1];\n        LL tot = n - st + 1;\n        ans += tot / len * cycleSum;\n        int res = tot % len;\n        ans += sum[st + res - 1] - sum[st - 1];\n        cout << ans;\n    }\n    return 0;\n}\n```\n\n# F Simplified Reversi\n## Description \n[题目链接](https://atcoder.jp/contests/abc179/tasks/abc179_f)\n## Solution\n首先，总的黑棋子数为 $(n-2)^2$，我们只需要考虑每次操作会删除多少黑棋子，最后用 $(n-2)^2$ 减去被删除黑棋子的总数就是答案。\n\n对于操作 1，在第 $x$ 列上查询第一个白棋子的位置 $j$，那么应该被删去的黑棋子的数目为 $j-2$。对于 $[2,j-1]$ 行，删去这些黑棋子并用白棋子替换后，显然有第一个白棋子的位置不超过 $x$。\n\n对于操作 2，可以看作是在操作 1 的基础上对行列进行了交换。\n\n因此，我们可以对行和列分别建立线段树维护区间最小值。对于操作 1，在列上单点查询，在行上进行区间修改；对于操作 2，在行上单点查询，在列上进行区间修改。\n## Code\n```cpp Simplified Reversi\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\nconst int MAXN = 2E5 + 5;\n\nint n, q, type, x;\nLL ans;\n\nstruct Node {\n    int lson, rson;\n    int l, r, mi, lazy;\n} tr[MAXN * 8];\n\nint root1, root2;\n\nvoid update(int id) { tr[id].mi = min(tr[tr[id].lson].mi, tr[tr[id].rson].mi); }\n\nvoid pushdown(int id) {\n    if (tr[id].lazy != n) {\n        tr[tr[id].lson].mi = min(tr[tr[id].lson].mi, tr[id].lazy);\n        tr[tr[id].lson].lazy = min(tr[tr[id].lson].lazy, tr[id].lazy);\n        tr[tr[id].rson].mi = min(tr[tr[id].rson].mi, tr[id].lazy);\n        tr[tr[id].rson].lazy = min(tr[tr[id].rson].lazy, tr[id].lazy);\n        tr[id].lazy = n;\n    }\n}\n\nvoid build(int& id, int l, int r) {\n    static int tot;\n    id = ++tot;\n    tr[id].l = l, tr[id].r = r;\n    tr[id].lazy = n;\n    if (l == r) {\n        tr[id].mi = n;\n        return;\n    }\n    int mid = l + r >> 1;\n    build(tr[id].lson, l, mid);\n    build(tr[id].rson, mid + 1, r);\n    update(id);\n}\n\nvoid modify(int id, int l, int r, int val) {\n    if (tr[id].mi < val) return;\n    if (tr[id].l == l && tr[id].r == r) {\n        tr[id].mi = min(tr[id].mi, val);\n        tr[id].lazy = min(tr[id].lazy, val);\n        return;\n    }\n    pushdown(id);\n    int mid = tr[id].l + tr[id].r >> 1;\n    if (r <= mid)\n        modify(tr[id].lson, l, r, val);\n    else if (l > mid)\n        modify(tr[id].rson, l, r, val);\n    else {\n        modify(tr[id].lson, l, mid, val);\n        modify(tr[id].rson, mid + 1, r, val);\n    }\n    update(id);\n}\n\nint query(int id, int x) {\n    if (tr[id].l == x && tr[id].r == x) {\n        return tr[id].mi;\n    }\n    pushdown(id);\n    int mid = tr[id].l + tr[id].r >> 1;\n    if (x <= mid)\n        return query(tr[id].lson, x);\n    else\n        return query(tr[id].rson, x);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n >> q;\n    ans = 1ll * (n - 2) * (n - 2);\n    build(root1, 2, n - 1);\n    build(root2, 2, n - 1);\n    for (int i = 1; i <= q; i++) {\n        cin >> type >> x;\n        if (type == 1) {\n            int now = query(root1, x);\n            ans-= now - 2;\n            modify(root2, 2, now - 1, x);\n        } else {\n            int now = query(root2, x);\n            ans -= now - 2;\n            modify(root1, 2, now - 1, x);\n        }\n    }\n    cout << ans;\n    return 0;\n}\n```","tags":["contest"],"categories":["contest"]},{"title":"AtCoder Beginner Contest 178","url":"/2020/09/22/atcoder-abc-178/","content":"[比赛链接](https://atcoder.jp/contests/abc178)\n<!-- more -->\n# C Ubiquity\n## Description\n设 $A$ 为 $N$ 个 0~9 的数构成的序列。问存在 0 且存在 9 的序列有多少个。\n## Solution\n方法 1：所求序列个数为总序列个数减去不含 0 或不含 9 的序列个数。\n- 不含 0 和 9 的序列个数有 $8^n$ 个。\n- 含 0 但不含 9 的序列个数有 $9^n - 8^n$ 个。（二项式去掉第 0 项可得）\n- 含 9 但不含 0 的序列个数同上。\n\n所以答案为 $10^n - 2 * 9^n + 8^n$\n\n方法 2: [DP](https://atcoder.jp/contests/abc178/submissions/16709001)\n- $dp[n][0][0]$ 表示当前序列长度为 $n$，有 0 个 0, 0 个 9 的方案数\n- $dp[n][1][0]$ 表示当前序列长度为 $n$，有至少 1 个 0, 0 个 9 的方案数\n- $dp[n][0][1]$ 表示当前序列长度为 $n$，有 0 个 0, 至少 1 个 9 的方案数\n- $dp[n][1][1]$ 表示当前序列长度为 $n$，有至少 1 个 0，至少 1 个 9 的方案数\n## Code\n```cpp Ubiquity\n#include <bits/stdc++.h>\n#define int long long\n\nint tc, n, m;\narray<int, MAXN> a;\n\ninline int qpow(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    int res = qpow(10, n);\n    int minus = qpow(8, n);\n    (minus += 2LL * (qpow(9, n) - qpow(8, n))) %= MOD;\n    (res -= minus) %= MOD;\n    cout << (res + MOD) % MOD <<endl;\n    return 0;\n}\n```\n\n# D Redistribution\n## Description\n[题目链接](https://atcoder.jp/contests/abc178/tasks/abc178_d)\n## Solution\n首先，由于数列中每个数至少为 3，因此数列长度最大为 $L=\\frac{S}{3}$。设 $dp[i][j]$ 表示构成长度为 $i$，和为 $j$ 的数列方案数，那么最后答案为 $\\sum\\limits_{i=1}^{L}dp[i][S]$。易得状态转移方程为 $dp[i][j]=\\sum\\limits_{k=(i-1)*3}^{j-3}dp[i-1][k],j∈[i*3,S]$。如果直接转移时间复杂度为$O(S^2L)$，但 $\\sum\\limits_{k=(i-1)*3}^{j-3}dp[i-1][k]$ 可以用利用前缀和 $O(1)$ 求得，同时 $dp[i][j]$ 第一维可以滚掉，因此复杂度可降至 $O(SL)$。\n\n## Code\n```cpp Redistribution\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int MOD = 1E9 + 7;\nint dp[2005], sum[2005];\nint len, s, ans;\n\ntemplate <class T>\nvoid read(T &x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nint main() {\n    cin >> s;\n    len = s / 3;\n    dp[0] = 1;\n    for (int i = 0; i <= s; i++) sum[i] = 1;\n    for (int i = 1; i <= len; i++) {\n        for (int j = i * 3; j <= s; j++)\n            dp[j] = (sum[j - 3] - (i > 1 ? sum[(i - 1) * 3 - 1] : 0)) % MOD;\n        ans += dp[s], ans %= MOD;\n        for (int j = 0; j <= s; j++) sum[j] = 0;\n        for (int j = i * 3 - 1; j <= s; j++)\n            sum[j] = (sum[j - 1] + dp[j]) % MOD;\n    }\n    cout << (ans + MOD) % MOD;\n    return 0;\n}\n```\n\n# E Dist Max\n## Description\n[题目链接](https://atcoder.jp/contests/abc178/tasks/abc178_e)\n## Solution\n$|x_1-x_2|+|y_1-y_2|$ 去绝对值后有以下四种情况：\n- $x_1+y_1-(x_2+y_2)$\n- $y_1-x_1-(y_2-x_2)$\n- $x_2+y_2-(x_1+y_1)$\n- $y_2-x_2-(y_1-x_1)$\n\n要求 $|x_1-x_2|+|y_1-y_2|$ 最大值，只需要分别求出 $x_i+y_i$ 和 $y_i-x_i$ 最大值与最小值的差，对这两个差取 $max$ 即可。\n## Code\n```cpp Dist Max\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, x, y;\nint mxSum = INT_MIN, miSum = INT_MAX, mxSub = INT_MIN, miSub = INT_MAX;\n\ntemplate <class T>\nvoid read(T &x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nint main() {\n    read(n);\n    for (int i = 1; i <= n; i++) {\n        read(x), read(y);\n        mxSum = max(mxSum, x + y), miSum = min(miSum, x + y);\n        mxSub = max(mxSub, y - x), miSub = min(miSub, y - x);\n    }\n    cout << max(mxSum - miSum, mxSub - miSub);\n    return 0;\n}\n```\n\n\n# E Contrast\n## Description\n[题目链接](https://atcoder.jp/contests/abc178/tasks/abc178_f)\n## Solution\n首先根据鸽巢原理，如果一个数在 $A$ 和 $B$ 的出现次数大于 $n$，那么一定无解。\n\n对于有解的情况，设 $C_i$ 表示 $A$ 中小于等于 $i$ 的数的个数，设 $D_i$ 表示 $B$ 中小于等于 $i$ 的数的个数，$C_i$， $D_i$ 是单增的。\n\n对于每一个 $x(0 \\leq x \\leq N)$，我们让 $B$ 的每个元素向右移动 $x$ 位(即将 $B_{i+1}$ 移动到 $B_{(i+x) \\% n+1}$)。\n\n要使结果合法，$x$ 需要满足对于所有 $i(1 \\leq i \\leq n)$，区间$(C_{i-1}, C_{i}]$，$(x + D_{i - 1}, x + D_{i}]$ 和 $(n + C_{i-1}, n + C_{i}]$ 没有交集(可以看作 $A$ 复制一倍，$B$ 右移 $x$，需满足同一位置没有相同的数)。即对于所有 $i$， $C_i - D_{i-1} \\leq x \\leq C_{i-1}+n-D_i$。\n\n可以证明这样的 $x$ 是一定存在的[Editorial](https://atcoder.jp/contests/abc178/editorial/128)。\n\n由于对于每一个 $i$ 都要成立，则 $x$ 的取值范围一定在 $C_i - D_{i-1}$ 的最大值 与 $C_{i-1}+n-D_i$ 的最小值之间。故取 $x$ 为 $C_i - D_{i-1}$ 的最大值即可。\n## Code\n```cpp Contrast\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 2e5 + 5;\n\nint n, mx;\narray<int, MAXN> a, b, c, d, cnt, ans;\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i], c[a[i]]++, cnt[a[i]]++;\n    for (int i = 1; i <= n; i++) c[i] += c[i - 1];\n\n    for (int i = 1; i <= n; i++) cin >> b[i], d[b[i]]++, cnt[b[i]]++;\n    for (int i = 1; i <= n; i++) d[i] += d[i - 1];\n\n    for (int i = 1; i <= n; i++)\n        if (cnt[i] > n) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    \n    for (int i = 1; i <= n; i++)\n        mx = max(mx, c[i] - d[i - 1]);\n    for (int i = 1; i <= n; i++)\n        ans[(i + mx) % n == 0 ? n : (i + mx) % n] = b[i];\n\n    cout << \"Yes\" << endl;\n    for (int i = 1; i <= n; i++)\n        cout << ans[i] << \" \";\n    return 0;\n}\n```","tags":["contest"],"categories":["contest"]},{"title":"树分块 树上莫队笔记 Mo's Algorithm on Tree","url":"/2020/09/05/Mo-s-Algorithm-on-tree/","content":"# \n<!-- more -->\n参考博客：\n[莫队、带修莫队、树上莫队详解](https://www.cnblogs.com/ouuan/p/MoDuiTutorial.html)\n# 树分块\n这里介绍三种分块方法\n- 按 $DFS$ 序分块。严格保证块大小为 $\\sqrt N$，但是不保证直径，也不保证联通。处理子树信息比较方便。 \n- 王室联邦分块。如果确定每个块大小至少为 $\\sqrt N$，可以保证分得每个块的大小和直径都不超过 $3\\sqrt N$，但是不保证块联通。\n- 按深度分块。待补充...\n\n这样分块是为了莫队的排序，使在两个查询间转移时只需进行 $\\sqrt N$ 数量级的操作。\n\n# P2325 [SCOI2005]王室联邦\n## Description\n[题目链接](https://www.luogu.com.cn/problem/P2325)\n## Solution\n- 构造方式：\n\n\t$dfs$，同时创建一个栈存储未分块的节点。每 $dfs$ 到一个点时获取当前栈的大小，当搜完当前节点 $now$ 的一个子节点后，判断栈的大小的增量是否大于等于 $B$，是则将栈内所有新增点分到新的块中，并将首都点为当前节点 $now$，否则保留新增节点，处理下一个子节点。当当前节点的所有子节点都被搜过后，将当前节点入栈。$dfs$ 结束后将栈内所有剩余节点归入已经分好的最后一个块即可。\n    \n- 证明：\n\n\t- 显然，每个块的大小 $|S| \\ge B$。\n   \n   - 由上述构造方式可知 $now$ 的子节点 $v$ 对应子树中剩下的未被分块的节点个数小于 $B$，而每次栈中剩下元素，即之前处理完的子树中未被分块的节点，其数目是小于 $B$ 的，故合并后得到的块的大小小于 $2B$。\n   - $dfs$ 结束后，已经分好的块的大小都小于$2B$, 剩下的未分块的节点数小于 $B$, 故最后一个块的大小小于 $3B$。\n   - 综上可知，每个块大小在 $[B,3B]$ 之间，满足题目要求。\n\n\n## Code\n```cpp 王室联邦\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1e3 + 5;\n\nint n, b, ans, u, v;\nint p[MAXN], pro[MAXN], belong[MAXN];\n\ntemplate <class T>\nvoid read(T &x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct edge {\n    int to, nxt;\n} e[MAXN << 1];\n\nvoid addEdge(int from, int to) {\n    static int t;\n    e[t].to = to, e[t].nxt = p[from], p[from] = t++;\n}\n\nstack<int> s;\nvoid dfs(int now, int fa) {\n    int tmp = s.size();\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (to != fa) {\n            dfs(to, now);\n            if (s.size() - tmp >= b) {\n                pro[++ans] = now;\n                while (s.size() > tmp) {\n                    int cur = s.top();\n                    s.pop();\n                    belong[cur] = ans;\n                }\n            }\n        }\n    }\n    s.push(now);\n}\n\nint main() {\n    read(n), read(b);\n    fill(p, p + n + 1, -1);\n    for (int i = 1; i <= n - 1; i++) {\n        read(u), read(v);\n        addEdge(u, v), addEdge(v, u);\n    }\n    dfs(1, 1);\n    if (!ans) pro[++ans] = 1;\n    while (!s.empty()) {\n        int tmp = s.top();\n        s.pop();\n        belong[tmp] = ans;\n    }\n    printf(\"%d\\n\", ans);\n    for (int i = 1; i <= n; i++) printf(\"%d \", belong[i]);\n    printf(\"\\n\");\n    for (int i = 1; i <= ans; i++) printf(\"%d \", pro[i]);\n    return 0;\n}\n```\n# 普通树上莫队\n# SP10707 COT2 - Count on a tree II\n## Description\n[题目链接](https://www.luogu.com.cn/problem/SP10707)\n## Solution1\n采用王室联邦分块法。对于所有询问 $\\{(u_i,v_i)\\}$，按 $u_i$ 所属块编号从小到大排序，若 $u_i$ 所属块相同按 $v_i$ 所属块编号从小到大排序。至于奇偶性优化...也许有点用，还是加上吧。\n\n接下来考虑两个查询间如何转移。设 $S_{u,v}$ 为路径 $u-v$ 上的所有点的集合，$T_{u,v}$表示路径 $u-v$ 上的除 $lca(u,v)$ 外的点构成的集合。设上一次询问为 $(u,v)$，本次询问为 $(u',v')$。那么上一次询问涉及到的节点为 $S_{u,v}=T_{u,v}∪lca(u,v)$，本次询问涉及到的节点为 $S_{u',v'}=T_{u',v'}∪lca(u',v')$。定义 ⊕ 表示集合的对称差运算，由 ⊕ 的交换律和结合律，有：\n\n$T_{u',v'}=T_{u',v'}⊕T_{u,v}⊕T_{v,u}$\n\n$=(S_{u',rt}⊕S_{rt,v'})⊕(S_{u,rt}⊕S_{rt,v})⊕T_{u,v}$\n\n$=(S_{u',rt}⊕S_{u,rt})⊕(S_{rt,v}⊕S_{rt,v'})⊕T_{u,v}$\n\n$=T_{u,u'}⊕T_{v,v'}⊕T_{u,v}$\n\n$=T_{u,u'}⊕T_{v,v'}⊕S_{u,v}⊕lca(u,v)$\n\n$= S_{u',v'}⊕lca(u',v')$\n\n移项可得：$S_{u',v'}=lca(u',v')⊕lca(u,v)⊕T_{u,u'}⊕T_{v,v'}⊕S_{u,v}$\n\n求 $lca$ 可用树链剖分(相比倍增常数小)，在 $dfs$ 分块时可顺便维护。\n对于异或操作，可用一个数组记录每个节点是否在集合中。每更新一个节点，若其在集合中则将相应数值删除，否则加入集合。至于 $T_{u,u'}$ 和 $T_{v,v'}$，分别直接遍历整个链，更新直至 $lca$ 处停止即可。\n\n## Code1\n```cpp Count on a tree II\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nint n, m, B, cntB, tot;\nint val[MAXN], p[MAXN], belong[MAXN], ans[MAXN], cntC[MAXN];\nint hson[MAXN], sz[MAXN], dep[MAXN], f[MAXN], top[MAXN];\nbool vis[MAXN];\nvector<int> v;\n\ntemplate <class T>\nvoid read(T &x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct Edge {\n    int to, nxt;\n} e[MAXN * 2];\n\nstruct Query {\n    int x, y, id;\n    friend bool operator<(const Query &a, const Query &b) {\n        if (belong[a.x] == belong[b.x]) {\n            if (belong[a.x] & 1) return belong[a.y] < belong[b.y];\n            return belong[a.y] > belong[b.y];\n        }\n        return belong[a.x] < belong[b.x];\n    }\n} q[MAXN * 3];\n\nvoid addEdge(int from, int to) {\n    static int t;\n    e[t].to = to, e[t].nxt = p[from], p[from] = t++;\n}\n\nstack<int> s;\nvoid dfs(int now, int fa) {\n    sz[now] = 1, dep[now] = dep[fa] + 1, f[now] = fa;\n    int tmp = s.size();\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (to != fa) {\n            dfs(to, now);\n            sz[now] += sz[to];\n            if (!hson[now] || sz[to] > sz[hson[now]]) hson[now] = to;\n            if (s.size() - tmp >= B) {\n                cntB++;\n                while (s.size() > tmp) {\n                    int cur = s.top();\n                    s.pop();\n                    belong[cur] = cntB;\n                }\n            }\n        }\n    }\n    s.push(now);\n}\n\nvoid dfs2(int now, int tp) {\n    top[now] = tp;\n    if (!hson[now]) return;\n    dfs2(hson[now], tp);\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (to != f[now] && to != hson[now]) dfs2(to, to);\n    }\n}\n\nint lca(int u, int v) {\n    if (dep[top[u]] < dep[top[v]]) swap(u, v);\n    while (top[u] != top[v]) {\n        u = f[top[u]];\n        if (dep[top[u]] < dep[top[v]]) swap(u, v);\n    }\n    if (dep[u] < dep[v]) swap(u, v);\n    return v;\n}\n\nvoid getBlock() {\n    B = sqrt(n);\n    dfs(1, 1);\n    dfs2(1, 1);\n    if (!cntB) ++cntB;\n    while (!s.empty()) {\n        int tmp = s.top();\n        s.pop();\n        belong[tmp] = cntB;\n    }\n}\n\nvoid discretize() {\n    sort(v.begin(), v.end());\n    for (int i = 1; i <= n; i++)\n        val[i] = lower_bound(v.begin(), v.end(), val[i]) - v.begin() + 1;\n}\n\nvoid modify(int now) {\n    if (!vis[now]) {\n        ++cntC[val[now]];\n        if (cntC[val[now]] == 1) tot++;\n    } else {\n        --cntC[val[now]];\n        if (cntC[val[now]] == 0) tot--;\n    }\n    vis[now] ^= 1;\n}\n\nvoid update(int u, int v) {\n    if (dep[u] < dep[v]) swap(u, v);\n    while (dep[u] > dep[v]) modify(u), u = f[u];\n    while (u != v) modify(u), modify(v), u = f[u], v = f[v];\n}\n\nint main() {\n    read(n), read(m);\n    for (int i = 1; i <= n; i++) read(val[i]), v.push_back(val[i]);\n    discretize();\n    fill(p + 1, p + n + 1, -1);\n    int x(0), y(0);\n    for (int i = 1; i <= n - 1; i++) {\n        read(x), read(y);\n        addEdge(x, y), addEdge(y, x);\n    }\n    getBlock();\n    for (int i = 1; i <= m; i++) {\n        read(q[i].x), read(q[i].y);\n        q[i].id = i;\n    }\n    sort(q + 1, q + m + 1);\n    x = 1, y = 1;\n    modify(1);\n    for (int i = 1; i <= m; i++) {\n        int lca1 = lca(x, y), lca2 = lca(q[i].x, q[i].y);\n        update(x, q[i].x), x = q[i].x;\n        update(y, q[i].y), y = q[i].y;\n        modify(lca1), modify(lca2);\n        ans[q[i].id] = tot;\n    }\n    for (int i = 1; i <= m; i++) printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n```\n\n## Solution2\n考虑把树上的问题转化到序列上。\n\n这里引入欧拉序，它的思想是：当访问到点$i$ 时，加入序列，记录时间戳 $in[i]$，然后访问 $i$ 的子树，当访问完时，再把 $i$ 加入序列，并记录时间戳 $out[i]$。如果将一条链映射到序列中的一段区间，那么这个区间中出现两次的节点一定不属于这条链（两端点的 $lca$）除外, 这样只需要统计出现一次的节点即可。\n\n对于一条链 $(u,v)$，设 $in[u]<in[v]$，讨论两种情况：\n- $lca(u,v)=u$，统计欧拉序在 $[in[u],in[v]]$ 的节点即可。\n- $lca(u,v)\\neq u$，统计欧拉序在 $[out[u],in[v]]$ 的节点，同时加上 $lca(u,v)$ 即可。\n\n注：\n- 这里求 $lca$ 依然使用树链剖分。\n- 对于上述第二种情况，不取 $[in[u],in[v]]$ 是因为这样会导致 $u$ 在序列中出现两次。另外， $(in[u],out[u])$ 间的节点在 $u$ 的子树中，这些节点显然没有必要统计。\n- 分块时需要注意序列长度为 $2n$。\n\n## Code2\n```cpp Count on a tree II\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nint n, m, B, tot;\nint val[MAXN], p[MAXN], in[MAXN], out[MAXN], from[MAXN * 2];\nint belong[MAXN * 2], ans[MAXN], cntC[MAXN];\nint hson[MAXN], sz[MAXN], dep[MAXN], f[MAXN], top[MAXN];\nbool vis[MAXN];\nvector<int> v;\n\ntemplate <class T>\nvoid read(T &x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct Edge {\n    int to, nxt;\n} e[MAXN * 2];\n\nstruct Query {\n    int l, r, id, lca;\n    friend bool operator<(const Query &a, const Query &b) {\n        if (belong[a.l] == belong[b.l]) {\n            if (belong[a.l] & 1) return belong[a.r] < belong[b.r];\n            return belong[a.r] > belong[b.r];\n        }\n        return belong[a.l] < belong[b.l];\n    }\n} q[MAXN * 3];\n\nvoid addEdge(int from, int to) {\n    static int t;\n    e[t].to = to, e[t].nxt = p[from], p[from] = t++;\n}\n\nvoid dfs(int now, int fa) {\n    static int tim = 1;\n    in[now] = tim, from[tim++] = now;\n    sz[now] = 1, dep[now] = dep[fa] + 1, f[now] = fa;\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (to != fa) {\n            dfs(to, now);\n            sz[now] += sz[to];\n            if (!hson[now] || sz[to] > sz[hson[now]]) hson[now] = to;\n        }\n    }\n    out[now] = tim, from[tim++] = now;\n}\n\nvoid dfs2(int now, int tp) {\n    top[now] = tp;\n    if (!hson[now]) return;\n    dfs2(hson[now], tp);\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (to != f[now] && to != hson[now]) dfs2(to, to);\n    }\n}\n\nint lca(int u, int v) {\n    if (dep[top[u]] < dep[top[v]]) swap(u, v);\n    while (top[u] != top[v]) {\n        u = f[top[u]];\n        if (dep[top[u]] < dep[top[v]]) swap(u, v);\n    }\n    if (dep[u] < dep[v]) swap(u, v);\n    return v;\n}\n\nvoid discretize() {\n    sort(v.begin(), v.end());\n    for (int i = 1; i <= n; i++)\n        val[i] = lower_bound(v.begin(), v.end(), val[i]) - v.begin() + 1;\n}\n\nvoid modify(int now) {\n    if (!vis[now]) {\n        ++cntC[val[now]];\n        if (cntC[val[now]] == 1) tot++;\n    } else {\n        --cntC[val[now]];\n        if (cntC[val[now]] == 0) tot--;\n    }\n    vis[now] ^= 1;\n}\n\nint main() {\n    read(n), read(m);\n    for (int i = 1; i <= n; i++) read(val[i]), v.push_back(val[i]);\n    discretize();\n    fill(p + 1, p + n + 1, -1);\n    int x(0), y(0);\n    for (int i = 1; i <= n - 1; i++) {\n        read(x), read(y);\n        addEdge(x, y), addEdge(y, x);\n    }\n    B = max(1, 2 * n / (int)sqrt(m));\n    dfs(1, 1), dfs2(1, 1);\n    for (int i = 1; i <= m; i++) {\n        read(x), read(y);\n        if (in[x] > in[y]) swap(x, y);\n        q[i].lca = lca(x, y);\n        if (q[i].lca == x) {\n            q[i].l = in[x];\n            q[i].r = in[y];\n            q[i].lca = 0;\n        } else {\n            q[i].l = out[x];\n            q[i].r = in[y];\n        }\n        q[i].id = i;\n    }\n    for (int i = 1; i <= 2 * n; i++) belong[i] = (i - 1) / B + 1;\n    sort(q + 1, q + m + 1);\n    x = 1, y = 0;\n    for (int i = 1; i <= m; i++) {\n        while (x < q[i].l) modify(from[x++]);\n        while (x > q[i].l) modify(from[--x]);\n        while (y > q[i].r) modify(from[y--]);\n        while (y < q[i].r) modify(from[++y]);\n        if (q[i].lca) modify(q[i].lca);\n        ans[q[i].id] = tot;\n        if (q[i].lca) modify(q[i].lca);\n    }\n    for (int i = 1; i <= m; i++) printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n```\n\n注：本题有在线做法，以后有空再补上。\n\n# 树上带修莫队\n处理方法和序列上的莫队相同，对每个询问增加一维时间。\n\n# P4074 [WC2013]糖果公园\n## Description\n[题目链接](https://www.luogu.com.cn/problem/P4074)\n## Hint\n记录每个询问之前的修改次数，排序的时候以修改次数为第三关键字排序即可。查询的时候，如果多修改了则回退，否则对未修改的部分进行修改，当修改位置在本次查询区间内时对答案进行更新。\n## Solution1\n求欧拉序后转化为区间问题。\n## Code1\n```cpp 糖果公园（欧拉序）\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5 + 5;\nint n, m, Q, B, type, cntQ, cntR;\nint C[MAXN], V[MAXN], W[MAXN];\nll tot, ans[MAXN];\nint p[MAXN], in[MAXN], out[MAXN], from[MAXN * 2];\nint belong[MAXN * 2], cntC[MAXN];\nint hson[MAXN], sz[MAXN], dep[MAXN], f[MAXN], top[MAXN];\nbool vis[MAXN];\n\ntemplate <class T>\nvoid read(T &x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct Edge {\n    int to, nxt;\n} e[MAXN * 2];\n\nstruct Query {\n    int l, r, id, lca, t;\n    friend bool operator<(const Query &a, const Query &b) {\n        if (belong[a.l] == belong[b.l]) {\n            if (belong[a.r] == belong[b.r]) return a.t < b.t;\n            if (belong[a.l] & 1) return belong[a.r] < belong[b.r];\n            return belong[a.r] > belong[b.r];\n        }\n        return belong[a.l] < belong[b.l];\n    }\n} q[MAXN];\n\nstruct Replace {\n    int id, type;\n} r[MAXN];\n\nvoid addEdge(int from, int to) {\n    static int t;\n    e[t].to = to, e[t].nxt = p[from], p[from] = t++;\n}\n\nvoid dfs(int now, int fa) {\n    static int tim = 1;\n    in[now] = tim, from[tim++] = now;\n    sz[now] = 1, dep[now] = dep[fa] + 1, f[now] = fa;\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (to != fa) {\n            dfs(to, now);\n            sz[now] += sz[to];\n            if (!hson[now] || sz[to] > sz[hson[now]]) hson[now] = to;\n        }\n    }\n    out[now] = tim, from[tim++] = now;\n}\n\nvoid dfs2(int now, int tp) {\n    top[now] = tp;\n    if (!hson[now]) return;\n    dfs2(hson[now], tp);\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (to != f[now] && to != hson[now]) dfs2(to, to);\n    }\n}\n\nint lca(int u, int v) {\n    if (dep[top[u]] < dep[top[v]]) swap(u, v);\n    while (top[u] != top[v]) {\n        u = f[top[u]];\n        if (dep[top[u]] < dep[top[v]]) swap(u, v);\n    }\n    if (dep[u] < dep[v]) swap(u, v);\n    return v;\n}\n\nvoid modify(int now) {\n    if (!vis[now]) {\n        ++cntC[C[now]];\n        tot += 1ll * W[cntC[C[now]]] * V[C[now]];\n    } else {\n        tot -= 1ll * W[cntC[C[now]]] * V[C[now]];\n        --cntC[C[now]];\n    }\n    vis[now] ^= 1;\n}\n\nvoid change(Replace &rep) {\n    if (vis[rep.id]) {\n        modify(rep.id);\n        swap(rep.type, C[rep.id]);\n        modify(rep.id);\n    } else\n        swap(rep.type, C[rep.id]);\n}\n\nint main() {\n    read(n), read(m), read(Q);\n    fill(p + 1, p + n + 1, -1);\n    for (int i = 1; i <= m; i++) read(V[i]);\n    for (int i = 1; i <= n; i++) read(W[i]);\n    int x, y, t;\n    for (int i = 1; i <= n - 1; i++) {\n        read(x), read(y);\n        addEdge(x, y), addEdge(y, x);\n    }\n    for (int i = 1; i <= n; i++) read(C[i]);\n    B = pow(n, 2.0 / 3);  //不要忘了.0!\n    dfs(1, 1), dfs2(1, 1);\n    for (int i = 1; i <= Q; i++) {\n        read(type);\n        if (type == 1) {\n            cntQ++;\n            read(x), read(y);\n            if (in[x] > in[y]) swap(x, y);\n            q[cntQ].lca = lca(x, y);\n            if (q[cntQ].lca == x) {\n                q[cntQ].l = in[x];\n                q[cntQ].r = in[y];\n                q[cntQ].lca = 0;\n            } else {\n                q[cntQ].l = out[x];\n                q[cntQ].r = in[y];\n            }\n            q[cntQ].id = cntQ;\n            q[cntQ].t = cntR;\n        } else {\n            cntR++;\n            read(x), read(y);\n            r[cntR].id = x, r[cntR].type = y;\n        }\n    }\n    for (int i = 1; i <= 2 * n; i++) belong[i] = (i - 1) / B + 1;\n    sort(q + 1, q + cntQ + 1);\n    x = 1, y = 0, t = 0;\n    for (int i = 1; i <= cntQ; i++) {\n        while (x < q[i].l) modify(from[x++]);\n        while (x > q[i].l) modify(from[--x]);\n        while (y > q[i].r) modify(from[y--]);\n        while (y < q[i].r) modify(from[++y]);\n        while (t < q[i].t) change(r[++t]);\n        while (t > q[i].t) change(r[t--]);\n        if (q[i].lca) modify(q[i].lca);\n        ans[q[i].id] = tot;\n        if (q[i].lca) modify(q[i].lca);\n    }\n    for (int i = 1; i <= cntQ; i++) printf(\"%lld\\n\", ans[i]);\n    return 0;\n}\n```\n\n## Solution2\n采用王室联邦分块法。也许是我写假了，跑得巨慢...\n## Code2\n```cpp 糖果公园(王室联邦分块)\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5 + 5;\nint n, m, Q, B, type, cntQ, cntR, cntB;\nint C[MAXN], V[MAXN], W[MAXN];\nll tot, ans[MAXN];\nint p[MAXN];\nint belong[MAXN], cntC[MAXN];\nint hson[MAXN], sz[MAXN], dep[MAXN], f[MAXN], top[MAXN];\nbool vis[MAXN];\n\ntemplate <class T>\nvoid read(T &x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct Edge {\n    int to, nxt;\n} e[MAXN * 2];\n\nstruct Query {\n    int x, y, id, t;\n    friend bool operator<(const Query &a, const Query &b) {\n        if (belong[a.x] == belong[b.x]) {\n            if (belong[a.y] == belong[b.y]) return a.t < b.t;\n            if (belong[a.x] & 1) return belong[a.y] < belong[b.y];\n            return belong[a.y] > belong[b.y];\n        }\n        return belong[a.x] < belong[b.x];\n    }\n} q[MAXN];\n\nstruct Replace {\n    int id, type;\n} r[MAXN];\n\nvoid addEdge(int from, int to) {\n    static int t;\n    e[t].to = to, e[t].nxt = p[from], p[from] = t++;\n}\n\nstack<int> s;\nvoid dfs(int now, int fa) {\n    sz[now] = 1, dep[now] = dep[fa] + 1, f[now] = fa;\n    int tmp = s.size();\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (to != fa) {\n            dfs(to, now);\n            sz[now] += sz[to];\n            if (!hson[now] || sz[to] > sz[hson[now]]) hson[now] = to;\n            if (s.size() - tmp >= B) {\n                cntB++;\n                while (s.size() > tmp) {\n                    int cur = s.top();\n                    s.pop();\n                    belong[cur] = cntB;\n                }\n            }\n        }\n    }\n    s.push(now);\n}\n\nvoid dfs2(int now, int tp) {\n    top[now] = tp;\n    if (!hson[now]) return;\n    dfs2(hson[now], tp);\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (to != f[now] && to != hson[now]) dfs2(to, to);\n    }\n}\n\nint lca(int u, int v) {\n    if (dep[top[u]] < dep[top[v]]) swap(u, v);\n    while (top[u] != top[v]) {\n        u = f[top[u]];\n        if (dep[top[u]] < dep[top[v]]) swap(u, v);\n    }\n    if (dep[u] < dep[v]) swap(u, v);\n    return v;\n}\n\nvoid getBlock() {\n    B = sqrt(n);\n    dfs(1, 1);\n    dfs2(1, 1);\n    if (!cntB) ++cntB;\n    while (!s.empty()) {\n        int tmp = s.top();\n        s.pop();\n        belong[tmp] = cntB;\n    }\n}\n\nvoid modify(int now) {\n    if (!vis[now]) {\n        ++cntC[C[now]];\n        tot += 1ll * W[cntC[C[now]]] * V[C[now]];\n    } else {\n        tot -= 1ll * W[cntC[C[now]]] * V[C[now]];\n        --cntC[C[now]];\n    }\n    vis[now] ^= 1;\n}\n\nvoid update(int u, int v) {\n    if (dep[u] < dep[v]) swap(u, v);\n    while (dep[u] > dep[v]) modify(u), u = f[u];\n    while (u != v) modify(u), modify(v), u = f[u], v = f[v];\n}\n\nvoid change(Replace &rep) {\n    if (vis[rep.id]) {\n        modify(rep.id);\n        swap(rep.type, C[rep.id]);\n        modify(rep.id);\n    } else\n        swap(rep.type, C[rep.id]);\n}\n\nint main() {\n    read(n), read(m), read(Q);\n    fill(p + 1, p + n + 1, -1);\n    for (int i = 1; i <= m; i++) read(V[i]);\n    for (int i = 1; i <= n; i++) read(W[i]);\n    int x, y, t;\n    for (int i = 1; i <= n - 1; i++) {\n        read(x), read(y);\n        addEdge(x, y), addEdge(y, x);\n    }\n    for (int i = 1; i <= n; i++) read(C[i]);\n    B = pow(n, 2.0 / 3);\n    getBlock();\n    for (int i = 1; i <= Q; i++) {\n        read(type);\n        if (type == 1) {\n            cntQ++;\n            read(x), read(y);\n            q[cntQ].x = x, q[cntQ].y = y;\n            q[cntQ].id = cntQ;\n            q[cntQ].t = cntR;\n        } else {\n            cntR++;\n            read(x), read(y);\n            r[cntR].id = x, r[cntR].type = y;\n        }\n    }\n    sort(q + 1, q + cntQ + 1);\n    x = 1, y = 1, t = 0;\n    modify(1);\n    for (int i = 1; i <= cntQ; i++) {\n        int lca1 = lca(x, y), lca2 = lca(q[i].x, q[i].y);\n        update(x, q[i].x), x = q[i].x;\n        update(y, q[i].y), y = q[i].y;\n        modify(lca1), modify(lca2);\n        while (t < q[i].t) change(r[++t]);\n        while (t > q[i].t) change(r[t--]);\n        ans[q[i].id] = tot;\n    }\n    for (int i = 1; i <= cntQ; i++) printf(\"%lld\\n\", ans[i]);\n    return 0;\n}\n```\n\n","tags":["树分块","树上莫队"],"categories":["数据结构","分块","树上莫队","树分块"]},{"title":"CF1320C World of Darkraft-Battle for Azathoth","url":"/2020/09/03/Battle-for-Azathoth/","content":"# World of Darkraft-Battle for Azathoth\n  - [题目链接](https://www.luogu.com.cn/problem/CF1320C)\n  - 数据结构/线段树\n\n<!-- more -->\n# Description\n给定 n 种武器(攻击为 $x_i$， 价格为 $c_i$)，m 种(防御为 $y_j$，$c_j$)防具， p 个怪物(防御为 $x_k$， 攻击 $y_k$， 金币 $z_k$)。\n\n你必须选择一个武器(攻击力为 $x$)和一个防具(防御为 $y$)， 一个怪物 $k$ 能被击杀，当且仅当 $x > x_k$ 并且 $y > y_k$。求最大收益(可能为负)。\n# Solution\n  - 将怪物按照防御 $y_k$ 排序，从小到大处理(类似扫描线)。\n    ```cpp\n    for (int i = 0, v, c; i < n; i++) //武器与怪物防御力放在一起排序\n        read(v), read(c), vec.emplace_back(make_pair(v - 1, make_pair(Inf, c)));\n    for(...) vec.emplace_back(make_pair(def, make_pair(atk, c)));\n    ```\n  - 找到最小的 $j$ 使得 $y_j > y_k$，则编号 $\\ge j$ 的所有防具获得的金币 $D_j$ 都加上 $z_k$(金币初始值为 $-c_j$)。\n  - upper_bound 找到 $x_i > x$， 则最大获利为$-c_i + \\max D_j$。\n  - 按防具下标建立线段树维护最大值, 支持区间增值即可。\n\n注意：\n  - 最大收益可能为-2e9。\n  - 对pair排序以及upper_bound, 为防止临时变量第二关键值影响需将其设为Inf\n  ``int pos = upper_bound(armor.begin(), armor.end(), make_pair(y, Inf)) - armor.begin();``\n# Code\n```cpp World of Darkraft-Battle for Azathoth\n#include <bits/stdc++.h>\n\nconstexpr int MAXN = 2e5 + 5;\nconstexpr int Inf = 0x7fffffff;\n\nusing namespace std;\nusing LL = long long;\n\ntemplate <typename T>\ninline void read(T &x) {\n    int f = 1;\n    x = 0;\n    char ch = getchar();\n    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct segTree {\n    segTree *Lson, *Rson;\n    int l, r;\n    int max, tag;\n} Tree[MAXN << 1];\nint tot, n, m, p, ans = -Inf;\nvector<pair<int, int> > weapon, armor;\nvector<pair<int, pair<int, int> > > vec;\n\nusing Node = segTree *;\n#define Lson root->Lson\n#define Rson root->Rson\ninline void build(int L, int R, Node root) {\n    root->l = L, root->r = R;\n    if (L == R) {\n        root->max = -armor[L].second;\n        return;\n    }\n    int mid = (L + R) >> 1;\n    Lson = &Tree[++tot], Rson = &Tree[++tot];\n    build(L, mid, Lson), build(mid + 1, R, Rson);\n    root->max = max(Lson->max, Rson->max);\n}\n\ninline void pushTag(Node root) {\n    if (!root->tag) return;\n    Lson->tag += root->tag, Lson->max += root->tag;\n    Rson->tag += root->tag, Rson->max += root->tag;\n    root->tag = 0;\n}\n\ninline void change(int L, int R, int val, Node root) {\n    if (L <= root->l && root->r <= R) {\n        root->max += val, root->tag += val;\n        return;\n    }\n    pushTag(root);\n    int mid = (root->l + root->r) >> 1;\n    if (L <= mid) change(L, R, val, Lson);\n    if (R > mid) change(L, R, val, Rson);\n    root->max = max(Lson->max, Rson->max);\n}\n\nint main() {\n    read(n), read(m), read(p);\n    for (int i = 0, v, c; i < n; i++)  //武器与怪物防御力放在一起排序\n        read(v), read(c), vec.emplace_back(make_pair(v - 1, make_pair(Inf, c)));\n    for (int i = 0, v, c; i < m; i++)\n        read(v), read(c), armor.emplace_back(make_pair(v, c));\n    sort(armor.begin(), armor.end());  //防具按防御值升序排序\n    build(0, m - 1, Tree);             //按防具下标建树\n    for (int i = 0, def, atk, c; i < p; i++) {\n        read(def), read(atk), read(c);\n        vec.emplace_back(make_pair(def, make_pair(atk, c)));\n    }\n    sort(vec.begin(), vec.end());\n    for (auto &i : vec) {\n        int x = i.first, y = i.second.first, c = i.second.second;\n        if (y == Inf) {  // y = inf表明这是一个武器\n            ans = max(ans, -c + Tree->max);\n            continue;\n        }\n        int pos = upper_bound(armor.begin(), armor.end(), make_pair(y, Inf)) -\n                  armor.begin();\n        if (pos < m) change(pos, m - 1, c, Tree);  //后缀区间增值\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n","tags":["线段树"],"categories":["数据结构","线段树"]},{"title":"CF1320B Navigation System","url":"/2020/09/03/Navigation-System/","content":"[题目链接](https://www.luogu.com.cn/problem/CF1320B)\n<!-- more -->\n# Solution\nRebuild 最少：若有多条最短路，让每次导航恰好取和工作路径部分重合或完全重合的最短路。如果当前节点经工作路径到终点的距离大于到该点的最短路，且该节点到终点的最短路、工作路径没有公共前缀，一定会 Rebuild，有交集就不 Rebuild; 如果工作路径和最短路完全重合，则不会再 Rebuild，beak即可。\n\nRebuild 最多：若有多条最短路，让每次导航优尽量取在工作路径外的最短路。如果当前节点经工作路径到终点的距离大于到该点的最短路，且该节点到终点的最短路、工作路径没有公共前缀，一定 Rebuild ; 若当前节点经工作路径到终点的距离等于到该点的最短路，且有多条最短路优先取工作路径以外的, 若仅有一条最短路，即只能取在工作路径上的，则不会再 Rebuild，beak即可。\n\n# Code\n```cpp Navigation System\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 2e5 + 5;\n\nint n, m, c;\nvector<int> G[MAXN];\narray<int, MAXN> dis, inq, id, onChain, outChain, chain, chainDis;\n\ninline void spfa(int st) {\n    fill(dis.begin(), dis.begin() + n + 1, 1e9);\n    deque<int> q;\n    q.push_back(st), dis[st] = 0;\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop_front(), inq[cur] = false;\n        for (auto& to : G[cur]) {\n            if (dis[to] > dis[cur] + 1) {\n                dis[to] = dis[cur] + 1;\n                onChain[to] = outChain[to] = 0;\n                if (id[to] && id[cur] && id[cur] - 1 == id[to]) onChain[to] = 1;\n                else outChain[to] = 1;\n                if (!inq[to]) { //slf\n                    if (q.empty() || dis[to] < dis[q.front()]) q.push_front(to);\n                    else q.push_back(to);\n                    inq[to] = true;\n                }\n            } else if (dis[to] == dis[cur] + 1) { //多条最短路\n                if (id[to] && id[cur] && id[cur] - 1 == id[to]) onChain[to] = 1;\n                else outChain[to] = 1; //不在链上\n            }\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1, u, v; i <= m; i++) cin >> u >> v, G[v].push_back(u);\n    cin >> c;\n    for (int i = 1; i <= c; i++) cin >> chain[i], id[chain[i]] = i;\n    spfa(chain[c]); //处理最短路\n    for (int i = c - 1; i >= 1; i--) //处理工作路径到终点的距离\n        chainDis[chain[i]] = chainDis[chain[i + 1]] + 1;\n    int min = 0, max = 0;\n    for (int i = 1; i < c; i++) {\n        if (chainDis[chain[i]] > dis[chain[i]]) {\n            if (!onChain[chain[i]]) min++;\n        } else break;\n    }\n    for (int i = 1; i < c; i++) {\n        if (chainDis[chain[i]] > dis[chain[i]]) {\n            if (outChain[chain[i]]) max++;\n        } else {\n            if (outChain[chain[i]]) max++; //有多条最短路\n            else break;\n        }\n    }\n    cout << min << \" \" << max << endl;\n    return 0;\n}\n```\n","tags":["最短路","贪心"],"categories":["图论","最短路","贪心"]},{"title":"CF1000F One Occurrence","url":"/2020/09/02/One-Occurrence/","content":"# One Occurrence\n  - [题目链接](https://www.luogu.com.cn/problem/CF1000F)\n  - 数据结构/线段树/可持久化线段树\n  - 数据结构/莫队/栈\n\n<!-- more -->\n# Description\n多次询问区间中只出现一次的任意一个数。\n# Solution\n可持久化线段树做法：\n对下标建立可持久化线段树。令 $pre_{a_i}$ 表示 $a_i$ 出现的上一个位置，初始值为 0。如果 $a_i$ 出现过，则将 $pre_{a_i}$ 位置的值修改为 INF。如果一个数在 $[l, r]$ 只出现了一次，那么在该区间中一定有 $pre < l$。对 $root_r$ 进行区间 $[l, r]$ 查询返回下标即可。\n莫队 + 栈 (惰性删除)：\n维护每个数出现次数 $cnt_i$， 如果一个数出现次数等于 1，则将其进栈。如果一个数的出现次数由 1 变为 0 或 变为 2 时，令 $deleted_i ++$，表示删除一次，不直接在栈中操作。查询时，如果栈顶的数 i 的 $deleted_i > 0$ 说明要出栈，一直弹到 $deleted_i = 0$ 为止。\n# Code\n```cpp One Occurrence (Persistent Segment Tree)\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 5e5 + 5;\n\ntemplate<typename T>\ninline void read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct SegTree {\n    SegTree * lson, *rson;\n    int min = 1e9;\n} *root[MAXN], tree[MAXN * 60];\nint n, m, pre[MAXN], arr[MAXN];\n\ninline SegTree* newNode (SegTree*& root) {\n    static int tot;\n    return root = &tree[tot++];\n}\n\ninline void build(SegTree* root, int L, int R) {\n    if (L == R) return;\n    int mid = (L + R) >> 1;\n    build(newNode(root->lson), L, mid);\n    build(newNode(root->rson), mid + 1, R);\n}\n\ninline void modify (SegTree* pre, SegTree*& root, int L, int R, int pos, int val) {\n    root = newNode(root), *root = *pre;\n    if (L == pos && R == pos) {\n        root->min = val;\n        return;\n    }\n    int mid = (L + R) >> 1;\n    if (pos <= mid) modify(pre->lson, root->lson, L, mid, pos, val);\n    else modify(pre->rson, root->rson, mid + 1, R, pos, val);\n    root->min = min(root->lson->min, root->rson->min);\n}\n\ninline int query(SegTree* root, int L, int R, int qL, int qR) {\n    if (L > qR || R < qL || root->min >= qL) return 0;\n    if (L == R) return L;\n    int mid = (L + R) >> 1;\n    int tmp = query(root->lson, L, mid, qL, qR);\n    if (!tmp) return query(root->rson, mid + 1, R, qL, qR);\n    return tmp;\n}\n\nint main() {\n    read(n);\n    build(newNode(root[0]), 1, n);\n    for (int i = 1; i <= n; i++) {\n        read(arr[i]);\n        root[i] = root[i - 1];\n        if (pre[arr[i]]) modify(root[i], root[i], 1, n, pre[arr[i]], 1e9);\n        modify(root[i], root[i], 1, n, i, pre[arr[i]]);\n        pre[arr[i]] = i;\n    }\n    read(m);\n    while (m--) {\n        int l, r;\n        read(l), read(r);\n        printf(\"%d\\n\", arr[query(root[r], 1, n, l, r)]);\n    }\n    return 0;\n}\n```\n","tags":["可持久化线段树","莫队"],"categories":["数据结构","线段树","分块","可持久化线段树","莫队","栈"]},{"title":"UVA12436 Rip Van Winkle's Code","url":"/2020/09/02/Rip-Van-Winkle-Code/","content":"# Rip Van Winkle's Code\n  - [题目链接](https://www.luogu.com.cn/problem/UVA12436)\n  - 线段树\n\n<!-- more -->\n# Description\n有一个序列初始值全为零，现有一下四种操作：\n  - A l r 将区间 $[l, r]$ 加上等差数列 $1, 2, ..., r - l + 1$\n  - B l r 将区间 $[l, r]$ 加上等差数列 $r - l + 1, r - l, ..., 1$\n  - C l r x 将区间 $[l, r]$ 赋值 $x$\n  - S l r 求区间 $[l, r]$ 的和\n\n# Solution\n难点在于区间加等差数列。\n用 $Lval$ 表示表示该区间增加的等差数列的首项标记，$tag2$ 表示表示该区间增加的等差数列的公差标记。因为一个加上等差数列的区间依旧是一个等差数列区间，于是两个标记可以累加。左右儿子增加的 $sum$ 由父亲节点的 $Lval$ 和 $tag2$ 推出。\n注意：$Lval$ 和 $tag2$ 都为 0 时标记不用下放；当有区间赋值标记时，等差数列标记无效，赋为 0。\n# Code\n```cpp Rip Van Winkle's Code\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconstexpr int MAXN = 3e5 + 5;\n\ntemplate <typename T>\ninline void read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct SegTree {\n    SegTree *lson, *rson;\n    int l, r;\n    int sum, Lval; // sum为区间和，Lval为增加的等差数列首项标记\n    int tag1 = 1e18, tag2;  // tag1为区间赋值标记，tag2为公差标记\n} * root, tree[MAXN << 1];\n\ninline SegTree* newNode(SegTree*& root) {\n    static int tot;\n    return root = &tree[tot++];\n}\n\ninline void update(SegTree* root) {\n    root->sum = root->lson->sum + root->rson->sum;\n}\n\ninline int size(SegTree* root) { return root->r - root->l + 1; }\n/*等差数列求和 @param Lval 首项 @param d 公差 @param len 项数*/\ninline int sum(int Lval, int d, int len) {\n    return Lval * len + d * len * (len - 1) / 2;\n}\n\ninline void build(SegTree* root, int l, int r) {\n    root->l = l, root->r = r;\n    if (l == r) return;\n    int mid = (l + r) >> 1;\n    build(newNode(root->lson), l, mid);\n    build(newNode(root->rson), mid + 1, r);\n}\n\ninline void pushTag(SegTree* root) {\n    if (root->tag1 != 1e18) {  //区间修改\n        root->lson->tag1 = root->tag1, root->rson->tag1 = root->tag1;\n        //区间修改后首项 公差为 0\n        root->lson->Lval = root->rson->Lval = 0;\n        root->lson->tag2 = root->rson->tag2 = 0;\n\n        root->lson->sum = root->tag1 * size(root->lson);\n        root->rson->sum = root->tag1 * size(root->rson);\n        root->tag1 = 1e18;\n    }\n    if (root->tag2 || root->Lval) {  //区间等差数列\n        root->lson->tag2 += root->tag2, root->rson->tag2 += root->tag2;\n\n        root->lson->Lval += root->Lval;\n        root->rson->Lval += root->Lval + root->tag2 * size(root->lson);\n        //注意是从父亲root->Lval累加下来 新增的等差数列求和\n        root->lson->sum += sum(root->Lval, root->tag2, size(root->lson));\n        root->rson->sum += sum(root->Lval + root->tag2 * size(root->lson),\n                               root->tag2, size(root->rson));\n        root->tag2 = root->Lval = 0;  //两个都要清零\n    }\n}\n\ninline void modify(SegTree* root, int l, int r, int val, int type) {\n    if (l <= root->l && root->r <= r) {\n        if (type == 1) {  //区间赋值\n            root->sum = val * size(root);\n            root->tag1 = val;\n            root->Lval = root->tag2 = 0;  //!\n        } else if (type == 2) {           //区间增加等差数列 公差 1\n            root->Lval += root->l - l + val;\n            root->tag2++;\n            root->sum += sum(root->l - l + val, 1, size(root));\n        } else {  //区间增加等差数列 公差 -1\n            root->Lval += l - root->l + val;\n            root->tag2--;\n            root->sum += sum(l - root->l + val, -1, size(root));\n        }\n        return;\n    }\n    pushTag(root);\n    int mid = (root->l + root->r) >> 1;\n    if (l <= mid) modify(root->lson, l, r, val, type);\n    if (r > mid) modify(root->rson, l, r, val, type);\n    update(root);\n}\n\ninline int query(SegTree* root, int l, int r) {  //查询求和\n    if (l <= root->l && root->r <= r) return root->sum;\n    pushTag(root);\n    int mid = (root->l + root->r) >> 1, res = 0;\n    if (l <= mid) res += query(root->lson, l, r);\n    if (r > mid) res += query(root->rson, l, r);\n    return res;\n}\n\nsigned main() {\n    int n;\n    read(n);\n    build(newNode(root), 1, 250000);\n    char opt[2];\n    for (int i = 1, l, r, x; i <= n; i++) {\n        scanf(\"%s\", opt), read(l), read(r);\n        if (opt[0] == 'A') modify(root, l, r, 1, 2);\n        else if (opt[0] == 'B') modify(root, l, r, r - l + 1, 3);\n        else if (opt[0] == 'C') read(x), modify(root, l, r, x, 1);\n        else printf(\"%lld\\n\", query(root, l, r));\n    }\n    return 0;\n}\n```\n","tags":["线段树"],"categories":["数据结构","线段树"]},{"title":"AtCoder Beginner Contest 177","url":"/2020/08/31/atcoder-abc-177/","content":"[比赛链接](https://atcoder.jp/contests/abc177)\n<!-- more -->\n# D Friends\n## Description\n[题目链接](https://atcoder.jp/contests/abc177/tasks/abc177_d)\n## Solution\n并查集处理每个联通块大小。设最大联通块大小为 $S$，那么属于这个联通块的人不能分在一组，所以至少分成 $S$ 组，而对于大小为 $T < S$ 的联通块，将块中 $T$ 个人分配到之前分好的 $S$ 组，且每组至多分配一人即可。故答案为最大联通块的大小。\n## Code\n```cpp Friends\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nint n, m, a, b, fa[MAXN], sz[MAXN], ans;\n\ninline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\ninline void unionn(int a, int b) {\n    int r1 = find(a), r2 = find(b);\n    if (r1 != r2) fa[r1] = r2, sz[r2] += sz[r1];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) fa[i] = i, sz[i] = 1;\n    for (int j = 1; j <= m; j++) cin >> a >> b, unionn(a, b);\n    for (int i = 1; i <= n; i++)\n        if (fa[i] == i) ans = max(ans, sz[i]);\n    cout << ans;\n    return 0;\n}\n```\n\n# E Coprime\n## Description\n[题目链接](https://atcoder.jp/contests/abc177/tasks/abc177_e)\n## Solution\n$a_i$ 和 $∀a_j(j>i)$ 互质当且仅当对 $∀j>i,a_j$ 和 $a_i$ 没有相同的质因数。可以 $O(nlnn)$ 处理出每个数的所有约数，或者线性筛素数并 $O(n)$ 预处理出 $[2, 10^6]$ 每个数的质因数后，对每个质因数的数目记录后缀和 $O(n)$ 扫一遍即可。\n## Code\n```cpp Coprime\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e6 + 5;\n\nint n, a[MAXN], cnt[MAXN], gcdd;\nvector<int> v[MAXN];\n\ntemplate <class T>\nvoid read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nbool isprime(int x) {\n    for (int i = 2; i <= sqrt(x); i++)\n        if (x % i == 0) return false;\n    return true;\n}\n\nvoid init() {\n    for (int i = 2; i <= MAXN - 5; i++)\n        if (isprime(i))\n            for (int k = 1; k * i <= MAXN - 5; k++) v[k * i].push_back(i);\n}\n\nint main() {\n    init();\n    read(n);\n    for (int i = 1; i <= n; i++) read(a[i]);\n    bool tag = 1;\n    for (int i = n; i >= 1; i--) {\n        for (int j = 0; j < v[a[i]].size(); j++)\n            if (cnt[v[a[i]][j]]) {\n                tag = 0;\n                break;\n            }\n        for (int j = 0; j < v[a[i]].size(); j++) cnt[v[a[i]][j]]++;\n    }\n    gcdd = a[1];\n    for (int i = 2; i <= n; i++) gcdd = __gcd(a[i], gcdd);\n    if (tag)\n        cout << \"pairwise coprime\";\n    else if (gcdd == 1)\n        cout << \"setwise coprime\";\n    else\n        cout << \"not coprime\";\n    return 0;\n}\n```\n\n\n\n# F I hate Shortest Path Problem\n## Description\n[题目链接](https://atcoder.jp/contests/abc177/tasks/abc177_f)\n\n## Solution\n设 $a[i][j]$ 表示到第 $i$ 行第 $j$ 列需要往右移动的最少次数，由题意可知，$a[1]=0$。之后的状态转移分以下两种情况：\n- $a[i][j]=a[i-1][j],j∈[1,A_{i-1}-1]∪[B_{i-1}+1,w]$\n- $a[i][j]=a[i-1][A_{i-1}-1]+j-A_{i-1}+1,j∈[A_{i-1},B_{i-1}]$\n\n需要注意的是，若 $A_{i-1}=1$，那么对 $j∈[A_{i-1},B_{i-1}]$ 是无法抵达的，这时需要把距离设为 $INF$。  \n\n设 $dp[i]$ 表示到第 $i$ 行所需要的最少移动次数。由于一定会往下移动 $i-1$ 次，所以只需要考虑至少要往右移动的次数。故 $dp[i]=i-1+\\min \\limits_{1 \\le j \\le w}a[i][j]$。\n\n显然，$a$ 的第一维可以滚掉，而维护 $a$ 的最小值和等差区间可以用线段树实现。\n\n## Code\n```cpp I hate Shortest Path Problem\n#include <bits/stdc++.h>\n#define lid id << 1\n#define rid id << 1 | 1\n\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nconst int INF = 1e9;\n\nint h, w, a[MAXN], L[MAXN], R[MAXN], ans[MAXN];\n\ntemplate <class T>\nvoid read(T &x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct Node {\n    int l, r, mi, lval;\n    bool tag;\n    Node() { mi = lval = 0, tag = 0; }\n    // mi denotes the minimum value in array [l,r]\n    // lval denotes the value of the left end point of array [l,r]\n} tr[MAXN * 4];\n\nvoid update(int id) {\n    tr[id].mi = min(tr[lid].mi, tr[rid].mi);\n    tr[id].lval = tr[lid].lval;\n}\n\nvoid pushdown(int id) {\n    if (tr[id].tag) {\n        tr[lid].tag = 1;\n        tr[lid].lval = tr[lid].mi = tr[id].lval;\n        tr[rid].tag = 1;\n        tr[rid].lval = tr[rid].mi = tr[id].lval + tr[rid].l - tr[lid].l;\n        tr[id].tag = 0;\n    }\n}\n\nvoid build(int id, int l, int r) {\n    tr[id].l = l, tr[id].r = r;\n    if (l == r) return;\n    int mid = l + r >> 1;\n    build(lid, l, mid);\n    build(rid, mid + 1, r);\n}\n\nvoid modify(int id, int l, int r, int val) {\n    if (tr[id].l == l && tr[id].r == r) {\n        tr[id].mi = tr[id].lval = val;\n        tr[id].tag = 1;\n        return;\n    }\n    pushdown(id);\n    int mid = tr[id].l + tr[id].r >> 1;\n    if (r <= mid)\n        modify(lid, l, r, val);\n    else if (l > mid)\n        modify(rid, l, r, val);\n    else {\n        modify(lid, l, mid, val);\n        modify(rid, mid + 1, r, val + mid + 1 - l);\n    }\n    update(id);\n}\n\nint query(int id, int l, int r) {\n    if (r < 1) return INF;\n    if (tr[id].l == l && tr[id].r == r) {\n        return tr[id].mi;\n    }\n    pushdown(id);\n    int mid = tr[id].l + tr[id].r >> 1;\n    if (r <= mid)\n        return query(lid, l, r);\n    else if (l > mid)\n        return query(rid, l, r);\n    else\n        return min(query(lid, l, mid), query(rid, mid + 1, r));\n}\n\nint main() {\n    read(h), read(w);\n    for (int i = 1; i <= h; i++) read(L[i]), read(R[i]);\n    fill(ans + 1, ans + h + 2, -1);\n    build(1, 1, w);\n    for (int i = 2; i <= h + 1; i++) {\n        int tmp = query(1, L[i - 1] - 1, L[i - 1] - 1);\n        modify(1, L[i - 1], R[i - 1], tmp + 1);\n        int mi = query(1, 1, w);\n        if (mi >= INF) break;\n        ans[i] = mi + i - 1;\n    }\n    for (int i = 2; i <= h + 1; i++) printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n```\n","tags":["contest"],"categories":["contest"]},{"title":"树状数组","url":"/2020/08/29/binary-index-trees/","content":"- 递归版线段树常数略大，在数据结构优化DP，树套树，etc 时容易超时。\n- 下为树状数组区间 / 单点增值，区间/单点查询模板 ( $O(n)$ 建树)。\n\n<!-- more -->\n```cpp Binary Indexed Trees\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 1e5 + 5;\n\nint n, m;\n\nstruct BIT { //Binary Index Trees, 1based\n    int lowbit(int x) { return x & (~x + 1); }\n    /* O(n) 建树*/\n    void build(int x = 2, int sub = 1) {\n        while (x <= n) {\n            for (int i = x; i <= n; i += x)\n                c[i] += c[i - sub];  //加上儿i - sub子的c\n            x <<= 1, sub <<= 1;      // 2 ^ n\n        }\n    }\n    /*@param x the position to add val*/\n    void add(int x, LL val) {\n        while (x <= n) c[x] += val, x += lowbit(x);\n    }\n    /*查询 [1, x] 的前缀和*/\n    LL query(int x, LL res = 0) {\n        while (x) res += c[x], x -= lowbit(x);\n        return res;\n    }\n    array<LL, MAXN> c;\n} bit[3];\n/*range [l, r] add val*/\ninline void add(int l, int r, LL val) {\n    bit[1].add(l, val), bit[1].add(r + 1, -val);\n    bit[2].add(l, val * l), bit[2].add(r + 1, -val * (r + 1));\n}\n/*range [l, r] sum query*/\ninline LL query(int l, int r, LL res = 0) {\n    res = bit[0].query(r) + bit[1].query(r) * (r + 1) - bit[2].query(r);\n    res -= bit[0].query(l - 1) + bit[1].query(l - 1) * l - bit[2].query(l - 1);\n    return res;\n}\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> bit[0].c[i];\n    bit[0].build();\n    while (m--) {\n        char opt;\n        cin >> opt;\n        if (opt == 'Q') {\n            int x;\n            cin >> x;\n            cout << query(x, x) << \"\\n\";\n        } else {\n            int l, r, x;\n            cin >> l >> r >> x;\n            add(l, r, x);\n        }\n    }\n    return 0;\n}\n```\n\n```cpp 再封装一下\ntemplate <int MAXN>\nstruct BIT {\n    struct Bit {\n        int lowbit(int x) { return x & (-x); }\n\n        void build(int x = 2, int sub = 1) {\n            while (x <= n) {\n                for (int i = x; i <= n; i += x)\n                    c[i] += c[i - sub];  //加上儿i - sub子的c\n                x <<= 1, sub <<= 1;      // 2 ^ n\n            }\n        }\n\n        void add(int x, LL val) {\n            while (x <= n) c[x] += val, x += lowbit(x);\n        }\n\n        LL query(int x, LL res = 0) {\n            while (x) res += c[x], x -= lowbit(x);\n            return res;\n        }\n        array<LL, MAXN> c;\n    } bit[3];\n\n    inline void add(int l, int r, LL val) {\n        bit[1].add(l, val), bit[1].add(r + 1, -val);\n        bit[2].add(l, val * l), bit[2].add(r + 1, -val * (r + 1));\n    }\n\n    inline LL query(int l, int r, LL res = 0) {\n        res = bit[0].query(r) + bit[1].query(r) * (r + 1) - bit[2].query(r);\n        res -=\n            bit[0].query(l - 1) + bit[1].query(l - 1) * l - bit[2].query(l - 1);\n        return res;\n    }\n};\nBIT<MAXN> bit;\n```","tags":["树状数组"],"categories":["数据结构","树状数组"]},{"title":"AtCoder Beginner Contest 175","url":"/2020/08/17/atcoder-abc-175/","content":"[比赛链接](https://atcoder.jp/contests/abc175)\n<!-- more -->\n# D Moving Piece\n## Description\n有 $n$ 个格子排成一列。给定 $1, 2, ..., n$ 的排列 $P_1, P_2, ..., P_n$，以及数组$C_1, C_2, ..., C_n$，表示格子 $i$ 能达到 $P_i$，获得的分数为 $C_{P_i}$。从任意一点出发走 $K$ 步，求能获得的最大分数。\n## Solution\n$O(N^2)$：\n以每个点作为起点 $st$，求出路径，记录环的起点 $cyBeg$ 和终点 $cyEnd$ (终点指再走一步能回到环的起点的节点)。\n求起点 $st$ 到 $cyEnd$ 的 $C$ 前缀和，以及前缀和中的最大值。并求出环上的 $C$ 总和，以及从 $cyBeg$ 开始的前缀和及其最大值。\n判断能否走完整个环，若环为正环，则可以一直走到若干圈直到不能再走完整个环，或者少走一圈再加上前缀和最大值 (虽然环是正环，但可能环上存在一个极小值，少走一圈反而能使答案更大)。\n$O(nlogn)$：\n通过 $P$ 求出每个点的入度，从入度为 0 的点开始 $dfs$ 建图 (若没有点入度为 0，则所有点在环上，任意找一个点为起点即可)，并记录每个点是否在环上。分起点在环上和不在环上，起点在环上需分段讨论，然后可用支持区间修改查询的数据结构维护区间最大值。也有multiset做法 [link](https://codeforces.ml/blog/entry/81458?#comment-681192)。\n## Code\n```cpp Moving Piece O(N^2)\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconstexpr int MAXN = 5e3 + 5;\n\nint n, k, ans(-1e18), cyBeg, cyEnd;\narray<int, MAXN> to, c, vis, pre, preMax;\nvector<int> node;\n\ninline void dfs(int cur) {\n    vis[cur] = true;\n    node.push_back(cur);\n    if (vis[to[cur]]) {\n        cyEnd = node.size() - 1; //环终点\n        for (int i = 0; i < node.size(); i++)\n            if (node[i] == to[cur]) {\n                cyBeg = i; //环起点\n                break;\n            }\n    }\n    else dfs(to[cur]);\n}\n\ninline void search(int st) {\n    node.clear();\n    fill(vis.begin(), vis.end(), 0);\n    fill(pre.begin(), pre.end(), 0);\n    fill(preMax.begin(), preMax.end(), -1e18);\n    cyBeg = cyEnd = -1;\n    dfs(st);\n    for (int i = 1; i < node.size(); i++)\n        pre[i] = pre[i - 1] + c[node[i]], preMax[i] = max(preMax[i - 1], pre[i]);\n    ans = max(ans, preMax[min(k, (int)node.size() - 1)]);\n    if (k <= cyEnd || cyBeg == - 1 || cyEnd == -1) return;\n    if (cyBeg == 0) { //一开始就有环\n        int valC = pre[cyEnd] + c[node[cyBeg]];\n        if (valC < 0) return;\n        int tim = k / node.size(), res = k % node.size();\n        ans = max(ans, tim * valC + max(0LL, preMax[res]));\n        ans = max(ans, (tim - 1) * valC + max(0LL, preMax[cyEnd]));\n        return;\n    }\n    int tmp = pre[cyBeg - 1];\n    fill(pre.begin(), pre.end(), 0);\n    fill(preMax.begin(), preMax.end(), -1e18);\n    int valC = 0, cSize = cyEnd - cyBeg + 1, tim, res;\n    for (int i = cyBeg; i <= cyEnd; i++) { //环上前缀和\n        valC += c[node[i]];\n        pre[i] = pre[i - 1] + c[node[i]];\n        preMax[i] = max(preMax[i - 1], pre[i]);\n    }\n    if (valC < 0) return;\n    k -= cyBeg - 1, tim = k / cSize, res = k % cSize;\n    ans = max(ans, tmp + valC * tim + max(0LL, preMax[cyBeg + res - 1]));\n    ans = max(ans, tmp + valC * (tim - 1) + max(0LL, preMax[cyEnd]));\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) cin >> to[i];\n    for (int i = 1; i <= n; i++) cin >> c[i];\n    for (int i = 1; i <= n; i++) search(i);\n    cout << ans << endl;\n    return 0;\n}\n```\n\n# E Picking Goods\n## Description\n[题目链接](https://atcoder.jp/contests/abc175/tasks/abc175_e)\n## Solution\n设 $dp[i][j][k]$ 表示当前为第 $i$ 行，第$j$ 列，第 $i$ 行选了 $k$ 个数的最大值。状态转移明显。\n## Code\n```cpp Picking Goods\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 3e3 + 3;\n\nLL R, C, K;\nLL dp[MAXN][MAXN][5], mp[MAXN][MAXN];\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> R >> C >> K;\n    for (int i = 1; i <= K; i++) {\n        int r, c, v;\n        cin >> r >> c >> v;\n        mp[r][c] = v;\n    }\n    for (int i = 1; i <= R; i++)\n        for (int j = 1; j <= C; j++) {\n            for (int cnti = 0; cnti < 4; cnti++) {\n                    //不选\n                    dp[i][j][cnti] = max(dp[i][j][cnti], dp[i][j - 1][cnti]);\n                    for (int cntj = 0; cntj < 4; cntj++)\n                        dp[i][j][cnti] = max(dp[i][j][cnti], dp[i - 1][j][cntj]);\n                    //选\n                    dp[i][j][cnti + 1] = max(dp[i][j][cnti + 1], dp[i][j - 1][cnti] + mp[i][j]);\n                    for (int cntj = 0; cntj < 4; cntj++)\n                        dp[i][j][cnti + 1] = max(dp[i][j][cnti + 1], dp[i - 1][j][cntj] + mp[i][j]);\n            }\n        }\n    LL ans = 0;\n    for (int i = 0; i < 4; i++) ans = max(ans, dp[R][C][i]);\n    cout << ans << endl;\n    return 0;\n}\n\n```\n\n# F Making Palindrome\n## Description\n求将一些字符串 $S_1, S_2, ..., S_n$ 拼接为回文串的最小代价 ( $S_i$ 可多次被选，每选一次代价为 $C_i$ )。不能拼成回文串则输出 -1。\n## Solution\n将目标回文串分为左右两部分，设左边的字符串为 $l = s_{l_1}, s_{l_2}, ..., s_{l_j}$，右边的字符串为 $r = s_{r_k}, ..., s_{r_2}, s_{r_1}$。要使 $l, r$ 构成回文串，则需要 $s_{l_1}$ 的前缀与 $s_{r_1}$ 回文，或者 $s_{l_1}$ 与 $s_{r_1}$ 的后缀回文，并且将回文部分消去后的 $l, r$ 也满足上述条件 (此时 $s_{l_i}$ 和 $s_{r_i}$ 可能只是 $S$ 的一部分)。\n于是可以考虑设当前状态为 $state = \\{ string_l, string_r \\}$，向字符串长度小的一边加入新字符串进行拼接，并消去回文部分，直到 $l, r$ 都为空，或者一个是回文串，一个是空串为止，然后跑 $dijkstra$ 即可。\n\n## Code\n```cpp Making Palindrome\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 55;\n\nstruct Node {\n    Node() = default;\n    Node(LL _c, string& _l, string& _r) : c(_c), l(_l), r(_r) {}\n    LL c;\n    string l, r;\n    friend inline bool operator<(const Node& lhs, const Node& rhs) {\n        return lhs.c > rhs.c;\n    }\n};\nLL n, cost[MAXN];\nstring s[MAXN], emps(\"\");\n\ninline bool isPalindrome(const string& tmp) {\n    for (int i = 0; i < tmp.size() /2 + 1; i++)\n        if (tmp[i] != tmp[tmp.size() - 1 - i]) return false;\n    return true;\n}\n/*删除l, r公共部分 @return l, r第一个不同的位置*/\ninline int check(string& l, string& r) {\n    int i = 0;\n    for (; i < min(l.size(), r.size()); i++)\n        if (l[i] != r[r.size() - 1 - i]) break;\n    l = l.substr(i), r = r.substr(0, r.size() - i);\n    return i;\n}\n\npriority_queue<Node, vector<Node>> q;\nmap<string, map<string, bool>> vis;\ninline void dijkstra() {\n    while (!q.empty()) {\n        auto cur = q.top();\n        q.pop();\n        if (vis[cur.l][cur.r]) continue; //l, r 访问过\n        if (isPalindrome(cur.l) && cur.r.empty()) { //左边是回文\n            cout << cur.c << endl;\n            return;\n        } else if (isPalindrome(cur.r) && cur.l.empty()) { //右边是回文\n            cout << cur.c << endl;\n            return;\n        } else if (cur.l.empty() && cur.r.empty()) { //都是空字符串\n            cout << cur.c << endl;\n            return;\n        } else {\n            for (int i = 1; i <= n; i++) {\n                Node tmp(cur.c, cur.l, cur.r);\n                if (tmp.l.size() >= tmp.r.size()) { //左边比右边长，加到右边\n                    tmp.r = s[i] + tmp.r, tmp.c += cost[i];\n                    int id = check(tmp.l, tmp.r);\n                    if (id && (tmp.l.empty() || tmp.r.empty())) q.push(tmp);\n                } else { //左边比右边短，加到左边\n                    tmp.l = tmp.l + s[i], tmp.c += cost[i];\n                    int id = check(tmp.l, tmp.r);\n                    if (id && (tmp.l.empty() || tmp.r.empty())) q.push(tmp);\n                }\n            }\n        }\n        vis[cur.l][cur.r] = true;\n    }\n    cout << -1 << endl;\n}\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> s[i] >> cost[i];\n        q.push(Node(cost[i], s[i], emps));\n        q.push(Node(cost[i], emps, s[i]));\n    }\n    dijkstra();\n    return 0;\n}\n```","tags":["contest"],"categories":["contest"]},{"title":"最大内接四边形","url":"/2020/08/17/largest-quadrilateral/","content":"# SCOI2007 最大土地面积\n  - [题目链接](https://www.luogu.com.cn/problem/P4166)\n  - 计算几何/凸包/旋转卡壳\n<!-- more -->\n# Description\n选取平面上的 4 个点，使得围成的四边形的面积最大 ($n \\le 2000$)。\n# Solution\n最大四边形的顶点一定在凸包上。\n当凸包顶点数大于 3 时，先选取一条对角线，则其它两个点到对角线的距离具有单峰性，套旋转卡壳即可求出最大四边形面积。\n当凸包顶点数等于 3 时，最大四边形面积为凸包面积减去内部点与凸包上的点构成的最小的三角形面积。\n当凸包顶点数等于 2 时，面积为 0。\n# Code\n```cpp 最大内接四边形\n#include <bits/stdc++.h>\n#define PI acos(-1)\n\nusing namespace std;\n\nconstexpr int MAXN = 3e3 + 3;\n\nstruct Vec2 {\n    Vec2() = default;\n    Vec2(double _x, double _y) : x(_x), y(_y) {}\n\n    friend inline bool operator<(const Vec2& a, const Vec2& b) {\n        return fabs(a.x - b.x) < 1e-8 ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline double operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;  //×\n    }\n    double x = 0, y = 0;\n} vec[MAXN], cov[MAXN];\nint n, top, Up;\n\ninline void convex() {\n    top = 0, Up = 0;\n    sort(vec + 1, vec + n + 1);\n    for (int i = 1; i <= n; i++) {  //下凸壳\n        while (top > 1 && (cov[top] - cov[top - 1]) * (vec[i] - cov[top]) < 1e-8)\n            cov[top--] = Vec2(0, 0);\n        cov[++top] = vec[i];\n    }\n    Up = top;                          //上凸壳起点\n    for (int i = n - 1; i > 0; i--) {  //上凸壳\n        while (top > Up && (cov[top] - cov[top - 1]) * (vec[i] - cov[top]) < 1e-8)\n            cov[top--] = Vec2(0, 0);\n        cov[++top] = vec[i];\n    }\n}\n\ninline double calc(double res = .0) {\n    if (top <= 3) return 0.0; //凸包只有2个点\n    if (top == 4) ; //凸包只有3个点\n    for (int i = 1; i < top; i++) {\n        int up = (i + 2) % (top - 1) == 0 ? (i + 2) : (i + 2) % (top - 1);\n        int down = i;\n        for (int j = i + 2; j < i + top - 2; j++) {\n            auto s = cov[i], t = cov[j % (top - 1) == 0 ? j : j % (top - 1)];\n            while (true) {\n                auto s1 = fabs((t - cov[up]) * (s - cov[up]));\n                auto s2 = fabs((t - cov[up + 1]) * (s - cov[up + 1]));\n                if (s1 < s2 + 1e-8) up = up % (top - 1) + 1;\n                else break;\n            }\n            while (true) {\n                auto s1 = fabs((t - cov[down]) * (s - cov[down]));\n                auto s2 = fabs((t - cov[down + 1]) * (s - cov[down + 1]));\n                if (s1 < s2 + 1e-8) down = down % (top - 1) + 1;\n                else break;\n            }\n            res = max(res, fabs((cov[up]- s) * (cov[up] - t)) +\n                               fabs((cov[down] - s) * (cov[down] - t)));\n        }\n    }\n    return res / 2;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> vec[i].x >> vec[i].y;\n    convex();\n    cout << setprecision(3) << fixed << calc() << endl;;\n    return 0;\n}\n```\n","tags":["旋转卡壳","凸包"],"categories":["计算几何","旋转卡壳","凸包"]},{"title":"矩阵树笔记 Matrix tree","url":"/2020/08/14/matrix-tree/","content":"# Matrix tree\n<!-- more -->\n## 矩阵树\n定义图无向图 $G$ 的拉普拉斯矩阵 (Laplacian matrix) $L(G)$\n$$\nL_{ij} =\n\\begin{cases}\n-m_{ij} & i \\ne\\ j, i 与 j 之间有 m_{ij}条边\\\\\ndeg(i) & i = j, deg(i) 为点 i 的度\\\\\n\\end{cases}\n$$\n则 $G$ 的生成树个数等于 $detL_0$，其中 $L_0$ 是去掉 $L$ 的 第 $i$ 行，第 $i$ 列得到的子矩阵 ($i$ 任意)。具体证明见 [参考资料](https://zhuanlan.zhihu.com/p/108209378)。\n那么就可以化矩阵 $L_0$ 为上三角矩阵，即可求出 $detL_0$。\n### Code\n```cpp template\ninline void add(int u, int v) { //加边\n    G[u][u]++, G[v][v]++;\n    G[u][v]--, G[v][u]--;\n}\n\nLL G[MAXN][MAXN];\ninline LL Gauss(int tot) { //高斯消元\n    LL ans = 1;\n    for (int i = 1; i < tot; i++) {\n        for (int j = i + 1; j < tot; j++)\n            while (G[j][i]) {\n                LL t = G[i][i] / G[j][i];\n                for (int k = i; k < tot; k++)\n                    G[i][k] = ((G[i][k] - t * G[j][k]) % MOD + MOD) % MOD;\n                swap(G[i], G[j]);\n                ans = -ans;\n            }\n        ans = ans * G[i][i] % MOD;\n    }\n    return (ans + MOD) % MOD;\n}\n```\n## 变元矩阵树\n用于求所有生成树边权乘积的和。和矩阵树求法相同，不过行列式中 $G[i][i]$ 记录的是点 $i$ 所连的边权总和，$G[i][j]$ 记录的是 $i, j$ 之间边权的相反数之和。\n### Code\n```cpp tempalte\ninline void add(int u, int v, double val) { //加边\n    G[u][u] += val, G[v][v] += val;\n    G[u][v] -= val, G[v][u] -= val;\n}\n\ninline double Gauss(int n) { //高斯消元\n    double ans = 1;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (fabs(G[i][i]) < eps) swap(G[i], G[j]), ans = -ans;\n            else break;\n        }\n        for (int j = i + 1; j < n; j++) {\n            if (fabs(G[j][i]) < eps) continue;\n            double tmp = G[j][i] / G[i][i];\n            for (int k = i; k < n; k++)\n                G[j][k] -= tmp * G[i][k];\n        }\n        ans = ans * G[i][i];\n    }\n    return ans;\n}\n```\n\n## Cayley 定理\n有 $p$ 个顶点的完全图 $K_p$，生成树的个数为 $p^{p - 2}$ 个 (行列式递推就行了)。\n\n## 图联通方案数\n有 $p$ 个顶点的图，已知有 $k$ 个连通块，如果仅将连通块看作点，则对应的生成树个数为 $p^{k - 2}$。[证明](https://oi-wiki.org/graph/prufer/#_3)。\n\n\n# 例题\n## HEOI2015 小Z的房间\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P4111)\n### Solution\n模板题，不过注意不要建重边。\n### Code\n```cpp 小Z的房间\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 2000;\nconstexpr int MOD = 1e9;\n\nint n, m, tot, mp[MAXN][MAXN];\n\nLL G[MAXN][MAXN];\ninline LL Gauss() {\n    LL ans = 1;\n    for (int i = 1; i < tot; i++) {\n        for (int j = i + 1; j < tot; j++)\n            while (G[j][i]) {\n                LL t = G[i][i] / G[j][i];\n                for (int k = i; k < tot; k++)\n                    G[i][k] = ((G[i][k] - t * G[j][k]) % MOD + MOD) % MOD;\n                swap(G[i], G[j]);\n                ans = -ans;\n            }\n        ans = ans * G[i][i] % MOD;\n    }\n    return (ans + MOD) % MOD;\n}\n\ninline void add(int u, int v) {\n    if (u > v) return;\n    G[u][u]++, G[v][v]++;\n    G[u][v]--, G[v][u]--;\n}\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++) {\n            char ch;\n            cin >> ch;\n            if (ch == '.') mp[i][j] = ++tot;\n        }\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= m; j++) {\n            int u = mp[i][j], v;\n            if (!u) continue;\n            if (v = mp[i - 1][j]) add(u, v);\n            if (v = mp[i + 1][j]) add(u, v);\n            if (v = mp[i][j - 1]) add(u, v);\n            if (v = mp[i][j + 1]) add(u, v);\n        }\n    cout << Gauss() << endl;\n    return 0;\n}\n```\n\n## B SHOI2016 黑暗前的幻想乡\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P4336)\n### Solution\n矩阵树+容斥+状态压缩。\n令 $P_i$ 表示事件: 第 $i$ 个公司没有参与修建。由容斥原理有 $|\\overline{P_1} \\cap \\overline{P_2} \\cap ...\\cap \\overline{P_{n-k}}|= N-\\sum\\limits_{1<=i<={n-k}}|P_i|+\\sum\\limits_{1<=i<j<={n-k}}|P_i\\cap P_j|$ $-\\sum\\limits_{1<=i<j<q<={n-k}}|P_i\\cap P_j\\cap P_q|+...+(-1)^{n-k}|P_1\\cap P_2 \\cap ...\\cap P_{n-k}|$。压缩公司的参与状态即可。\n### Code\n```cpp 黑暗前的幻想乡\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MOD = 1e9 + 7;\n\nint n, m, tot;\nvector<pair<int, int>> vec[20];\n\nLL G[20][20];\ninline LL Gauss() {\n    LL ans = 1;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j < n; j++)\n            while (G[j][i]) {\n                LL t = G[i][i] / G[j][i];\n                for (int k = i; k < n; k++)\n                    G[i][k] = ((G[i][k] - t * G[j][k]) % MOD + MOD) % MOD;\n                swap(G[i], G[j]);\n                ans = -ans;\n            }\n        ans = ans * G[i][i] % MOD;\n    }\n    return (ans + MOD) % MOD;\n}\n\ninline void add(int u, int v) {\n    G[u][u]++, G[v][v]++;\n    G[u][v]--, G[v][u]--;\n}\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 0, cnt; i < n - 1; i++) {\n        cin >> cnt;\n        for (int j = 1, u, v; j <= cnt; j++) {\n            cin >> u >> v;\n            vec[i].emplace_back(u, v);\n        }\n    }\n    LL ans = 0;\n    for (int st = 0; st < (1 << (n - 1)); st++) {\n        int cnt = 0;\n        memset(G, 0, sizeof(G));\n        for (int i = 0; i < n - 1; i++)\n            if (st & (1 << i)) {\n                for (auto& e : vec[i])\n                    add(e.first, e.second);\n                cnt++;\n            }\n        if ((n - cnt - 1) & 1) ans = (ans - Gauss()) % MOD;\n        else ans = (ans + Gauss()) % MOD;\n    }\n    cout << (ans + MOD) % MOD << endl;\n    return 0;\n}\n```\n\n## C SDOI2014 重建\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P3317)\n### Solution\n我们已知变元矩阵树可以求 $\\sum_T \\prod_{e \\in T} p_e$。\n而本题需要求 $\\sum_T \\{ \\prod_{e \\in T} p_e \\prod_{e \\notin T} (1 - p_e) \\}$。变换可得：\n$$\\sum_T \\{ \\prod_{e \\in T} p_e \\prod_{e \\notin T} (1 - p_e) \\}$$\n$$= \\sum_T \\{ \\prod_{e \\in T} p_e \\frac{\\prod_e (1 - p_e)}{\\prod_{e \\in T} (1-p_e)} \\}$$\n$$= \\prod_e (1 - p_e) (\\sum_T \\prod_{e \\in T} \\frac{p_e}{1-p_e})$$\n然后以 $\\frac{p_e}{1 - p_e}$ 为边权使用变元矩阵树求边权积的和即可。\n### Code\n```cpp 重建\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nint n;\ndouble ans(1), eps = 1e-8;\n\ndouble G[55][55], p[55][55];\ninline double Gauss() {\n    double ans = 1;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (fabs(G[i][i]) < eps) swap(G[i], G[j]), ans = -ans;\n            else break;\n        }\n        for (int j = i + 1; j < n; j++) {\n            if (fabs(G[j][i]) < eps) continue;\n            double tmp = G[j][i] / G[i][i];\n            for (int k = i; k < n; k++)\n                G[j][k] -= tmp * G[i][k];\n        }\n        ans = ans * G[i][i];\n    }\n    return ans;\n}\n\ninline void add(int u, int v, double val) {\n    G[u][u] += val, G[v][v] += val;\n    G[u][v] -= val, G[v][u] -= val;\n}\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << setprecision(4) << fixed;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++) {\n            cin >> p[i][j];\n            if (i >= j) continue;\n            double tmp = fabs(1.0 - p[i][j]) < eps ? eps : fabs(1.0 - p[i][j]);\n            ans *= tmp, p[i][j] /= tmp;\n            add(i, j, p[i][j]);\n        }\n    cout << ans * fabs(Gauss()) << endl;\n    return 0;\n}\n```\n\n## D HDU多校 Expectation\n### Description\n[题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6836)\n求生成树边权按位与的期望。\n### Solution\n期望 = 按位与的和 / 总生成树个数。生成树个数可以用矩阵树求出。对于按位与，考虑每一位，如果生成树边权的第 $bit$ 位全为 1，则 $bit$ 位的按位与为1，否则为0。相当于0, 1的乘积。于是可对每一位跑变元矩阵树，最后按位累加即为按位与的和。\n### Code Expectation\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 300;\nconstexpr LL INF = 1e16;\nconstexpr LL MOD = 998244353;\n\nint t, n, m;\n\ninline LL qpow(LL a, LL b) {\n    LL res = 1;\n    while (b) {\n        if (b & 1) res = res * a % MOD;\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nLL K[110][110], K2[32][110][110];\nLL gauss(int n) {  //求矩阵K的n-1阶顺序主子式\n    LL res = 1;\n    for (int i = 1; i <= n - 1; i++) {  //枚举主对角线上第i个元素\n        for (int j = i + 1; j <= n - 1; j++) {  //枚举剩下的行\n            while (K[j][i]) {                   //辗转相除\n                int t = K[i][i] / K[j][i];\n                for (int k = i; k <= n - 1; k++)  //转为倒三角\n                    K[i][k] = (K[i][k] - t * K[j][k] + MOD) % MOD;\n                swap(K[i], K[j]);  //交换i、j两行\n                res = -res;        //取负\n            }\n        }\n        res = (res * K[i][i]) % MOD;\n    }\n    return (res + MOD) % MOD;\n}\n\nLL gauss2(int n, int bit) {  //求矩阵K的n-1阶顺序主子式\n    LL res = 1;\n    for (int i = 1; i <= n - 1; i++) {  //枚举主对角线上第i个元素\n        for (int j = i + 1; j <= n - 1; j++) {  //枚举剩下的行\n            while (K2[bit][j][i]) {                   //辗转相除\n                int t = K2[bit][i][i] / K2[bit][j][i];\n                for (int k = i; k <= n - 1; k++)  //转为倒三角\n                    K2[bit][i][k] = (K2[bit][i][k] - t * K2[bit][j][k] + MOD) % MOD;\n                swap(K2[bit][i],K2[bit][j]);  //交换i、j两行\n                res = -res;        //取负\n            }\n        }\n        res = (res * K2[bit][i][i]) % MOD;\n    }\n    return (res + MOD) % MOD;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> t;\n    while (t--) {\n        memset(K, 0, sizeof(K));\n        memset(K2, 0, sizeof(K2));\n        cin >> n >> m;\n        LL ans = 0;\n        for (int i = 1, u, v, w; i <= m; i++) {\n            cin >> u >> v >> w;\n            for (int j = 0; j < 31; j++) {\n                int tmp = (w & (1 << j));\n                if (tmp) {\n                    K2[j][u][u]++, K2[j][v][v]++;\n                    K2[j][u][v]--, K2[j][v][u]--;\n                }\n            }\n            K[u][u]++, K[v][v]++;\n            K[u][v]--, K[v][u]--;\n        }\n        LL fenMu = gauss(n);\n        for (int i = 0; i < 31; i++) {\n            ans = (ans + ((gauss2(n, i) << i) % MOD)) % MOD;\n        }\n        cout << ans * qpow(fenMu, MOD - 2) % MOD << \"\\n\";\n    }\n    return 0;\n}\n```\n\n## E 最小生成树计数\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P4208)\n### Solution\n最小生成树有一个性质是，同一边权的边的数目是相同的。考虑先随意生成一个最小生成树，然后对生成树上的每个权值计算贡献 (相同边权只计算一次)。\n具体来说，就是枚举最小生成树上的边，将其删除 (设边权为 $w_i$，相同边权只删除一次)，然后得到若干连通块 (缩成一个点)。再用所有边权为 $w_i$ 的边把连通块连接起来，对这些连通块的生成树计数，最后乘法原理得到最终答案。\n### Code\n```cpp 最小生成树计数\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 105;\nconstexpr int MOD = 31011;\n\nint n, m, ans = 1, fa[MAXN], vis[MAXN], belong[MAXN];\nvector<pair<int, pair<int, int>>> vec, eTree;\n\ninline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\ninline void Union(int a, int b) {\n    int r1 = find(a), r2 = find(b);\n    if (r1 != r2) fa[r1] = r2;\n}\n\ninline void kruskal(int cnt = 0) {\n    for (int i = 1; i <= n; i++) fa[i] = i;\n    sort(vec.begin(), vec.end());\n    for (auto& e : vec) {\n        int w = e.first, u = e.second.first, v = e.second.second;\n        if (find(u) != find(v)) {\n            cnt++;\n            Union(u, v);\n            eTree.push_back(make_pair(w, make_pair(u, v)));\n        }\n        if (cnt == n - 1) break;\n    }\n}\n\nint G[MAXN][MAXN];\ninline LL Gauss(int n) {\n    LL ans = 1;\n    for (int i = 1; i < n; i++) {\n        for (int j = i + 1; j < n; j++)\n            while (G[j][i]) {\n                LL t = G[i][i] / G[j][i];\n                for (int k = i; k < n; k++)\n                    G[i][k] = ((G[i][k] - t * G[j][k]) % MOD + MOD) % MOD;\n                swap(G[i], G[j]);\n                ans = -ans;\n            }\n        ans = ans * G[i][i] % MOD;\n    }\n    return (ans + MOD) % MOD;\n}\n\ninline void add(int u, int v) { G[u][u]++, G[v][v]++, G[u][v]--, G[v][u]--; }\n\ninline int calc(int res = 1) {\n    for (int i = 0; i < eTree.size(); i++) {\n        if (i && eTree[i - 1].first == eTree[i].first) continue;\n        int cnt = 0;\n        memset(G, 0, sizeof(G)), memset(vis, 0, sizeof(vis));\n        for (int j = 1; j <= n; j++) fa[j] = j;\n        for (auto& e : eTree) { //生成树上权值不为eTree[i]的边，求出联通块\n            int w = e.first, u = e.second.first, v = e.second.second;\n            if (w == eTree[i].first) continue;\n            Union(u, v);\n        }\n        for (int j = 1; j <= n; j++) {//处理连通块数目 方便后续生成树Gauss计数\n            if (!vis[find(j)]) vis[find(j)] = ++cnt;\n            belong[j] = vis[find(j)];\n        }\n        for (auto& e : vec) { //所有边，将连通块相连\n            int w = e.first, u = e.second.first, v = e.second.second;\n            if (w != eTree[i].first) continue;\n            add(belong[u], belong[v]); //加边\n        }\n        res = res * Gauss(cnt) % MOD;\n    }\n    return res;\n}\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1, u, v, w; i <= m; i++) {\n        cin >> u >> v >> w;\n        vec.push_back(make_pair(w, make_pair(u, v)));\n    }\n    kruskal();\n    cout << calc() << endl;\n    return 0;\n}\n```\n\n## 有向图的有根最小生成树计数\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P4455)\n### Solution\n求以 1 为根的生成树数量。\n构造矩阵 $A$： $i != j$，$a_{ij}$ 表示 $i$ 到 $j$ 的有向边数的相反数；$a_{ii}$ 为 $i$ 的出度。\n该矩阵去掉第 1 行，第 1 列即为以 1 为根的生成树数量。\n### Code\n```cpp CQOI2018 社交网络\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 1e3 + 3, MOD = 1e4 + 7;\n\nint n, m, u, v;\n\nint G[MAXN][MAXN];\ninline int Gauss(int n, int res = 1) {\n    for (int i = 2; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            while (G[j][i]) {\n                int t = G[i][i] / G[j][i];\n                for (int k = i; k <= n; k++)\n                    G[i][k] = ((G[i][k] - t * G[j][k]) % MOD + MOD) % MOD;\n                swap(G[i], G[j]);\n                res = -res;\n            }\n        }\n        res = res * G[i][i] % MOD;\n    }\n    return (res + MOD) % MOD;\n}\n/*从 u 到 v 的有向边*/\ninline void add(int u, int v) { G[u][v]--, G[u][u]++; }\n\nsigned main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    while (m--) cin >> u >> v, add(u, v);\n    cout << Gauss(n) << endl;\n    return 0;\n}\n```\n\n\n\n","tags":["高斯消元","矩阵树"],"categories":["数论","图论","高斯消元","矩阵树"]},{"title":"Codeforces Round 657 Div2","url":"/2020/08/14/cf-657-div2/","content":"[比赛链接](https://codeforces.ml/contest/1379)\n<!-- more -->\n# A Acacius and String\n[题目链接](https://codeforces.ml/contest/1379/problem/A)\n## Solution\n遇到可能匹配的位置 $i$ 暴力匹配即可。需要注意的是当前位置 $i$ 匹配后得到的串中  $abacaba$ 子串的个数可能大于 1，因此每次匹配成功后要检查子串 $abacaba$ 的个数。\n## Code\n```cpp Acacius and String\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint T, n;\nstring s;\nstring t = \"abacaba\";\n\nint check(const string &s) {\n    int cnt = 0;\n    for (int i = 0; i <= n - 7; i++) {\n        cnt++;\n        for (int j = i; j < i + 7; j++) {\n            if (s[j] != t[j - i]) {\n                cnt--;\n                break;\n            }\n        }\n    }\n    return cnt;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> T;\n    while (T--) {\n        cout << \"\\n\";\n        cin >> n >> s;\n        int cnt = check(s);\n        if (cnt > 1)\n            cout << \"No\";\n        else {\n            if (cnt) {\n                cout << \"Yes\\n\";\n                for (int i = 0; i < n; i++)\n                    if (s[i] == '?') s[i] = 'z';\n                cout << s;\n            } else {\n                bool flag = 0;\n                for (int i = 0; i <= n - 7; i++) {\n                    vector<int> v;\n                    if (s[i] == t[0] || s[i] == '?') {\n                        flag = 1;\n                        for (int j = i; j < i + 7; j++) {\n                            if (s[j] != t[j - i] && s[j] == '?')\n                                s[j] = t[j - i], v.push_back(j);\n                            else if (s[j] != t[j - i] && s[j] != '?') {\n                                flag = 0;\n                                break;\n                            }\n                        }\n                    }\n                    if (check(s) > 1) flag = 0;\n                    if (flag) {\n                        for (int j = 0; j < n; j++)\n                            if (s[j] == '?') s[j] = 'z';\n                        break;\n                    } else\n                        for (int j = 0; j < v.size(); j++) s[v[j]] = '?';\n                    v.clear();\n                }\n                if (!flag)\n                    cout << \"No\";\n                else\n                    cout << \"Yes\\n\" << s;\n            }\n        }\n    }\n    return 0;\n}\n```\n\n# B Dubious Cyrpto\n[题目链接](https://codeforces.ml/contest/1379/problem/B)\n## Solution\n枚举 $a ∈ [l,r]$，由于 $b-c ∈ [l-r,r-l]$，故 $l-r \\le m-na \\le r-l$ 且 $n \\ge 1$，由此可得 $\\lceil \\frac{m-(r-l)}a \\rceil \\le n \\le \\lfloor \\frac{m+(r-l)}a \\rfloor$，且 $n \\ge 1$。这个范围内的 $n$ 都对应一组解。为了方便，取上界代入, 可推出 $b-c$。根据 $b-c$ 的正负分类构造即可。\n\n## Code\n```cpp Dubious Cyrpto\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint T;\nll m, l, r;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> T;\n    while (T--) {\n        cin >> l >> r >> m;\n        for (ll a = l; a <= r; a++) {\n            ll k = (m + r - l) / a;\n            if (k > 0) {\n                ll delta = m - k * a;\n                if (delta < 0 && delta >= l - r) {\n                    cout << a << \" \" << r + delta << \" \" << r << endl;\n                    break;\n                } else if (delta >= 0 && delta <= r - l) {\n                    cout << a << \" \" << l + delta << \" \" << l << endl;\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n```\n\n# C Choosing Flowers\n[题目链接](https://codeforces.ml/contest/1379/problem/C)\n\n## Solution\n显然，价值大的花应尽可能多选，于是将所有价值从大到小排序后贪心的选取价值大的花。设当前枚举到的价值为 $c_i$，对应编号为 $f_i$ 的花，有如下情形：\n- 若 $c_i = a_{f_i}$，则一定买 $f_i$，得到价值 $a_{f_i}$，且还需购买的花的数目减 1\n- 若 $c_i = b_{f_i}$，则有三种情况：\n  - 若 $f_i$ 没有被买过，先买一次 $f_i$，得到价值 $a_{f_i}$。剩下的全部买 $f_i$, 每个价值为 $b_{f_i}$\n  - 若 $f_i$ 已被买过，则剩下的全部买 $f_i$, 每个价值为 $b_{f_i}$\n  - 不买 $f_i$，继续向后考虑\n\n容易证明没有比上述方式更优的选法。\n\n## Code\n```cpp Choosing Flowers\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 100005;\nint a[MAXN], b[MAXN], n, m, T;\nvector<tuple<int, bool, int> > cost;\nbool vis[MAXN];\n\nbool cmp(tuple<int, bool, int> &a, tuple<int, bool, int> &b) {\n    return get<0>(a) > get<0>(b);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> T;\n    while (T--) {\n        cin >> n >> m;\n        cost.clear();\n        fill(vis + 1, vis + m + 1, 0);\n        ll tmp = 0, ans = 0;\n        for (int i = 1; i <= m; i++) {\n            cin >> a[i] >> b[i];\n            cost.push_back(make_tuple(a[i], 0, i));\n            cost.push_back(make_tuple(b[i], 1, i));\n        }\n        sort(cost.begin(), cost.end(), cmp);\n        for (int i = 0; i < cost.size(); i++) {\n            int val = get<0>(cost[i]);\n            bool type = get<1>(cost[i]);\n            int id = get<2>(cost[i]);\n            if (type) {\n                if (vis[id])\n                    ans = max(ans, tmp + 1ll * n * val);\n                else\n                    ans = max(ans, tmp + a[id] + 1ll * (n - 1) * val);\n            } else {\n                tmp += val;\n                n--;\n                vis[id] = 1;\n            }\n            if (!n) {\n                ans = max(ans, tmp);\n                break;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n\n```\n\n\n# D New Passenger Trams\n[题目链接](https://codeforces.ml/contest/1379/problem/D)\n\n## Solution\n设第一辆客车发车时间为 $t$，$t ∈ [0, \\frac{M}2 - 1]$，那么应该被删除的货车 $i$ 的发车时间应该满足 $h_iM+m_i ∈[t-k+1+j * \\frac{M}2,t-1+j*\\frac{M}2]$，移项得 $m_i ∈[t-k+1+(j-2h_i) * \\frac{M}2,t-1+(j-2h_i)*\\frac{M}2]$，其中 $j$ 为任意整数。由于 $m_i∈[0,M-1]$，则可能的 $j$ 的取值为 $2h_i$ 以及 $2h_i+1$。将这两个取值分别代入可得 $m_i ∈ [t-k+1,t-1]∪ [t-k+1 +\\frac{M}2,t-1+\\frac{M}2]$。需要注意的是对于区间$[t-k+1,t-1]$，其左端点可能小于 $0$，此时需要将区间从 $0$ 拆成两半，并将小于零的部分对 $M$ 取模，得$m_i∈[t-k+1+M,M-1]∪[0,t-1]∪[t-k+1 +\\frac{M}2,t-1+\\frac{M}2]$。容易发现当 $k=1$ 时不存在包含货车发车时间的区间，即没有货车需要被删去，直接输出 $0$ $0$ 即可。\n\n从上述推导可知，一辆货车是否被删除仅取决于 $m_i$ 和 $t$。注意到货车发车时间总数不超过 $10^5$ 个，且对于 $m_i$ 可以反推出会导致它被删除的 $t$ 的区间：\n- 若 $t \\ge k-1$，则 $t∈[m_i+1, m_i+k-1]∪[m_i+1 -\\frac{M}2, m_i+k-1-\\frac{M}2]$\n- 若 $t \\le k-2$，则 $t∈[0, m_i+k-1-M]∪[m_i+1 -\\frac{M}2, m_i+k-1-\\frac{M}2]∪[m_i+1, k-2]$\n\n因此可以枚举所有货车 $i$，对 $m_i$ 对应的不合法时间段进行区间增值操作，最后统计区间最小值就是需要被删去的货车的最少数目，且区间最小值的位置对应最优发车时间。这样问题转化成区间更新与求区间最值，用动态开点线段树维护即可。\n\n## Code\n```cpp New Passenger Trams\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5 + 5;\nll n, H, M, k;\nll h[MAXN], m[MAXN];\n\ntemplate <class T>\nvoid read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct Node {\n    Node *lson, *rson;\n    int l, r;\n    ll id, lazy;\n    ll mi;\n} * root, node[MAXN * 64];\n\nNode* newNode(ll l, ll r) {\n    static int tot;\n    node[tot].l = l, node[tot].r = r;\n    node[tot].lazy = 0;\n    node[tot].mi = 0, node[tot].id = l;\n    return &node[tot++];\n}\n\nvoid pushdown(Node* cur) {\n    if (cur->lson) {\n        cur->lson->mi += cur->lazy;\n        cur->lson->lazy += cur->lazy;\n    }\n    if (cur->rson) {\n        cur->rson->mi += cur->lazy;\n        cur->rson->lazy += cur->lazy;\n    }\n    cur->lazy = 0;\n}\n\nvoid update(Node* cur) {\n    if (cur->lson->mi <= cur->rson->mi)\n        cur->mi = cur->lson->mi, cur->id = cur->lson->id;\n    else\n        cur->mi = cur->rson->mi, cur->id = cur->rson->id;\n}\n\nvoid insert(Node* cur, ll l, ll r) {\n    if (cur->l == l && cur->r == r) {\n        cur->mi++;\n        cur->lazy++;\n        return;\n    }\n    int mid = cur->l + cur->r >> 1;\n    if (!cur->lson) cur->lson = newNode(cur->l, mid);\n    if (!cur->rson) cur->rson = newNode(mid + 1, cur->r);\n    pushdown(cur);\n    if (r <= mid)\n        insert(cur->lson, l, r);\n    else if (l > mid)\n        insert(cur->rson, l, r);\n    else\n        insert(cur->lson, l, mid), insert(cur->rson, mid + 1, r);\n    update(cur);\n}\n\nint main() {\n    read(n), read(H), read(M), read(k);\n    if (k == 1) cout << 0 << \" \" << 0, exit(0);\n    root = newNode(0, M / 2 - 1);\n    for (int i = 1; i <= n; i++) {\n        read(h[i]), read(m[i]);\n\n        if (m[i] + 1 <= M / 2 - 1)\n            insert(root, max(k - 1, m[i] + 1), min(M / 2, m[i] + k) - 1);\n        if (m[i] + k - 1 - M / 2 >= k - 1 && m[i] + 1 - M / 2 <= M / 2 - 1)\n            insert(root, max(k - 1, m[i] + 1 - M / 2), min(M / 2, m[i] + k - M / 2) - 1);\n\n        if (m[i] + k - 1 - M >= 0)\n            insert(root, 0, min(k - 2, m[i] + k - 1 - M));\n        if (m[i] + 1 <= k - 2) \n            insert(root, m[i] + 1, k - 2);\n        if (m[i] + k - 1 - M / 2 >= 0 && m[i] + 1 - M / 2 <= k - 2)\n            insert(root, max(0ll, m[i] + 1 - M / 2), min(k - 2, m[i] + k - 1 - M / 2));\n    }\n    cout << root->mi << \" \" << root->id << endl;\n    int t = root->id;\n    for (int i = 1; i <= n; i++) {\n        if (t >= k - 1) {\n            if (t - k + 1 <= m[i] && m[i] <= t - 1)\n                cout << i << \" \";\n            else if (t - k + 1 + M / 2 <= m[i] && m[i] <= t - 1 + M / 2)\n                cout << i << \" \";\n        } else {\n            if (t >= 1 && m[i] <= t - 1)\n                cout << i << \" \";\n            else if (t - k + 1 + M <= m[i] && m[i] <= M - 1)\n                cout << i << \" \";\n            else if (t - k + 1 + M / 2 <= m[i] && m[i] <= t - 1 + M / 2)\n                cout << i << \" \";\n        }\n    }\n    return 0;\n}\n```\n\n\n\n# E Inverse Genealogy\n[题目链接](https://codeforces.ml/contest/1379/problem/E)\n\n## Solution\n结论题。设当前有 $n$ 个节点，其中有 $k$ 个不平衡点。显然，有最多不平衡点的树是毛毛虫树，即 $n$ 个节点中最多有 $\\frac{n-3}2$ 个不平衡点。如果 $k = 0$，则应有 $n=2^p-1$；如果 $k=1$，则 $n \\neq 2^p-1$。同时当 $n=9,k=2$ 时无解。验证 $n$ 个节点，构造 $k$ 个不平衡点的可行性后暴力构造即可。具体的，让左子树不平衡点数目为 0，即使左子树大小为 $2^p-1$，接下来在右子树中构造剩余的不平衡点。\n## Code\n```cpp Inverse Genealogy\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, k, cnt;\n\nbool check(int cntNode, int cntCritical) {\n    if (cntNode % 2 == 0) return 0;\n    if (!cntCritical) return !(cntNode & (cntNode + 1));\n    if (cntCritical == 1) return cntNode & (cntNode + 1);\n    if (cntNode == 9 && cntCritical == 2) return 0;\n    return cntCritical > 0 && cntCritical <= (cntNode - 3) / 2;\n}\n\nvoid dfs(int cntNode, int cntCritical, int cur) {\n    cout << cur << \" \";\n    int fa = ++cnt;\n    if (cntNode == 1) return;\n    for (int lsize = 1; lsize < cntNode; lsize = lsize * 2 + 1) {\n        int rsize = cntNode - lsize - 1;\n        int rem = cntCritical - (max(lsize, rsize) >= (min(lsize, rsize) * 2));\n        if (check(lsize, 0) && check(rsize, rem)) {\n            dfs(lsize, 0, fa);\n            dfs(rsize, rem, fa);\n            return;\n        }\n    }\n}\n\nint main() {\n    cin >> n >> k;\n    if (!check(n, k)) cout << \"NO\" << endl, exit(0);\n    cout << \"YES\" << endl;\n    dfs(n, k, 0);\n    return 0;\n}\n```\n\n\n# F Chess Strikes Back\n[题目链接（Easy Version）](https://codeforces.ml/contest/1379/problem/F1)\n\n[题目链接（Hard Version）](https://codeforces.ml/contest/1379/problem/F2)\n\n## Solution\n将 $2n*2m$ 的棋盘分割为 $n*m$ 个 $2*2$ 的小方格，则问题转化为判断在每个小方格的左上角或右下角放入一个棋子的可行性。规定左上角不能放棋子的方格为 $L$ 型，右下角不能放棋子的为 $R$ 型。 \n\n若当前方格 $(i,j)$ 为 $R$ 型，即只能在左上角放棋子，则满足 $i'\\le i$ 且 $j' \\le j$ 的方格 $(i',j')$ 不能是 $L$ 型。换而言之，设 $minL_i$ 表示第 $i$ 行第一个 $L$ 型方格的列坐标，$maxR_i$ 为第 $i$ 行最后一个 $R$ 型方格的列坐标，则对 $\\forall j\\le i,minL_j>maxR_i$。\n\n考虑线段树维护区间 $[1,n]$ 的 $minL$ 和 $maxR$，每次更新后合并区间时可以判断左子树 $minL$ 是否大于右子树 $maxR$，若不是则无解。至于 $minL_i$ 和 $maxR_i$，由于有删除操作，可用 $n$ 个 $set$ 存储，每次询问时取相应 $set$ 的元素并在线段树上进行单点修改即可。 \n## Code\n```cpp Chess Strikes Back\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nint n, m, q, x, y;\nunordered_map<int, unordered_map<int, int> > state[2];\nset<int> L[MAXN], R[MAXN];\n\ntemplate <class T>\nvoid read(T& x, T f = 1, char ch = getchar()) {\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct Node {\n    Node *lson, *rson;\n    int l, r;\n    int miL, mxR;\n    bool tag;\n    Node(int _l, int _r) {\n        l = _l, r = _r;\n        miL = m + 1, mxR = 0;\n        tag = 1;\n    }\n} * root;\n\nvoid update(Node* cur) {\n    cur->miL = min(cur->lson->miL, cur->rson->miL);\n    cur->mxR = max(cur->lson->mxR, cur->rson->mxR);\n    if (!cur->lson->tag || !cur->rson->tag || cur->lson->miL <= cur->rson->mxR)\n        cur->tag = 0;\n    else\n        cur->tag = 1;\n}\n\nvoid build(Node*& cur, int l, int r) {\n    cur = new Node(l, r);\n    if (l == r) return;\n    int mid = l + r >> 1;\n    build(cur->lson, l, mid);\n    build(cur->rson, mid + 1, r);\n}\n\nvoid modify(Node* cur, int x, int val, int tag) {\n    if (cur->l == x && cur->r == x) {\n        if (tag == 2)\n            cur->mxR = val;\n        else\n            cur->miL = val;\n        cur->tag = cur->miL > cur->mxR;\n        return;\n    }\n    int mid = cur->l + cur->r >> 1;\n    if (x <= mid)\n        modify(cur->lson, x, val, tag);\n    else\n        modify(cur->rson, x, val, tag);\n    update(cur);\n}\n\nint main() {\n    read(n), read(m);\n    read(q);\n    build(root, 1, n);\n    while (q--) {\n        read(x), read(y);\n        int i = x + 1 >> 1, j = y + 1 >> 1;\n        if (!state[x & 1][i][j]) {\n            if (x & 1) {\n                state[x & 1][i][j] = 1;\n                L[i].insert(j);\n                modify(root, i, *L[i].begin(), 1);\n            } else {\n                state[x & 1][i][j] = 1;\n                R[i].insert(j);\n                auto it = R[i].end();\n                modify(root, i, *(--it), 2);\n            }\n        } else {\n            if (x & 1) {\n                state[x & 1][i][j] = 0;\n                L[i].erase(j);\n                modify(root, i, L[i].empty() ? m + 1 : *L[i].begin(), 1);\n            } else {\n                state[x & 1][i][j] = 0;\n                R[i].erase(j);\n                auto it = R[i].end();\n                modify(root, i, R[i].empty() ? 0 : *(--it), 2);\n            }\n        }\n        if (!root->tag)\n            puts(\"NO\");\n        else\n            puts(\"YES\");\n    }\n    return 0;\n}\n```","tags":["contest"],"categories":["contest"]},{"title":"杭电多校 Asteroid In Love","url":"/2020/08/14/hdu-Asteroid-in-love/","content":"# Asteroid in Love\n  - [题目链接](http://acm.hdu.edu.cn/showproblem.php?pid=6830)\n  - 计算几何/凸包\n  - 三分法\n<!-- more -->\n# Description\n给定平面 $n$ 个点，每个点可能是 0, 1, 2 三中类型中的一个。选出三个类型不同的点，使得三点形成的三角形面积最大。输出最大面积。\n# Solution\n考虑已选了 2 个不同的点，则要使构成的三角形面积最大，第三个点一定在对应类型的凸包上，故先求出三类凸包。\n对于同一直线，与第三点形成的三角形面积(叉积求面积，有正有负)在凸包上下凸壳分别具有单峰性，故可通过三分法求解。\n三分法求解：下凸壳起点、终点，上凸壳起点、终点可以求出，设分别为 $[1, up]$, $[up, top]$，那么只需要对这两个区间三分求极值(极大值、极小值)即可。\n```cpp 三分\ninline LL trisection(const Vec2& a, const Vec2& b, int x, LL res = 0) { // x是点的类型\n    LL l = 1, r = up[x]; //三分法 up是下凸壳终点，或上凸壳起点\n    while (r - l >= 3) { //单峰\n        LL lmid = (l + l + r) / 3;\n        LL rmid = (l + r + r) / 3;\n        LL ls = (cov[x][lmid] - a) * (cov[x][lmid] - b);\n        LL rs = (cov[x][rmid] - a) * (cov[x][rmid] - b);\n        if (ls > rs) r = rmid;\n        else l = lmid;\n    }\n    for (int i = l; i <= r; i++) res = max(res, abs((cov[x][i] - a) * (cov[x][i] - b)));\n\n    l = 1, r = up[x];\n    while (r - l >= 3) { //单谷\n        LL lmid = (l + l + r) / 3;\n        LL rmid = (l + r + r) / 3;\n        LL ls = (cov[x][lmid] - a) * (cov[x][lmid] - b);\n        LL rs = (cov[x][rmid] - a) * (cov[x][rmid] - b);\n        if (ls < rs) r = rmid;\n        else l = lmid;\n    }\n    for (int i = l; i <= r; i++) res = max(res, abs((cov[x][i] - a) * (cov[x][i] - b)));\n\n    l = up[x], r = top[x];\n    while (r - l >= 3) { //单峰\n        LL lmid = (l + l + r) / 3;\n        LL rmid = (l + r + r) / 3;\n        LL ls = (cov[x][lmid] - a) * (cov[x][lmid] - b);\n        LL rs = (cov[x][rmid] - a) * (cov[x][rmid] - b);\n        if (ls > rs) r = rmid;\n        else l = lmid;\n    }\n    for (int i = l; i <= r; i++) res = max(res, abs((cov[x][i] - a) * (cov[x][i] - b)));\n\n    l = up[x], r = top[x];\n    while (r - l >= 3) { //单谷\n        LL lmid = (l + l + r) / 3;\n        LL rmid = (l + r + r) / 3;\n        LL ls = (cov[x][lmid] - a) * (cov[x][lmid] - b);\n        LL rs = (cov[x][rmid] - a) * (cov[x][rmid] - b);\n        if (ls < rs) r = rmid;\n        else l = lmid;\n    }\n    for (int i = l; i <= r; i++) res = max(res, abs((cov[x][i] - a) * (cov[x][i] - b)));\n    return res;\n}\n```\n注意：最后若用浮点数输出面积要用long double。\n# Code\n```cpp Asteriod in Love\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr LL MAXN = 3e3 + 3;\n\nLL tc, n, top[3], up[3], cnt[3], ans;\n\nstruct Vec2 {\n    Vec2() = default;\n    Vec2(LL _x, LL _y) : x(_x), y(_y) {}\n\n    friend inline Vec2 intersect(const Vec2&, const Vec2&, const Vec2&, const Vec2&);\n\n    friend inline bool operator<(const Vec2& a, const Vec2& b) {\n        return a.x == b.x ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline Vec2 operator+(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x + b.x, a.y + b.y);\n    }\n    /*@return cross product of two Vec2*/\n    friend inline LL operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;  //×\n    }\n    /*@return 向量与数乘后的向量*/\n    friend inline Vec2 operator*(const Vec2& a, LL num) {\n        return Vec2(a.x * num, a.y * num);\n    }\n    /*@param a 2D vector @return norm of the vector*/\n    friend inline LL norm(const Vec2& a) {\n        return sqrt(a.x * a.x + a.y * a.y);\n    }\n    /*@param a 2D vector @return square norm of the vector*/\n    friend inline LL normSquare(const Vec2& a) {\n        return a.x * a.x + a.y * a.y;\n    }\n\n    LL x = 0, y = 0;\n} vec[3][MAXN], cov[3][MAXN]/*三类凸包*/;\n\ninline void convex(int x) { //x表示类型\n    top[x] = up[x] = 0;\n    sort(vec[x] + 1, vec[x] + cnt[x] + 1);\n    LL& tp = top[x], &tmp = up[x];\n    for (int i = 1; i <= cnt[x]; i++) {  //下凸壳\n        while (tp > 1 && (cov[x][tp] - cov[x][tp - 1]) * (vec[x][i] - cov[x][tp]) <= 0)\n            cov[x][tp--] = Vec2(0, 0);\n        cov[x][++tp] = vec[x][i];\n    }\n    tmp = tp; //上凸壳起点\n    for (int i = cnt[x] - 1; i > 0; i--) {  //上凸壳\n        while (tp > tmp && (cov[x][tp] - cov[x][tp - 1]) * (vec[x][i] - cov[x][tp]) <= 0)\n            cov[x][tp--] = Vec2(0, 0);\n        cov[x][++tp] = vec[x][i];\n    }\n}\n\ninline LL trisection(const Vec2& a, const Vec2& b, int x, LL res = 0) {\n    LL l = 1, r = up[x]; //三分法\n    while (r - l >= 3) { //单峰\n        LL lmid = (l + l + r) / 3;\n        LL rmid = (l + r + r) / 3;\n        LL ls = (cov[x][lmid] - a) * (cov[x][lmid] - b);\n        LL rs = (cov[x][rmid] - a) * (cov[x][rmid] - b);\n        if (ls > rs) r = rmid;\n        else l = lmid;\n    }\n    for (int i = l; i <= r; i++) res = max(res, abs((cov[x][i] - a) * (cov[x][i] - b)));\n\n    l = 1, r = up[x];\n    while (r - l >= 3) { //单谷\n        LL lmid = (l + l + r) / 3;\n        LL rmid = (l + r + r) / 3;\n        LL ls = (cov[x][lmid] - a) * (cov[x][lmid] - b);\n        LL rs = (cov[x][rmid] - a) * (cov[x][rmid] - b);\n        if (ls < rs) r = rmid;\n        else l = lmid;\n    }\n    for (int i = l; i <= r; i++) res = max(res, abs((cov[x][i] - a) * (cov[x][i] - b)));\n\n    l = up[x], r = top[x];\n    while (r - l >= 3) { //单峰\n        LL lmid = (l + l + r) / 3;\n        LL rmid = (l + r + r) / 3;\n        LL ls = (cov[x][lmid] - a) * (cov[x][lmid] - b);\n        LL rs = (cov[x][rmid] - a) * (cov[x][rmid] - b);\n        if (ls > rs) r = rmid;\n        else l = lmid;\n    }\n    for (int i = l; i <= r; i++) res = max(res, abs((cov[x][i] - a) * (cov[x][i] - b)));\n\n    l = up[x], r = top[x];\n    while (r - l >= 3) { //单谷\n        LL lmid = (l + l + r) / 3;\n        LL rmid = (l + r + r) / 3;\n        LL ls = (cov[x][lmid] - a) * (cov[x][lmid] - b);\n        LL rs = (cov[x][rmid] - a) * (cov[x][rmid] - b);\n        if (ls < rs) r = rmid;\n        else l = lmid;\n    }\n    for (int i = l; i <= r; i++) res = max(res, abs((cov[x][i] - a) * (cov[x][i] - b)));\n    return res;\n}\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << setprecision(1) << fixed;\n    cin >> tc;\n    while (tc--) {\n        cin >> n;\n        ans = 0;\n        memset(cnt, 0, sizeof(cnt));\n        for (LL i = 1, x, y, type; i <= n; i++) {\n            cin >> x >> y >> type;\n            vec[type][++cnt[type]] = Vec2(x, y);\n        }\n        for (int type = 0; type < 3; type++) convex(type);\n        for (int x = 0; x < 1; x++) //枚举星星类型\n            for (int y = x + 1; y <= 2; y++)\n                 for (int i = 1; i <= cnt[x]; i++)\n                    for (int j = 1; j <= cnt[y]; j++)\n                        ans = max(ans, trisection(vec[x][i], vec[y][j], 3 - x - y));\n        long double res = ans; //注意精度\n        cout << res / 2 << endl;\n    }\n    return 0;\n}\n```","tags":["凸包","三分法"],"categories":["计算几何","凸包","三分法"]},{"title":"CF933A A Twisty Movement","url":"/2020/08/12/A-Twisty-Movement/","content":"# A Twisty Movement\n  - [题目链接](https://www.luogu.com.cn/problem/CF933A)\n  - 动态规划/线性DP\n<!-- more -->\n# Solution\n由于 $a_i$ 的取值只有两种，那么某不下降子序列对应的翻转前的子序列一定由 $[111...1][222...2][111...1][222...2]$ 这样的四段构成(每一段可以为空，但不全为空)。其中，第二段和第三段属于被翻转区间 $[l,r]$，这样翻转后第二段和第三段交换，于是得到形如 $[111...1][222...2]$ 的不下降子序列(同样的，每一段可以为空，但不全为空)。对所有这样的子序列长度取最大值就是答案。\n\n具体的，设当前位置为 $i$，只需求 $i$ 之前形如 $[111...1][222...2]$ 的最长子序列和 $i$ 之后形如 $[111...1][222...2]$ 的最长子序列，即求 $1 \\to i$ 的最长不下降子序列以及 $n \\to i+1$ 的最长不上升子序列。分别从前往后、从后往前扫一遍用 $DP$ 维护序列长度最大值即可。\n\n时空复杂度 $O(n)$。\n\n# Code\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int MAXN = 2005;\nint n, ans, a[MAXN];\nint pre[MAXN][2], pos[MAXN][2];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= n; i++) {\n        if (a[i] == 2) {\n            pre[i][2] = max(pre[i - 1][2], pre[i - 1][1]) + 1;\n            pre[i][1] = pre[i - 1][1];\n        } else {\n            pre[i][2] = pre[i - 1][2];\n            pre[i][1] = pre[i - 1][1] + 1;\n        }\n    }\n    for (int i = n; i; i--) {\n        if (a[i] == 2) {\n            pos[i][2] = pos[i + 1][2] + 1;\n            pos[i][1] = pos[i + 1][1];\n        } else {\n            pos[i][2] = pos[i + 1][2];\n            pos[i][1] = max(pos[i + 1][1], pos[i + 1][2]) + 1;\n        }\n    }\n    for (int i = 1; i <= n; i++)\n        ans = max(\n            ans, max(pre[i][1], pre[i][2]) + max(pos[i + 1][1], pos[i + 1][2]));\n    cout << ans;\n    return 0;\n}\n```","tags":["线性DP"],"categories":["动态规划","线性DP"]},{"title":"自适应Simpson积分笔记 Adaptive Simpson","url":"/2020/08/11/Adaptive-Simpson/","content":"# Adaptive Simpson\n<!-- more -->\n## 辛普森公式\n$Simpson$ 积分是积分数值计算的一种方法，用抛物线而非传统的矩形来近似图形，精度较高，公式为：\n$$\n\\int_{a}^{b}f(x)\\,dx \\approx \\frac{b - a}{6n} \\sum_{i = 1}^{n} [f(x_i) + 4f(\\frac{x_i + x_{i - 1}}{2}) + f(x_{i - 1})]\n$$\n具体证明见 [学习笔记 自适应辛普森(Simpson)积分](https://blog.csdn.net/xyz32768/article/details/81392369)\n\n实际计算中不好判断划分数 $n$，因此提出了**自适应**辛普森积分，即在积分数值在可接受范围内直接返回积分值，否则对区间二分递归求解，即：\n$$\n\\int_{a}^{b}f(x)\\,dx \\approx \\frac{b - a}{6} [f(a) + 4f(\\frac{a + b}{2}) + f(b)]\n$$\n## 模板\n不能 $O(1)$ 求出 $f(x)$ 时，保存已有结果能降低时间复杂度，进而可提高精度。可用unordered_map实现优化。\n```cpp\nunordered_map<int, int> mp;\n//f根据要求不同实现不同\ninline long double simpson(long double l, long double r) {\n    double mid = (l + r) / 2;\n    return (f(l) + f(mid) * 4 + f(r)) * (r - l) / 6;\n}\n\nlong double integral(long double l, long double r, long double eps， double i) {\n    long double mid = (l + r) / 2;\n    long double iL = simpson(l, mid), iR = simpson(mid, r);\n    if (fabs(iL + iR - i) <= eps * 15) return iL + iR + (iL + iR - i) / 15;\n    return integral(l, mid, eps / 2, iL) + integral(mid, r, eps / 2, iR);\n}\n\nintegral(l, r, 1e-5, simpson(l, r));\n```\n\n## 面积并\n自适应辛普森积分可以用来解决一些面积并问题，即平面上几何图形覆盖面积的总和。\n\n求面积并：对于 $x$，求出该处覆盖的线长 ($x$ 与图形相交得到一系列线段，按左端点排序计算可得)，那么总线长就是面积并了 (联想二重积分)。\n\n注意：保证线长是连续的，如果不连续需要分段求。此外还需注意区间范围，过大无法保证精度，可能需要其它方法 (如三角形面积并一般用扫描线)。\n# 积分例题\n## A 自适应辛普森法1\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P4525)\n### Code\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong double a, b, c, d, L, R;\n\nunordered_map<long double, long double> mp;\ninline long double f(long double x) {\n    return (c * x + d) / (a * x + b);\n}\n\ninline long double simpson(long double l, long double r) {\n    double mid = (l + r) / 2;\n    return (f(l) + f(mid) * 4 + f(r)) * (r - l) / 6;\n}\n\nlong double integral(long double l, long double r, long double eps) {\n    long double mid = (l + r) / 2;\n    long double iL = simpson(l, mid), iR = simpson(mid, r);\n    long double i = simpson(l ,r);\n    if (fabs(iL + iR - i) <= eps * 15) return iL + iR + (iL + iR - i) / 15;\n    return integral(l, mid, eps / 2) + integral(mid, r, eps / 2);\n}\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << setprecision(6) << fixed;\n    cin >> a >> b >> c >> d >> L >> R;\n    cout << integral(L, R, 1e-7) << endl;\n    return 0;\n}\n```\n\n## B 自适应辛普森法2\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P4526)\n### Solution\n推导可得 $a < 0$ 时发散。$a \\ge 0$ 时， $x < 20$ 时就已收敛\n### Code\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong double a;\n\nunordered_map<long double, long double> mp;\ninline long double f(long double x) {\n    return pow(x, a / x - x);\n}\n\ninline long double simpson(long double l, long double r) {\n    double mid = (l + r) / 2;\n    return (f(l) + f(mid) * 4 + f(r)) * (r - l) / 6;\n}\n\nlong double integral(long double l, long double r, long double eps) {\n    long double mid = (l + r) / 2;\n    long double iL = simpson(l, mid), iR = simpson(mid, r);\n    long double i = simpson(l ,r);\n    if (fabs(iL + iR - i) <= eps * 15) return iL + iR + (iL + iR - i) / 15;\n    return integral(l, mid, eps / 2) + integral(mid, r, eps / 2);\n}\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << setprecision(5) << fixed;\n    cin >> a;\n    if (a < -1e-8) cout << \"orz\" << endl;\n    else cout << integral(1e-8, 20, 1e-7) << endl;\n    return 0;\n}\n```\n\n# 面积并例题\n## A SP8073 CIRU - The area of the union of circles\n### Description\n[题目链接](https://www.luogu.com.cn/problem/SP8073)\n求圆的面积并\n### Solution\n注意到目标函数值不连续，可能存在大量0，故分段进行辛普森积分。\n\n可以通过判断圆的相交求出联通块，对联通块上的圆求面积并。或者将圆的左右端点坐标存入 vector 排序，每次取相邻且不同的坐标 $l, r$，对 $[l, r]$ 进行积分。\n\n本题 $f(x)$ 不能在常数时间获得，可用 unordered_map 优化。\n### Code\n```cpp The area of the union of circles\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 1e3 + 3;\nconstexpr long double EPS = 1e-10;\n\nint n, vis[MAXN];\nvector<int> chosen, G[MAXN];\n\nstruct Circle {\n    /*@param x x of center O @param y y of center O @param R radius*/\n    long double x, y, R;\n    /*@param l 最左端 @param r 最右端*/\n    long double l, r;\n    /*按左端点排序 相同则按右端点排序*/\n    friend inline bool operator<(const Circle& a, const Circle& b) {\n        return a.l < b.l - EPS;\n    }\n} circle[MAXN];\n\nstruct Seg {\n    /*@param l 左端点 @param r 右端点*/\n    long double l, r;\n    /*按左端点排序 相同则按右端点排序*/\n    friend inline bool operator<(const Seg& a, const Seg& b) {\n         return a.l < b.l - EPS;\n    }\n} seg[MAXN];\n\nunordered_map<double, double> mp;\ninline long double f(long double x) { //算x处覆盖的线段总长\n    int tot = 0;\n    for (auto& i : chosen) {\n        long double tmp = pow(circle[i].R, 2) - pow(x - circle[i].x, 2);\n        if (tmp < EPS) continue;\n        seg[++tot].l = circle[i].y - sqrt(tmp);\n        seg[tot].r = circle[i].y + sqrt(tmp);\n    }\n    sort(seg + 1, seg + tot + 1);\n    long double l = seg[1].l, len = .0;\n    for (int i = 1; i <= tot; i++) {\n        l = max(l, seg[i].l);\n        if (l < seg[i].r - EPS) len += seg[i].r - l;\n        l = max(l, seg[i].r);\n    }\n    return len;\n}\n\ninline long double simpson(long double l, long double r) {\n    long double mid = (l + r) / 2;\n    return (f(l) + f(mid) * 4 + f(r)) * (r - l) / 6;\n}\n\nlong double integral(long double l, long double r, long double eps) {\n    long double mid = (l + r) / 2;\n    long double iL = simpson(l, mid), iR = simpson(mid, r);\n    long double i = simpson(l ,r);\n    if (fabs(iL + iR - i) < eps * 15) return iL + iR + (iL + iR - i) / 15;\n    return integral(l, mid, eps / 1.5) + integral(mid, r, eps / 1.5);\n}\n\ninline void init() {\n    for (int i = 1; i <= n; i++) { //circle已按l排序\n        if (vis[i] || circle[i].R < EPS) { //半径为0跳过\n            vis[i] = true; continue;\n        }\n        for (int j = i + 1; j <= n; j++) {\n            if (vis[j] || circle[j].R < EPS) { //半径为0跳过\n                vis[j] = true; continue;\n            }\n            long double tmp = pow(circle[i].x - circle[j].x, 2)\n                            + pow(circle[i].y - circle[j].y, 2);\n            if (tmp < pow(circle[i].R - circle[j].R, 2) + EPS) {//被包含\n                vis[j] = true; continue; //包含关系不加边\n            }\n            if (tmp < pow(circle[i].R + circle[j].R, 2) + EPS)\n                G[i].push_back(j), G[j].push_back(i); //i与j联通\n        }\n    }\n}\n\ninline void dfs(int cur, long double& r) { //处理连通块\n    vis[cur] = true, chosen.push_back(cur);\n    for (auto& to : G[cur]) {\n        if (vis[to]) continue;\n        dfs(to, r = max(r, circle[to].r)); //求最大右端点\n    }\n}\n\ninline long double calc() { //计算面积并\n    long double l, r, ans = .0;\n    for (int i = 1; i <= n; i++) {\n        if (vis[i]) continue;\n        chosen.clear();\n        l = circle[i].l, r = circle[i].r;\n        dfs(i, r); //处理连通块\n        if (chosen.size() == 1) ans += acos(-1) * circle[i].R * circle[i].R;\n        else ans += integral(l, r, 1e-5);\n    }\n    return ans;\n}\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << setprecision(3) << fixed;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> circle[i].x >> circle[i].y >> circle[i].R;\n        circle[i].l = circle[i].x - circle[i].R;\n        circle[i].r = circle[i].x + circle[i].R;\n    }\n    sort(circle + 1, circle + n + 1);\n    init();\n    cout << calc();\n    return 0;\n}\n```\n\n## B NOI2005 月下柠檬树\n### Prolbem\n[题目链接](https://www.luogu.com.cn/problem/P4207)\n### Solution\n投影为一系列圆以及梯形构成，其中梯形的斜边为相邻圆的公切线 (可能不存在)。\n\n切点求法：两圆心分别与对应的切点连线，圆心向连线做垂线，切点向轴做垂线，通过相似三角形求出。\n\n注意：由于投影具有对称性，只需对一半进行积分，否则可能超时。\n### Code\n```cpp NOI2005 月下柠檬树\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 3e3 + 3;\nconstexpr double EPS = DBL_EPSILON;\n\nint n;\ndouble h[MAXN], sumH, alpha;\n\nstruct Circle {\n    /*@param x x of center O @param y y of center O @param R radius*/\n    double x, y, R;\n    /*@param l 最左端 @param r 最右端*/\n    double l, r;\n} circle[MAXN];\n\nstruct Seg {\n    double l, r;\n    friend inline bool operator<(const Seg& a, const Seg& b) {\n        return a.l < b.l - EPS;\n    }\n} seg[MAXN];\n\nstruct Trapezoid {      //梯形类\n    double x1, y1; //右上顶点\n    double x2, y2; //右下顶点\n    double deltaX = 0, height = 0;\n} trape[MAXN];\n\nunordered_map<double, double> mp;\ninline double f(double x) {  //算x处覆盖的线段总长\n    if (mp.count(x)) return mp[x];\n    int tot = 0;\n    for (int i = 1; i <= n; i++) { //圆形\n        double tmp = pow(circle[i].R, 2) - pow(x - circle[i].x, 2);\n        if (tmp < EPS) continue;\n        seg[++tot].l = circle[i].y - sqrt(tmp);\n        seg[tot].r = circle[i].y + sqrt(tmp);\n    }\n    for (int i = 1; i <= n; i++) {  //梯形\n        double l = min(trape[i].x1, trape[i].x2);\n        double r = max(trape[i].x1, trape[i].x2);\n        if (r < x + EPS) continue;\n        if (x < l + EPS) {\n            seg[++tot].l = trape[i].y2, seg[tot].r = trape[i].y1;\n            continue;\n        }\n        double delta = trape[i].x2 - x;\n        double ratio = abs(delta / trape[i].deltaX);\n        if (trape[i].deltaX > EPS) {\n            seg[++tot].r = trape[i].y2 + trape[i].height * ratio;\n            seg[tot].l = trape[i].y2;\n        } else if (trape[i].deltaX < EPS) {\n            seg[++tot].l = trape[i].y2 + trape[i].height * ratio;\n            seg[tot].r = trape[i].y1;\n        }\n    }\n    sort(seg + 1, seg + tot + 1);\n    double len = .0, l = seg[1].l;\n    for (int i = 1; i <= tot; i++) {\n        l = max(l, seg[i].l);\n        if (l < seg[i].r - EPS) len += seg[i].r - l;\n        l = max(l, seg[i].r);\n    }\n    return mp[x] = len;\n}\n\ninline double simpson(double l, double r) {\n    double mid = (l + r) / 2;\n    return (f(l) + f(mid) * 4 + f(r)) * (r - l) / 6;\n}\n\ndouble integral(double l, double r, double eps, double i) {\n    double mid = (l + r) / 2;\n    double iL = simpson(l, mid), iR = simpson(mid, r);\n    if (fabs(iL + iR - i) <= eps * 15) return iL + iR + (iL + iR - i) / 15;\n    return integral(l, mid, eps / 1.6, iL) + integral(mid, r, eps / 1.6, iR);\n}\n\ninline double calc() {  //计算面积并\n    for (int i = 1; i <= n; i++) {\n        double dis = circle[i + 1].y - circle[i].y;  //圆心距离\n        if (dis < abs(circle[i].R - circle[i + 1].R) + EPS) continue;\n        double theta = acos((circle[i].R - circle[i + 1].R) / dis);\n        trape[i].x1 = circle[i + 1].R * sin(theta); //右上顶点\n        trape[i].y1 = circle[i + 1].y + circle[i + 1].R * cos(theta);\n        trape[i].x2 = circle[i].R * sin(theta); //右下顶点\n        trape[i].y2 = circle[i].y + circle[i].R * cos(theta);\n        trape[i].deltaX = trape[i].x2 - trape[i].x1; //\n        trape[i].height = trape[i].y1 - trape[i].y2; //高度\n    }\n    double l = circle[1].l, r = circle[1].r;\n    for (int i = 2; i <= n; i++)\n        l = min(l, circle[i].l), r = max(r, circle[i].r);\n    return integral(0, r, 5e-4, simpson(l, r)) * 2; //对称性 对1边积分\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << setprecision(2) << fixed;\n    cin >> n >> alpha;\n    for (int i = 0; i <= n; i++) cin >> h[i];\n    sumH = h[0];\n    for (int i = 1; i <= n; i++) {\n        cin >> circle[i].R;\n        circle[i].x = 0, circle[i].y = sumH / tan(alpha);\n        circle[i].l = -circle[i].R, circle[i].r = circle[i].R;\n        sumH += h[i];\n    }\n    circle[n + 1].x = 0, circle[n + 1].y = sumH / tan(alpha);\n    circle[n + 1].l = 0, circle[n + 1].r = 0;  //顶点\n    cout << calc() << endl;\n    return 0;\n}\n```\n## C 三角形\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P1222)\n求等腰直角三角形的面积并\n### Solution\n注意到即使三角形有交集，目标函数也会不连续。故不能求连通块，而是改为将三角形的左右端坐标存入 vector 排序，分段积分。\n### Code\n```cpp 三角形\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 2e3 + 3;\nconstexpr double EPS = DBL_EPSILON;\n\nstruct Triangle {\n    /*@param x1 上顶x坐标 @param y1 上顶y坐标*/\n    int x1, y1;\n    /*@param x2 下顶x坐标 @param y2 下顶y坐标*/\n    int x2, y2;\n    friend inline bool operator<(const Triangle& a, const Triangle& b) {\n        return a.x1 < b.x1;\n    }\n} tri[MAXN];\n\nint n, vis[MAXN], st, ed;\nvector<int> G[MAXN], posX, chosen;\npair<double, double> seg[MAXN];\n\nunordered_map<double, double> mp;\ninline double f(double x) {\n    if (mp.count(x)) return mp[x];\n    int tot = 0;\n    for (auto& i : chosen) {\n        if (x < -EPS + tri[i].x1 || tri[i].x2 < -EPS + x) continue;\n        seg[++tot].first = 1.0 * tri[i].y2;\n        seg[tot].second = 1.0 * tri[i].y2 + tri[i].x2 - x;\n    }\n    sort(seg + 1, seg + tot + 1);\n    double len = 0, l = seg[1].first;\n    for (int i = 1; i <= tot; i++) {\n        l = max(l, seg[i].first);\n        if (l < seg[i].second - EPS) len += seg[i].second - l;\n        l = max(l, seg[i].second);\n    }\n    return mp[x] = len;\n}\n\ninline double simpson(double l, double r) {\n    double mid = (l + r) / 2;\n    return (f(l) + f(mid) * 4 + f(r)) * (r - l) / 6;\n}\n\ndouble integral(double l, double r, double eps, double i) {\n    double mid = (l + r) / 2;\n    double iL = simpson(l, mid), iR = simpson(mid, r);\n    if (fabs(iL + iR - i) <= eps * 15) return iL + iR + (iL + iR - i) / 15;\n    return integral(l, mid, eps / 2, iL) + integral(mid, r, eps / 2, iR);\n}\n\ninline void init(double res = 0) {\n    sort(tri + 1, tri + n + 1);\n    sort(posX.begin(), posX.end());\n    auto edIt = unique(posX.begin(), posX.end());\n    for (auto it = posX.begin() + 1; it != edIt; it++) {\n        double l = *(it - 1), r = *(it);\n        chosen.clear();\n        for (int i = 1; i <= n; i++) {\n            if ((tri[i].x1 <= l && l <= tri[i].x2) ||\n                (tri[i].x1 <= r && r <= tri[i].x2)) {\n                chosen.push_back(i);\n            }\n        }\n        l += 2e-9, r -= 2e-9;\n        res += integral(l, r, 1e-4, simpson(l, r));\n    }\n    cout << setprecision(1) << fixed << res << endl;\n}\n\nint main () {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 1, x, y, m; i <= n; i++) {\n        cin >> x >> y >> m;\n        tri[i].x1 = x, tri[i].y1 = y + m;\n        tri[i].x2 = x + m, tri[i].y2 = y;\n        posX.push_back(x), posX.push_back(x + m);\n    }\n    init();\n    return 0;\n}\n```\n## D HNOI2012 三角形覆盖问题\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P3219)\n### Solution\n正解为扫面线，但依然可以用自适应 simpson 积分，只不过需要直接设置 eps，而不是每次递归的时候折半。此外还需判断一个三角形是不是被另一个三角形完全覆盖，是则可以将其跳过。\n### Code\n```cpp 三角形覆盖问题\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr long double EPS = 1e-13;\nconstexpr int MAXN = 1e4 + 5;\n\nint n, x, y, m;\nvector<int> chosen, pos;\nbool vis[MAXN];\n\nstruct Triangle {\n    int x, y, x2, y2;\n    friend inline bool operator<(const Triangle& a, const Triangle& b) {\n        return a.x < b.x;\n    }\n} tri[MAXN];\n\nstruct Segment {\n    long double l, r;\n    friend bool operator<(const Segment& a, const Segment& b) {\n        return a.l < b.l;\n    }\n} seg[MAXN];\n\nunordered_map<long double, long double> mp;\ninline long double f(long double x) {\n    if (mp.count(x)) return mp[x];\n    int tot = 0;\n    for (auto& i : chosen) {\n        if (x < (long double)tri[i].x - EPS || (long double)tri[i].x2 < x - EPS) continue;\n        seg[++tot].l = (long double)tri[i].y2;\n        seg[tot].r = (long double)tri[i].y - x + (long double)tri[i].x;\n    }\n    sort(seg + 1, seg + tot + 1);\n    long double l = seg[1].l, len = .0;\n    for (int i = 1; i <= tot; i++) {\n        l = max(l, seg[i].l);\n        if (seg[i].r - l > EPS) len += seg[i].r - l;\n        l = max(l, seg[i].r);\n    }\n    return mp[x] = len;\n}\n\nlong double simpson(long double l, long double r) {\n    long double mid = (l + r) / 2;\n    return (f(l) + f(mid) * 4 + f(r)) * (r - l) / 6;\n}\n\nlong double integral(long double l, long double r, long double eps, long double i) {\n    long double mid = (l + r) / 2;\n    long double iL = simpson(l, mid), iR = simpson(mid, r);\n    if (fabs(iR + iL - i) <= eps) return iL + iR + fabs(iR + iL - i);\n    return integral(l, mid, eps, iL) + integral(mid, r, eps, iR);\n}\n\nvoid init() {\n    for (int i = 1; i <= n; i++) {\n        if (vis[i]) continue;\n        if (tri[i].x2 - tri[i].x == 0) {\n            vis[i] = 1;\n            continue;\n        }\n        for (int j = i + 1; j <= n; j++) {\n            if (vis[j]) continue;\n            if (tri[j].x2 - tri[j].x == 0) {\n                vis[j] = 1;\n                continue;\n            }\n            if (tri[j].y <= tri[i].y && tri[j].x >= tri[i].x &&\n                tri[j].x2 <= tri[i].x2 && tri[j].y2 >= tri[i].y2 &&\n                tri[j].y <= tri[i].y - (tri[j].x - tri[i].x)) {\n                vis[j] = 1;\n            }\n        }\n    }\n}\n\nvoid calc() {\n    sort(pos.begin(), pos.end());\n    sort(tri + 1, tri + n + 1);\n    auto edIt = unique(pos.begin(), pos.end());\n    init();\n    long double ans = .0;\n    for (auto it = pos.begin() + 1; it != edIt; it++) {\n        int l = *(it - 1), r = *it;\n        chosen.clear();\n        for (int i = 1; i <= n; i++) {\n            if (vis[i]) continue;\n            if (tri[i].x >= r) break;\n            if ((tri[i].x <= l && l <= tri[i].x2) ||\n                (tri[i].x <= r && r <= tri[i].x2))\n                chosen.emplace_back(i);\n        }\n        if (!chosen.size()) continue;\n        long double L = 2 * EPS + l, R = - 2 * EPS + r;\n        ans += integral(L, R, 1e-14, simpson(L, R));\n    }\n    cout << setprecision(1) << fixed << ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> x >> y >> m;\n        tri[i].x = x, tri[i].y = y + m;\n        tri[i].x2 = x + m, tri[i].y2 = y;\n        pos.emplace_back(x), pos.emplace_back(x + m);\n    }\n    calc();\n    return 0;\n}\n```\n","tags":["自适应Simpson","面积并"],"categories":["数论","自适应Simpson","计算几何","面积并"]},{"title":"半平面交笔记 Half Plane Intersection","url":"/2020/08/08/Half-Plane-Intersection/","content":"# Half Plane Intersection\n<!-- more -->\n[参考资料](https://oi-wiki.org/geometry/half-plane/)\n## 半平面\n一条直线和直线的一侧。半平面是一个点集，因此是一条直线和直线的一侧构成的点集。当包含直线时，称为闭半平面；当不包含直线时，称为开半平面。\n解析式一般为 $Ax + By + C \\ge 0$。\n在计算几何中用向量表示，整个题统一以向量的左侧或右侧为半平面。\n## 半平面交\n半平面交是指多个半平面的交集。因为半平面是点集，所以点集的交集仍然是点集。在平面直角坐标系围成一个区域(可以理解为向量集中每一个向量的左侧交)。\n这就很像普通的线性规划问题了，得到的半平面交就是线性规划中的可行域。一般情况下半平面交是有限的，经常考察面积等问题的解决。\n## 多边形的核\n如果一个点集中的点与多边形上任意一点的连线与多边形没有其他交点，那么这个点集被称为多边形的核。\n把多边形的每条边看成是首尾相连的向量，那么这些向量在多边形内部方向的半平面交就是多边形的核。\n## 解法 - $S&I$算法\n### 极角排序\n利用 atan2(y, x) 函数将向量(线段)按极角排序，排序时，若遇到贡献向量(且方向相同)，则取靠近可行域的一个(即靠近左侧的向量)。判断方法为取一个向量的起点与另一个向量的起点、终点构成向量，通过叉积符号判断。\n```cpp 极角排序\n/*cross product of two Vec2 vector (starting point is zero)*/\nfriend inline double operator*(const Vec2& a, const Vec2& b) {\n    return a.x * b.y - a.y * b.x;\n}\n//s是Seg类的起点，t为终点\nfriend inline bool operator<(const Seg& a, const Seg& b) {//比较极角\n    // theta1 != theta2 按theta排序\n    if (abs(a.theta - b.theta) > EPS) return a.theta < b.theta;\n    // theta1 == theta2 判断向量a在b的哪边，令最靠左的排在最左边\n    return (b.s - a.s) * (b.t - a.s) > EPS;\n}\n```\n\n### 维护单调队列\n因为半平面交是一个凸多边形，所以需要维护一个凸壳。因为后来加入边的只可能会影响最开始加入的或最后加入的边（此时凸壳连通），只需要删除队首和队尾的元素，所以需要用单调队列。\n具体维护方法见 [oi-wiki.org](https://oi-wiki.org/geometry/half-plane/)\n\n### 得到半平面交\n如果半平面交是一个凸 $n$ 边形，最后在交点数组里会得到 $n$ 个点。我们再把它们首尾相连，就是一个统一方向（顺或逆时针）的多边形。\n此时就可以用三角剖分求面积了。（求面积是最基础的考法）\n偶尔会出现半平面交不存在或面积为 0 的情况，注意考虑边界。\n\n### 代码\n```cpp 向量类(也可以表示一个点)\nstruct Vec2 {  //点向量类\n    Vec2() = default;\n    Vec2(double _x, double _y) : x(_x), y(_y) {}\n    /*Vec2 vector a - Vec2 vector b @return Vec2(x, y)*/\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n    /*Vec2 vector a + Vec2 vector b @return Vec2(x, y)*/\n    friend inline Vec2 operator+(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x + b.x, a.y + b.y);\n    }\n    /*cross product of two Vec2 vector (starting point is zero)*/\n    friend inline double operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;\n    }\n    /*Vec2 * num operation @return Vec2(x, y)*/\n    friend inline Vec2 operator*(const Vec2& a, double num) {\n        return Vec2(a.x * num, a.y * num);\n    }\n    /*input coordinate of Vec2 through istream*/\n    inline friend istream& operator>>(istream& is, Vec2& p) {\n        is >> p.x >> p.y;\n        return is;\n    }\n    /*@param x x坐标 @param y y坐标*/\n    double x = 0, y = 0;\n} vertex[MAXN], its[MAXN]/*intersected points*/;\n```\n线段类(极角排序，对应直线的交点)\n```cpp 线段类\nstruct Seg {  //线段类 起点s, 终点t\n    Seg() = default;\n    Seg(Vec2 _s, Vec2 _t) : s(_s), t(_t) { theta = atan2((t - s).y, (t - s).x); }\n    /*comparison of two Seg @return bool*/\n    friend inline bool operator<(const Seg& a, const Seg& b) {//比较极角\n        // theta1 != theta2 按theta排序\n        if (abs(a.theta - b.theta) > EPS) return a.theta < b.theta;\n        // theta1 == theta2 判断向量a在b的哪边，令最靠左的排在最左边\n        return (b.s - a.s) * (b.t - a.s) > EPS;\n    }\n    /*intersection of two Seg @return Vec2(x, y)*/\n    inline friend Vec2 intersect(const Seg& a, const Seg& b) {\n        double ratio = ((b.t - b.s) * (a.s - b.s)) / ((a.t - a.s) * (b.t - b.s));\n        return a.s + (a.t - a.s) * ratio;\n    }\n    /*@param s 起点 @param t 终点*/\n    Vec2 s, t;\n    /*@param theta 极角*/\n    double theta = 1e9;\n} seg[MAXN], q[MAXN]/*deque 队列中存放线段*/;\n```\n半平面交\n```cpp\n//求向量左侧的半平面交 \n//队列中线段范围 (l, r]，若半平面交不闭合，则范围为 (l, r)\n//第一个交点是 its[l + 2]，因为 seg[l + 2] 为第二条线段\ninline void halfPlaneIntersection() {\n    sort(seg + 1, seg + tot + 1);\n    int l = 0, r = 0;\n    for (int i = 1; i <= tot; i++) {\n        if (abs(seg[i].theta - seg[i - 1].theta) > EPS) {\n            while (r - l > 1 && (seg[i].t - its[r]) * (seg[i].s - its[r]) > EPS)\n                --r;\n            while (r - l > 1 && (seg[i].t - its[l + 2]) * (seg[i].s - its[l + 2]) > EPS)\n                ++l;\n            q[++r] = seg[i];\n            if (r - l > 1) its[r] = intersect(q[r], q[r - 1]); //求新交点\n        }\n    }\n    while (r - l > 1 && (q[l + 1].t - its[r]) * (q[l + 1].s - its[r]) > EPS)\n        --r; //删除多余元素\n    its[r + 1] = intersect(q[l + 1], q[r]), ++r; //终点线段与起点线段相交\n\n    double ans(0);\n    for (int i = l + 2; i < r; i++) { // l + 2 是起始交点 三角剖分求面积\n        ans += (its[i] * its[i + 1]) / 2;\n    }\n    ans += (its[r] * its[l + 2]) / 2;\n    cout << setprecision(3) << fixed << ans << endl;\n}\n```\n\n# 例题\n## A CQOI2006 凸多边形\n### Description\n[模板题](https://www.luogu.com.cn/problem/P4196)\n### Code\n```cpp CQOI2006 凸多边形\n#include <bits/stdc++.h>\n#define PI acos(-1)\n\nusing namespace std;\n\nconstexpr double EPS = 1e-8;\nconstexpr int MAXN = 1e5 + 5;\n\nstruct Vec2 {  //点向量类\n    Vec2() = default;\n    Vec2(double _x, double _y) : x(_x), y(_y) {}\n    /*Vec2 vector a - Vec2 vector b @return Vec2(x, y)*/\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n    /*Vec2 vector a + Vec2 vector b @return Vec2(x, y)*/\n    friend inline Vec2 operator+(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x + b.x, a.y + b.y);\n    }\n    /*cross product of two Vec2 vector (starting point is zero)*/\n    friend inline double operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;\n    }\n    /*Vec2 * num operation @return Vec2(x, y)*/\n    friend inline Vec2 operator*(const Vec2& a, double num) {\n        return Vec2(a.x * num, a.y * num);\n    }\n    /*input coordinate of Vec2 through istream*/\n    inline friend istream& operator>>(istream& is, Vec2& p) {\n        is >> p.x >> p.y;\n        return is;\n    }\n    /*@param x x坐标 @param y y坐标*/\n    double x = 0, y = 0;\n} vertex[MAXN], its[MAXN]/*intersected points*/;\n\nstruct Seg {  //线段类 起点s, 终点t\n    Seg() = default;\n    Seg(Vec2 _s, Vec2 _t) : s(_s), t(_t) { theta = atan2((t - s).y, (t - s).x); }\n    /*comparison of two Seg @return bool*/\n    friend inline bool operator<(const Seg& a, const Seg& b) {//比较极角\n        // theta1 != theta2 按theta排序\n        if (abs(a.theta - b.theta) > EPS) return a.theta < b.theta;\n        // theta1 == theta2 判断向量a在b的哪边，令最靠左的排在最左边\n        return (b.s - a.s) * (b.t - a.s) > EPS;\n    }\n    /*intersection of two Seg @return Vec2(x, y)*/\n    inline friend Vec2 intersect(const Seg& a, const Seg& b) {\n        double ratio = ((b.t - b.s) * (a.s - b.s)) / ((a.t - a.s) * (b.t - b.s));\n        return a.s + (a.t - a.s) * ratio;\n    }\n    /*@param s 起点 @param t 终点*/\n    Vec2 s, t;\n    /*@param theta 极角*/\n    double theta = 1e9;\n} seg[MAXN], q[MAXN]/*deque 队列中存放线段*/;\nint n, cntVer, tot;\n/*求向量左侧的半平面交 队列范围(l, r]*/\ninline void halfPlaneIntersection() {\n    sort(seg + 1, seg + tot + 1);\n    int l = 0, r = 0;\n    for (int i = 1; i <= tot; i++) {\n        if (abs(seg[i].theta - seg[i - 1].theta) > EPS) {\n            while (r - l > 1 && (seg[i].t - its[r]) * (seg[i].s - its[r]) > EPS)\n                --r;\n            while (r - l > 1 && (seg[i].t - its[l + 2]) * (seg[i].s - its[l + 2]) > EPS)\n                ++l;\n            q[++r] = seg[i];\n            if (r - l > 1) its[r] = intersect(q[r], q[r - 1]); //求新交点\n        }\n    }\n    while (r - l > 1 && (q[l + 1].t - its[r]) * (q[l + 1].s - its[r]) > EPS)\n        --r; //删除多余元素\n    its[r + 1] = intersect(q[l + 1], q[r]), ++r; //终点线段与起点线段相交\n\n    double ans(0);\n    for (int i = l + 2; i < r; i++) { // l + 2 是起始交点 三角剖分求面积\n        ans += (its[i] * its[i + 1]) / 2;\n    }\n    ans += (its[r] * its[l + 2]) / 2;\n    cout << setprecision(3) << fixed << ans << endl;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> cntVer;\n        for (int j = 1; j <= cntVer; j++) cin >> vertex[j];\n        for (int j = 1; j < cntVer; j++)\n            seg[++tot] = Seg(vertex[j], vertex[j + 1]);\n        seg[++tot] = Seg(vertex[cntVer], vertex[1]);\n    }\n    halfPlaneIntersection();\n    return 0;\n}\n```\n## B UVA1304 Art Gallery\n### Description\n[UVA1304 Art Gallery](https://www.luogu.com.cn/problem/UVA1304)\n### Solution\n求凸多边形的核的面积，即求边的半平面交的面积。有的时候需要注意给出点的顺逆时针方向。\n\n## C ZJOI2008 瞭望塔\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P2600)\n在山的轮廓线上选取一个位置建瞭望塔，使得在瞭望塔最顶端能看到山的每一个角落，求瞭望塔高的最小值。\n### Solution\n先求出轮廓左侧半平面交(非闭合)，可以证明瞭望塔高取最小值时一定在 $x_i$ 或半平面交的交点所对应的 $x$ 处。\n对于每个 $x_i$，做垂直于水平方向的直线与半平面交的边界相交，求出 $deltaY$。\n对于半平面交的交点，同样做垂线，与轮廓线相交，求出 $deltaY$。\n注意：半平面交没有闭合，线段的取值范围为(l, r)。\n### Code\n```cpp ZJOI2008 瞭望塔\n#include <bits/stdc++.h>\n#define PI acos(-1)\n\nusing namespace std;\n\nconstexpr double EPS = 1e-8;\nconstexpr int MAXN = 1e5 + 5;\n\nstruct Vec2 {  //点向量类\n    Vec2() = default;\n    Vec2(double _x, double _y) : x(_x), y(_y) {}\n    /*Vec2 vector a - Vec2 vector b @return Vec2(x, y)*/\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n    /*Vec2 vector a + Vec2 vector b @return Vec2(x, y)*/\n    friend inline Vec2 operator+(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x + b.x, a.y + b.y);\n    }\n    /*cross product of two Vec2 vector (starting point is zero)*/\n    friend inline double operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;\n    }\n    /*Vec2 * num operation @return Vec2(x, y)*/\n    friend inline Vec2 operator*(const Vec2& a, double num) {\n        return Vec2(a.x * num, a.y * num);\n    }\n    /*input coordinate of Vec2 through istream*/\n    inline friend istream& operator>>(istream& is, Vec2& p) {\n        is >> p.x >> p.y;\n        return is;\n    }\n    /*@param x x坐标 @param y y坐标*/\n    double x = 0, y = 0;\n} vertex[MAXN], its[MAXN];\n\nstruct Seg {  //线段类 起点s, 终点t\n    Seg() = default;\n    Seg(Vec2 _s, Vec2 _t) : s(_s), t(_t) {\n        theta = atan2((t - s).y, (t - s).x);\n    }\n    /*comparison of two Seg @return bool*/\n    friend inline bool operator<(const Seg& a, const Seg& b) {  //比较极角\n        // theta1 != theta2 按theta排序\n        if (abs(a.theta - b.theta) > EPS) return a.theta < b.theta;\n        // theta1 == theta2 判断向量a在b的哪边，令最靠左的排在最左边\n        return (b.s - a.s) * (b.t - a.s) > EPS;\n    }\n    /*intersection of two Seg @return Vec2(x, y)*/\n    inline friend Vec2 intersect(const Seg& a, const Seg& b) {\n        double ratio = ((b.t - b.s) * (a.s - b.s)) / ((a.t - a.s) * (b.t - b.s));\n        return a.s + (a.t - a.s) * ratio;\n    }\n    /*@param s 起点 @param t 终点*/\n    Vec2 s, t;\n    /*@param theta 极角*/\n    double theta = 1e9;\n} seg[MAXN], q[MAXN];\nint n, cntVer, tot, x[MAXN], y[MAXN];\n\ninline void getHeight(int l, int r, double res = 1e15) {\n    for (int i = 1; i <= n; i++) {\n        double h = 0;\n        for (int j = l + 1; j < r; j++) {\n            auto tmpIts = intersect(q[j], Seg(Vec2(x[i], -1), Vec2(x[i], y[i])));\n            h = max(h, tmpIts.y);\n        }\n        res = min(res, h - y[i]);\n    }\n    for (int i = 1; i < n; i++)\n        for (int j = l + 2; j < r; j++) {\n            if (its[j].x >= x[i] && its[j].x <= x[i + 1]) {\n                auto tmpIts =\n                    intersect(Seg(Vec2(its[j].x, -1), Vec2(its[j].x, its[j].y)),\n                              Seg(Vec2(x[i], y[i]), Vec2(x[i + 1], y[i + 1])));\n                res = min(res, its[j].y - tmpIts.y);\n            }\n        }\n    cout << setprecision(3) << fixed << res << endl;\n}\n/*求向量左侧的半平面交 队列范围(l, r]*/\ninline void halfPlaneIntersection() {\n    sort(seg + 1, seg + tot + 1);\n    int l = 0, r = 0;\n    for (int i = 1; i <= tot; i++) {\n        if (abs(seg[i].theta - seg[i - 1].theta) > EPS) {\n            while (r - l > 1 && (seg[i].t - its[r]) * (seg[i].s - its[r]) > EPS)\n                --r;\n            while (r - l > 1 &&\n                   (seg[i].t - its[l + 2]) * (seg[i].s - its[l + 2]) > EPS)\n                ++l;\n            q[++r] = seg[i];\n            if (r - l > 1) its[r] = intersect(q[r], q[r - 1]);  //求新交点\n        }\n    }\n    while (r - l > 1 && (q[l + 1].t - its[r]) * (q[l + 1].s - its[r]) > EPS)\n        --r;                                      //删除多余元素\n    its[r + 1] = intersect(q[l + 1], q[r]), ++r;  //终点线段与起点线段相交\n\n    getHeight(l, r);\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> x[i];\n    for (int i = 1; i <= n; i++) cin >> y[i];\n    for (int i = 1; i < n; i++)\n        seg[++tot] = Seg(Vec2(x[i], y[i]), Vec2(x[i + 1], y[i + 1]));\n    halfPlaneIntersection();\n    return 0;\n}\n```\n\n## D UVA1396 Most Distant Point from the Sea\n### Description\n[题目链接](https://www.luogu.com.cn/problem/UVA1396)\n求凸多边形的最大内切圆半径。\n### Solution\n将多边形的边向内平移，当半平面交面积为 0 或不存在时，即所平移的距离为最大内切圆的半径。接下来二分移动的距离即可。\n### Code\n```cpp Most Distant Point from the Sea\n#include <bits/stdc++.h>\n#define PI acos(-1)\n\nusing namespace std;\n//求多边形最大内切圆半径 二分 + 半平面交\nconstexpr long double EPS = 1e-11;\nconstexpr int MAXN = 300;\n\nstruct Vec2 {  //点向量类\n    Vec2() = default;\n    Vec2(long double _x, long double _y) : x(_x), y(_y) {}\n    /*Vec2 vector a - Vec2 vector b @return Vec2(x, y)*/\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n    /*Vec2 vector a + Vec2 vector b @return Vec2(x, y)*/\n    friend inline Vec2 operator+(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x + b.x, a.y + b.y);\n    }\n    /*cross product of two Vec2 vector (starting point is zero)*/\n    friend inline long double operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;\n    }\n    /*Vec2 * num operation @return Vec2(x, y)*/\n    friend inline Vec2 operator*(const Vec2& a, long double num) {\n        return Vec2(a.x * num, a.y * num);\n    }\n    /*input coordinate of Vec2 through istream*/\n    inline friend istream& operator>>(istream& is, Vec2& p) {\n        is >> p.x >> p.y;\n        return is;\n    }\n    /*@param x x坐标 @param y y坐标*/\n    long double x = 0, y = 0;\n} vertex[MAXN], its[MAXN]/*intersected points*/;\n\nstruct Seg {  //线段类 起点s, 终点t\n    Seg() = default;\n    Seg(Vec2 _s, Vec2 _t) : s(_s), t(_t) { theta = atan2((t - s).y, (t - s).x); }\n    /*comparison of two Seg @return bool*/\n    friend inline bool operator<(const Seg& a, const Seg& b) {//比较极角\n        // theta1 != theta2 按theta排序\n        if (abs(a.theta - b.theta) > EPS) return a.theta < b.theta;\n        // theta1 == theta2 判断向量a在b的哪边，令最靠左的排在最左边\n        return (b.s - a.s) * (b.t - a.s) > EPS;\n    }\n    /*intersection of two Seg @return Vec2(x, y)*/\n    inline friend Vec2 intersect(const Seg& a, const Seg& b) {\n        long double ratio = ((b.t - b.s) * (a.s - b.s)) / ((a.t - a.s) * (b.t - b.s));\n        return a.s + (a.t - a.s) * ratio;\n    }\n    /*@param s 起点 @param t 终点*/\n    Vec2 s, t;\n    /*@param theta 极角*/\n    long double theta = 1e9;\n} seg[MAXN], sg[MAXN], q[MAXN]/*deque 队列中存放线段*/;\nint n, tot;\n/*求向量左侧的半平面交 队列范围[l, r]*/\ninline bool halfPlaneIntersection() {\n    sort(sg + 1, sg + tot + 1);\n    int l = 0, r = 0;\n    for (int i = 1; i <= tot; i++) {\n        if (abs(sg[i].theta - sg[i - 1].theta) > EPS) {\n            while (r - l > 1 && (sg[i].t - its[r]) * (sg[i].s - its[r]) > EPS)\n                --r;\n            while (r - l > 1 && (sg[i].t - its[l + 2]) * (sg[i].s - its[l + 2]) > EPS)\n                ++l;\n            q[++r] = sg[i];\n            if (r - l > 1) its[r] = intersect(q[r], q[r - 1]); //求新交点\n        }\n    }\n    while (r - l > 1 && (q[l + 1].t - its[r]) * (q[l + 1].s - its[r]) > EPS)\n        --r; //删除多余元素\n    its[r + 1] = intersect(q[l + 1], q[r]), ++r; //终点线段与起点线段相交\n\n    long double ans(0);\n    for (int i = l + 2; i < r; i++) { // l + 2 是起始交点 三角剖分求面积\n        ans += (its[i] * its[i + 1]) / 2;\n    }\n    ans += (its[r] * its[l + 2]) / 2;\n    return ans > EPS;\n}\n\ninline void translate(long double mid) { //平移 mid\n    for (int i = 1; i <= tot; i++) {\n        long double theta = seg[i].theta + PI / 2;\n        long double deltaX = mid * cos(theta);\n        long double deltaY = mid * sin(theta);\n        auto delta = Vec2(deltaX, deltaY);\n        sg[i] = Seg(seg[i].s + delta, seg[i].t + delta);\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    while (cin >> n && n) {\n        tot = 0;\n        for (int i = 1; i <= n; i++) cin >> vertex[i];\n        for (int i = 1; i <= n; i++)\n            seg[++tot] = Seg(vertex[i], vertex[i % n + 1]);\n        long double l = 0, r = 1e5;\n        while (l < r - EPS) {\n            long double mid = (l + r) / 2;\n            translate(mid);\n            if (halfPlaneIntersection()) l = mid;\n            else r = mid;\n        }\n        cout << setprecision(8) << fixed << l << endl;\n    }\n    return 0;\n}\n```\n","tags":["半平面交"],"categories":["计算几何","半平面交"]},{"title":"旋转卡壳笔记 Rotating Calipers","url":"/2020/08/08/Rotating-Calipers/","content":"# Rotating Calipers\n<!-- more -->\n[参考资料](https://zhuanlan.zhihu.com/p/68617952)\n## 凸多边形的切线\n如果一条直线与凸多边形有交点，并且整个凸多边形都在这条直线的一侧，那么这条直线就是该凸多边形的一条切线。\n## 对踵点\n如果过凸多边形上两点作一对平行线，使得整个多边形都在这两条线之间，那么这两个点被称为一对对踵点。\n## 凸多边形的直径\n即凸多边形上任意两个点之间距离的最大值。直径一定会**在对踵点中产生**，如果两个点不是对踵点，那么两个点中一定可以让一个点向另一个点的对踵点方向移动使得距离更大。并且点与点之间的距离可以体现为线与线之间的距离，在非对踵点之间构造平行线，一定没有在对踵点构造平行线优，这一点可以通过平移看出。\n## 旋转卡壳\n![](/images/RotatingCalipers.gif)\n通过求出每一条边的对踵点，即可求出凸多边形的直径。通过上面的图可以看出，边的对踵点同时是这两个点的对踵点，因此并没有遗漏。\n![](/images/RotatingCalipers2.png)\n具体来讲，通过向量叉积求出边与顶点形成三角形的面积，此三角形的面积也就反映了点到直线的距离。由于面积是单峰的，那么对单独一条边的对踵点，我们可以用三分来求，对于所有边，我们可以用 $two-pointer$ 来 $O(n)$ 求出。因为随着边在逆时针枚举，它的对踵点 $T$ 也在逆时针移动。\n## 步骤\n首先求出凸包，目的是把所有点按逆时针排序。然后枚举逆时针边，定义 $T$ 为当前的对踵点，若 $T$ 逆时针变动能增大到形成的三角形面积改变 $T$，直到继续改变会导致距离减小为止。每次求出边（设为 $AB$）的对踵点 $T_i$ 后，分别用 $|AT_i|, |BT_i|$ 来更新答案，即凸多边形的直径。\n时间复杂度 $O(n)$。\n## Code\n```cpp Rotating Calipers\n/*Vec2类中operator*重载为了向量叉积 norm为向量取模 cov为凸壳上的点*/\ninline long double rotatingCalipers(long double res = 0) { //旋转卡壳\n    convex();\n    int up = 1, left = 1, right = 1;\n    if (top == 3) return normSquare(cov[1] - cov[2]);\n    for (int i = 1; i < top; i++) {\n        while (true) { //寻找对踵点 two polong doubleers\n            auto s = cov[i], t = cov[i + 1];\n            auto x1 = cov[up], x2 = cov[up + 1];\n            long double s1 = abs((s - x1) * (t - x1));\n            long double s2 = abs((s - x2) * (t - x2));\n            if (s1 < s2 + EPS) up = up % (top - 1) + 1; //h1 <= h2\n            else break;\n        }\n        res = max(res, normSquare(cov[i] - cov[up]));\n        res = max(res, normSquare(cov[i + 1] - cov[up]));\n    }   \n    return res;\n}\n```\n下附向量类\n```cpp 向量类\nstruct Vec2 {\n    Vec2() = default;\n    Vec2(long double _x, long double _y) : x(_x), y(_y) {}\n\n    friend inline Vec2 intersect(const Vec2&, const Vec2&, const Vec2&, const Vec2&);\n\n    friend inline bool operator<(const Vec2& a, const Vec2& b) {\n        return a.x == b.x ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline Vec2 operator+(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x + b.x, a.y + b.y);\n    }\n    /*@return cross product of two Vec2*/\n    friend inline long double operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;  //×\n    }\n    /*@return 向量与数乘后的向量*/\n    friend inline Vec2 operator*(const Vec2& a, long double num) {\n        return Vec2(a.x * num, a.y * num);\n    }\n    /*@param a 2D vector @return norm of the vector*/\n    friend inline long double norm(const Vec2& a) {\n        return sqrt(a.x * a.x + a.y * a.y);\n    }\n    /*@param a 2D vector @return square norm of the vector*/\n    friend inline long double normSquare(const Vec2& a) {\n        return a.x * a.x + a.y * a.y;\n    }\n    long double x = 0, y = 0;\n} vec[MAXN];\n\n/*@return intersect point of two Seg*/\ninline Vec2 intersect(const Vec2& s1, const Vec2& t1,\n                        const Vec2& s2, const Vec2& t2) {\n    long double ratio = ((s1 - s2) * (t2 - s2)) / ((t2 - s2) * (t1 - s1));\n    return s1 + (t1 - s1) * ratio;\n}\n```\n\n# 例题\n## A Beauty Contest G\n### Description\n[模板题](https://www.luogu.com.cn/problem/P1452)\n### Solution\n模板题。不过求的是模长的平方。\n### Code\n```cpp Beauty Contest G\n#include <bits/stdc++.h>\n#define PI acos(-1)\n\nusing namespace std;\n//小数旋转卡壳\nconstexpr int MAXN = 2e5 + 5;\nconstexpr long double EPS = 1e-10;\n\nstruct Vec2 {\n    Vec2() = default;\n    Vec2(long double _x, long double _y) : x(_x), y(_y) {}\n\n    friend inline Vec2 intersect(const Vec2&, const Vec2&, const Vec2&, const Vec2&);\n\n    friend inline bool operator<(const Vec2& a, const Vec2& b) {\n        return a.x == b.x ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline Vec2 operator+(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x + b.x, a.y + b.y);\n    }\n    /*@return cross product of two Vec2*/\n    friend inline long double operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;  //×\n    }\n    /*@return 向量与数乘后的向量*/\n    friend inline Vec2 operator*(const Vec2& a, long double num) {\n        return Vec2(a.x * num, a.y * num);\n    }\n    /*@param a 2D vector @return norm of the vector*/\n    friend inline long double norm(const Vec2& a) {\n        return sqrt(a.x * a.x + a.y * a.y);\n    }\n    /*@param a 2D vector @return square norm of the vector*/\n    friend inline long double normSquare(const Vec2& a) {\n        return a.x * a.x + a.y * a.y;\n    }\n\n    long double x = 0, y = 0;\n} vec[MAXN], cov[MAXN];\n\n/*@return intersect point of two Seg*/\ninline Vec2 intersect(const Vec2& s1, const Vec2& t1,\n                        const Vec2& s2, const Vec2& t2) {\n    long double ratio = ((s1 - s2) * (t2 - s2)) / ((t2 - s2) * (t1 - s1));\n    return s1 + (t1 - s1) * ratio;\n}\n\nint n, top;\n\ninline void convex() {\n    top = 0;\n    sort(vec + 1, vec + n + 1);\n    for (int i = 1; i <= n; i++) {  //下凸壳\n        while (top > 1 && (cov[top] - cov[top - 1]) * (vec[i] - cov[top]) <= 0)\n            cov[top--] = Vec2(0, 0);\n        cov[++top] = vec[i];\n    }\n    int up = top; //上凸壳起点\n    for (int i = n - 1; i > 0; i--) {  //上凸壳\n        while (top > up && (cov[top] - cov[top - 1]) * (vec[i] - cov[top]) <= 0)\n            cov[top--] = Vec2(0, 0);\n        cov[++top] = vec[i];\n    }\n}\n\ninline long double rotatingCalipers(long double res = 0) { //旋转卡壳\n    convex();\n    int up = 1, left = 1, right = 1;\n    if (top == 3) return normSquare(cov[1] - cov[2]);\n    for (int i = 1; i < top; i++) {\n        while (true) { //寻找对踵点 two polong doubleers\n            auto s = cov[i], t = cov[i + 1];\n            auto x1 = cov[up], x2 = cov[up + 1];\n            long double s1 = abs((s - x1) * (t - x1));\n            long double s2 = abs((s - x2) * (t - x2));\n            if (s1 < s2 + EPS) up = up % (top - 1) + 1; //h1 <= h2\n            else break;\n        }\n        res = max(res, normSquare(cov[i] - cov[up]));\n        res = max(res, normSquare(cov[i + 1] - cov[up]));\n    }   \n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> vec[i].x >> vec[i].y;\n    cout << setprecision(0) << fixed << rotatingCalipers() << endl; //返回最远点对距离的平方\n    return 0;\n}\n```\n\n## B HNOI2007 最小矩形覆盖\n### Description\n[题目链接](https://www.luogu.com.cn/problem/P3187)\n给定一些点的坐标，要求求能够覆盖所有点的最小面积的矩形，输出所求矩形的面积和四个顶点坐标。\n### Solution\n首先最小矩形覆盖下的矩形的一条边一定在凸包上。与旋转卡壳求凸多边形直径类似，利用单峰性求出距离直线最远的顶点 $up$，最靠右的点 $right$ (通过向量点 $>0$ 积判断)，最靠左的点 $left$ (通过向量点积 $<0$ 判断)。通过这三个点和选取的凸包上的一条边可以求出矩形四个顶点，进而求出最小矩形覆盖面积。\n顶点求法：由 $up, left, right$ 对应的矩形边以及选取的直线 $AB$ 相交可得(实现起来略微复杂，两线段对应直线的交点见 $intersect()$ 函数)。\n### Code\n```cpp 最小矩形覆盖\n#include <bits/stdc++.h>\n#define PI acos(-1)\n\nusing namespace std;\n\nconstexpr int MAXN = 2e5 + 5;\nconstexpr long double EPS = 1e-10;\n\nstruct Vec2 {\n    Vec2() = default;\n    Vec2(long double _x, long double _y) : x(_x), y(_y) {}\n\n    friend inline bool operator<(const Vec2& a, const Vec2& b) {\n        return a.x == b.x ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline Vec2 operator+(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x + b.x, a.y + b.y);\n    }\n    /*@return cross product of two Vec2*/\n    friend inline long double operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;  //×\n    }\n    /*@return 向量与数乘后的向量*/\n    friend inline Vec2 operator*(const Vec2& a, long double num) {\n        return Vec2(a.x * num, a.y * num);\n    }\n    /*@param a 2D vector @return norm of the vector*/\n    friend inline long double norm(const Vec2& a) {\n        return sqrt(a.x * a.x + a.y * a.y);\n    }\n    /*@param a 2D vector @return square norm of the vector*/\n    friend inline long double normSquare(const Vec2& a) {\n        return a.x * a.x + a.y * a.y;\n    }\n    /*@return dot product of two vectors*/\n    friend inline long double dot(const Vec2& a, const Vec2& b) {\n        return a.x * b.x + a.y * b.y;\n    }\n    long double x = 0, y = 0;\n} vec[MAXN], ans[4];\n\n/*@return intersect point of two Seg*/\ninline Vec2 intersect(const Vec2& s1, const Vec2& t1, const Vec2& s2,\n                      const Vec2& t2) {\n    long double ratio = ((s1 - s2) * (t2 - s2)) / ((t2 - s2) * (t1 - s1));\n    return s1 + (t1 - s1) * ratio;\n}\n\nint cnt;\nint stk[MAXN], used[MAXN], top;\n\ninline void convex() {  //求凸包 旧版写法\n    sort(vec + 1, vec + cnt + 1);\n    top = 0, stk[++top] = 1;\n    for (int i = 2; i <= cnt; i++) {  //下凸壳\n        while (top > 1 &&\n               (vec[stk[top]] - vec[stk[top - 1]]) * (vec[i] - vec[stk[top]]) <=\n                   EPS)\n            used[stk[top--]] = false;\n        used[i] = true, stk[++top] = i;\n    }\n    long double tmp = top;\n    for (int i = cnt - 1; i > 0; i--) {  //上凸壳\n        if (!used[i]) {\n            while (top > tmp && (vec[stk[top]] - vec[stk[top - 1]]) *\n                                        (vec[i] - vec[stk[top]]) <=\n                                    EPS)\n                used[stk[top--]] = false;\n            used[i] = true, stk[++top] = i;\n        }\n    }\n}\n\ninline void rotatingCalipers(long double res = 1e18) { //旋转卡壳\n    convex();\n    int up = 1, left = 3, right = 1;\n    for (int i = 1; i < top; i++) {\n        auto s = vec[stk[i]], t = vec[stk[i + 1]];\n        while (true) {  //寻找对踵点 two polong doubleers\n            auto x1 = vec[stk[up]], x2 = vec[stk[up + 1]];\n            long double s1 = abs((s - x1) * (t - x1));\n            long double s2 = abs((s - x2) * (t - x2));\n            if (s1 < s2 + EPS) up = up % (top - 1) + 1;  // h1 <= h2\n            else break;\n        }\n        while (true) {  //右边最远的点\n            auto x1 = vec[stk[right]], x2 = vec[stk[right + 1]];\n            long double s1 = dot(x1 - s, t - s);\n            long double s2 = dot(x2 - s, t - s);\n            if (s1 < s2 + EPS) right = right % (top - 1) + 1;  // r1 <= r2\n            else break;\n        }\n        while (true) {  //左边最远的点\n            auto x1 = vec[stk[left]], x2 = vec[stk[left + 1]];\n            long double s1 = dot(x1 - s, t - s);\n            long double s2 = dot(x2 - s, t - s);\n            if (s1 > EPS) left = left % (top - 1) + 1;\n            else if (s2 < s1 + EPS) left = left % (top - 1) + 1;  // l2 <= l1\n            else break;\n        }\n        long double theta = atan2(t.y - s.y, t.x - s.x);\n        auto p1 = intersect(\n            s, t, vec[stk[left]],\n            vec[stk[left]] + Vec2(cos(theta + PI / 2), sin(theta + PI / 2)));\n        auto p2 = intersect(\n            s, t, vec[stk[right]],\n            vec[stk[right]] + Vec2(cos(theta + PI / 2), sin(theta + PI / 2)));\n        auto p3 = intersect(\n            vec[stk[up]], vec[stk[up]] + Vec2(cos(theta), sin(theta)),\n            vec[stk[right]],\n            vec[stk[right]] + Vec2(cos(theta + PI / 2), sin(theta + PI / 2)));\n        auto p4 = intersect(\n            vec[stk[up]], vec[stk[up]] + Vec2(cos(theta), sin(theta)),\n            vec[stk[left]],\n            vec[stk[left]] + Vec2(cos(theta + PI / 2), sin(theta + PI / 2)));\n        long double area = (p3 - p2) * (p1 - p2);\n        if (area < res - EPS) { // area < res\n            res = area;\n            ans[0] = p1, ans[1] = p2, ans[2] = p3, ans[3] = p4;\n        }\n    }\n    cout << res << endl;\n}\n\ninline void print() {\n    int st;\n    long double minY = 1e18, minX = 1e18;\n    for (int i = 0; i < 4; i++) {\n        if (ans[i].y < minY - EPS) {\n            st = i, minY = ans[i].y, minX = ans[i].y;\n        } else if (abs(ans[i].y - minY) < EPS) { //相等\n            if (ans[i].x < minX - EPS) { //选x小的\n                st = i, minY = ans[i].y, minX = ans[i].x;\n            }\n        }\n    }\n    for (int i = 0; i < 4; i++) {\n        double x = ans[(st + i) % 4].x, y = ans[(st + i) % 4].y;\n        if (abs(x) < EPS) x = .0;\n        if (abs(y) < EPS) y = .0;\n        cout << x << \" \" << y << endl;\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << setprecision(5) << fixed;\n    cin >> cnt;\n    for (int i = 1; i <= cnt; i++) cin >> vec[i].x >> vec[i].y;\n    rotatingCalipers(); //旋转卡壳求出矩形\n    print(); //输出\n    return 0;\n}\n```\n\n## C UVA10173 Smallest Bounding Rectangle\n### Description\n[题目链接](https://www.luogu.com.cn/problem/UVA10173)\n多组数据求最小矩形覆盖的面积。\n### Solution\n与 B HNOI2007 最小矩形覆盖做法相同，只需输出面积。\n注意多组数据 $used$ 数组清零。\n### Code\n```cpp UVA10173 Smallest Bounding Rectangle\n#include <bits/stdc++.h>\n#define PI acos(-1)\n\nusing namespace std;\n\nconstexpr int MAXN = 2e5 + 5;\nconstexpr long double EPS = 1e-11;\n\nstruct Vec2 {\n    Vec2() = default;\n    Vec2(long double _x, long double _y) : x(_x), y(_y) {}\n\n    friend inline bool operator<(const Vec2& a, const Vec2& b) {\n        return a.x == b.x ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline Vec2 operator+(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x + b.x, a.y + b.y);\n    }\n    /*@return cross product of two Vec2*/\n    friend inline long double operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;  //×\n    }\n    /*@return 向量与数乘后的向量*/\n    friend inline Vec2 operator*(const Vec2& a, long double num) {\n        return Vec2(a.x * num, a.y * num);\n    }\n    /*@param a 2D vector @return norm of the vector*/\n    friend inline long double norm(const Vec2& a) {\n        return sqrt(a.x * a.x + a.y * a.y);\n    }\n    /*@param a 2D vector @return square norm of the vector*/\n    friend inline long double normSquare(const Vec2& a) {\n        return a.x * a.x + a.y * a.y;\n    }\n    /*@return dot product of two vectors*/\n    friend inline long double dot(const Vec2& a, const Vec2& b) {\n        return a.x * b.x + a.y * b.y;\n    }\n    long double x = 0, y = 0;\n} vec[MAXN];\n\n/*@return intersect point of two Seg*/\ninline Vec2 intersect(const Vec2& s1, const Vec2& t1, const Vec2& s2,\n                      const Vec2& t2) {\n    long double ratio = ((s1 - s2) * (t2 - s2)) / ((t2 - s2) * (t1 - s1));\n    return s1 + (t1 - s1) * ratio;\n}\n\nint cnt;\nint stk[MAXN], used[MAXN], top;\n\ninline void convex() {  //求凸包\n    sort(vec + 1, vec + cnt + 1);\n    top = 0, stk[++top] = 1;\n    memset(used, 0, sizeof(used));\n    for (int i = 2; i <= cnt; i++) {  //下凸壳\n        while (top > 1 &&\n               (vec[stk[top]] - vec[stk[top - 1]]) * (vec[i] - vec[stk[top]]) < EPS)\n            used[stk[top--]] = false;\n        used[i] = true, stk[++top] = i;\n    }\n    long double tmp = top;\n    for (int i = cnt - 1; i > 0; i--) {  //上凸壳\n        if (!used[i]) {\n            while (top > tmp && (vec[stk[top]] - vec[stk[top - 1]]) *\n                                        (vec[i] - vec[stk[top]]) < EPS)\n                used[stk[top--]] = false;\n            used[i] = true, stk[++top] = i;\n        }\n    }\n}\n\ninline void rotatingCalipers(long double res = 1e18) { //旋转卡壳\n    convex();\n    int up = 2, left = 2, right = 1;\n    if (top <= 3) { cout << .0 << endl; return; }\n    for (int i = 1; i < top; i++) {\n        auto s = vec[stk[i]], t = vec[stk[i + 1]];\n        while (true) {  //寻找对踵点 two polong doubleers\n            auto x1 = vec[stk[up]], x2 = vec[stk[up + 1]];\n            long double s1 = abs((s - x1) * (t - x1));\n            long double s2 = abs((s - x2) * (t - x2));\n            if (s1 < s2 + EPS) up = up % (top - 1) + 1;  // h1 <= h2\n            else break;\n        }\n        while (true) {  //右边最远的点\n            auto x1 = vec[stk[right]], x2 = vec[stk[right + 1]];\n            long double s1 = dot(x1 - s, t - s);\n            long double s2 = dot(x2 - s, t - s);\n            if (s1 < s2 + EPS) right = right % (top - 1) + 1;  // r1 <= r2\n            else break;\n        }\n        while (true) {  //左边最远的点\n            auto x1 = vec[stk[left]], x2 = vec[stk[left + 1]];\n            long double s1 = dot(x1 - s, t - s);\n            long double s2 = dot(x2 - s, t - s);\n            if (s1 > EPS) left = left % (top - 1) + 1;\n            else if (s2 < s1 + EPS) left = left % (top - 1) + 1;  // l2 <= l1\n            else break;\n        }\n        long double theta = atan2(t.y - s.y, t.x - s.x);\n        auto p1 = intersect( //直线相交求顶点\n            s, t, vec[stk[left]],\n            vec[stk[left]] + Vec2(cos(theta + PI / 2), sin(theta + PI / 2)));\n        auto p2 = intersect( //直线相交求顶点\n            s, t, vec[stk[right]],\n            vec[stk[right]] + Vec2(cos(theta + PI / 2), sin(theta + PI / 2)));\n        auto p3 = intersect( //直线相交求顶点\n            vec[stk[up]], vec[stk[up]] + Vec2(cos(theta), sin(theta)),\n            vec[stk[right]],\n            vec[stk[right]] + Vec2(cos(theta + PI / 2), sin(theta + PI / 2)));\n        auto p4 = intersect( //直线相交求顶点\n            vec[stk[up]], vec[stk[up]] + Vec2(cos(theta), sin(theta)),\n            vec[stk[left]],\n            vec[stk[left]] + Vec2(cos(theta + PI / 2), sin(theta + PI / 2)));\n        long double area = (p3 - p2) * (p1 - p2);\n        res = min(res, area);\n    }\n    cout << res << endl;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cout << setprecision(4) << fixed;\n    while (cin >> cnt && cnt) {\n        for (int i = 1; i <= cnt; i++) cin >> vec[i].x >> vec[i].y;\n        rotatingCalipers(); //旋转卡壳求出矩形\n    }\n    return 0;\n}\n```","tags":["旋转卡壳"],"categories":["计算几何","旋转卡壳","凸包"]},{"title":"AtCoder Beginner Contest 174","url":"/2020/08/04/atcoder-abc-174/","content":"[比赛链接](https://atcoder.jp/contests/abc174)\n<!-- more -->\n# C Repsept\n## Description\n求 $7，77，777，7777，$ 中的第几个数是给定的 $K$ 的倍数 ($K \\le\\ 10^6$)，没有则输出 $-1$。\n## Solution\n- 设 $f(n)$ 为数列中第 n 个数的值，则有 $f(n) = 10 * f(n - 1) + 7$，两边同除以 $10^n$，求通项可得:\n    $$f(n) = 7 * (10^n - 1) / 9$$\n- 问题转化为求 $f(n) \\%\\ K = 0$ 所对应的 $n$\n- 可以发现，$K$ 是 2 或 5 的倍数时无解。有解时，一定有 $n < K$\n- 故可枚举 $n$，使用 $mod = K$ 的快速幂判断即可\n\n## Code Repsept\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nint k;\n\nint qpow(int a, int b, int modd) {\n    int ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % modd;\n        b >>= 1, base = base * base % modd;\n    }\n    return ans;\n}\n\ninline void work() {\n    cin >> k;\n    for (int i = 1; i <= 2e6; i++) {\n        if ((7 * (qpow(10, i, 9 * k) - 1) % (9 * k) + (9 * k)) % (9 * k) == 0) {\n            cout << i;\n            exit(0);\n        }\n    }\n    cout << -1 << endl;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    work();\n    return 0;\n}\n```\n# D Alter Altar\n## Description\n[题目链接](https://atcoder.jp/contests/abc174/tasks/abc174_d)\n## Solution\n应该使所有的 $W$ 在 $R$ 右侧。那么从头开始扫，如果遇到 $W$ 就将其与最右端的 $R$ 交换即可(用双指针维护)。\n## Code\n```cpp Alter Altar\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxn = 200005;\nint n, ans;\nchar c[maxn];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> c[i];\n    int i = 1, r = n;\n    for (; i <= n; i++) {\n        while (c[r] == 'W' && r > i) r--;\n        if (c[i] == 'W' && i < r && c[r] == 'R') {\n            swap(c[i], c[r]);\n            ans++;\n        }\n    }\n    cout << ans;\n    return 0;\n}\n```\n# E Logs\n## Description\n有 $N$ 个木头，现需要将这些木头砍 $K$ 次(设选取的木头长度为L，则砍了之后得到长度为 $t$ ($0 < t < L$), $L - t$ 的木头，砍了之后的木头还能继续砍)，求 $K$ 次操作后这些木头中最大长度的最小值(向上取整)。\n## Solution\n二分木头最大长度的最小值 $mid$，并 $check$ 把所有木头分为长度 $l \\le\\ mid$ 的木头所需要的次数，与 $k$ 比较即可。\n注意木头的最小长度应取 1 而不是 0。\n## Code\n```cpp Logs\n#include <bits/stdc++.h>\n#define int long long\n\nusing namespace std;\n\nconstexpr int MAXN = 3e5 + 5;\n\narray<int, MAXN> a;\n\nint n, k;\n\ninline bool check(int mid) {\n    int cnt(0);\n    for (int i = 1; i <= n; i++) {\n        if (a[i] % mid == 0) cnt += a[i] / mid - 1;\n        else cnt += a[i] / mid;\n    }\n    return cnt <= k; //\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    int l = 1, r = 2e9, ans = 0;\n    while (l <= r) {\n        int mid = (l + r) >> 1;\n        if (check(mid)) {\n            ans = mid, r = mid - 1;\n        } else l = mid + 1;\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n# F Range Set Query\n## Description\n给定一个序列，多次询问区间 $[l_i, r_i]$ 不同数字的个数。\n## Solution\n- 记录 $a_i$ 前一次出现的位置 $pre[a_i]$(若 $a_i$ 第一次出现则为 0)\n- 对于区间 $[l, r]$，如果区间的一个数 $per[a_i] \\le l$，则该数在区间内第一次出现，可计入答案\n- 于是以下标为值域，建立可持久化至于线段树。每个版本在 $pre[a_i]$ 位置权值加 1，最后统计 $[0, l_i - 1]$ 的权值总和即可\n\n## Code\n```cpp Range Set Query\n#include <bits/stdc++.h>\n\nconstexpr int MAXN = 5e5 + 5;\nconstexpr int MAXA = 5e5 + 6;\nconstexpr int LOG = 30;\nusing namespace std;\n\ninline int read() {\n    int x = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();\n    while (isdigit(ch)) x = (x << 3) + (x << 1) + ch - 48, ch = getchar();\n    return x * f;\n}\n\nstruct Node {\n    Node *lson, *rson;\n    int cnt;\n} Tree[MAXN * LOG], *root[MAXN];\nint tot, n, m, cnt, arr[MAXN], pre[MAXA], last[MAXN];\n\ninline Node *newNode(Node *&root) { return root = &Tree[tot++]; }\n\ninline void build(int L, int R, Node *root) {\n    if (L == R) return;\n    int mid = (L + R) >> 1;\n    build(L, mid, newNode(root->lson)), build(mid + 1, R, newNode(root->rson));\n}\n\ninline void modify(Node *pre, Node *cur, int L, int R, int pos) {\n    cur->cnt = pre->cnt;\n    if (L == R) {\n        cur->cnt++;\n        return;\n    }\n    int mid = (L + R) >> 1;\n    if (pos <= mid)\n        cur->rson = pre->rson,\n        modify(pre->lson, newNode(cur->lson), L, mid, pos);\n    else\n        cur->lson = pre->lson,\n        modify(pre->rson, newNode(cur->rson), mid + 1, R, pos);\n    cur->cnt = cur->lson->cnt + cur->rson->cnt;\n}\n\ninline int query2(Node *pre, Node *cur, int L, int R, int qL, int qR) {\n    if (qL == L && R == qR) return cur->cnt - pre->cnt;\n    int mid = (L + R) >> 1;\n    if (qR <= mid)\n        return query2(pre->lson, cur->lson, L, mid, qL, qR);\n    else if (qL > mid)\n        return query2(pre->rson, cur->rson, mid + 1, R, qL, qR);\n    else\n        return query2(pre->lson, cur->lson, L, mid, qL, mid) +\n               query2(pre->rson, cur->rson, mid + 1, R, mid + 1, qR);\n}\n\nint main() {\n    n = read(), m = read();\n    build(0, n, newNode(root[0]));\n    for (int i = 1; i <= n; i++) {\n        arr[i] = read(), last[i] = pre[arr[i]], pre[arr[i]] = i;\n        modify(root[i - 1], newNode(root[i]), 0, n, last[i]);\n    }\n    while (m--) {\n        int l = read(), r = read();\n        printf(\"%d\\n\", query2(root[l - 1], root[r], 0, n, 0, l - 1));\n    }\n    return 0;\n}\n\n```","tags":["contest"],"categories":["contest"]},{"title":"P4178 Tree","url":"/2020/07/29/tree/","content":"# Tree\n  - [题目链接](https://www.luogu.com.cn/problem/P4178)\n  - 数据结构/点分治\n<!-- more -->\n# Description\n求树上长度不超过 $k$ 的路径数。\n# Solution\n若节点 $root$ 为根，则对 $root$ 而言，树上路径可分为2类\n- 经过根节点 $root$。(分为 $x->root$, $root->y$)\n- 包含于 root 的某一棵子树中。(不经过根节点 $root$)\n\n对于当前节点 $root$，dfs 求出子树节点到其的距离 $dis_{node}$。\n```cpp\ninline void getDis(int cur, int fa) { //求出到根root的距离\n    vec.emplace_back(dis[cur]);\n    for (auto &e : G[cur]) {\n        int to = e.first, w = e.second;\n        if (to == fa || vis[to]) continue;\n        dis[to] = dis[cur] + w;\n        getDis(to, cur);\n    }\n}\n```\n将 $dis[]$ 数组升序排序，使用两个指针 $l, r$ 从前、后开始扫描数组。\n\n容易发现，在 l 从左到右扫描的过程中，恰好使得 $dis[l] + dis[r] \\le\\ k$ 的 r 是从右向左递减的，于是符合条件的点对有 $r - l$ 对。\n```cpp\ninline void calc(int cur, int w, int type) { //cur为有根树的根节点(重心) type为1表示加\n    dis[cur] = w, vec.clear(), getDis(cur, 0);\n    sort(vec.begin(), vec.end());\n    int l = 0, r = (int)vec.size() - 1;\n    while (l <= r) {\n        if (vec[l] + vec[r] <= k) res += type * (r - l), ++l;\n        else --r;\n    }\n}\n```\n不过一些点对在 $root$ 的某一棵子树中，且会使 $root$ 与其儿子间的边被经过两次。可以以 $root$ 的儿子节点为根, $dis[son] = w_{root, son}$，再次求 $dis[]$ 并统计, 减去这部分的结果即可 ($son$ 子树满足条件的在 $root$ 中不满足)。\n``calc(to, w, -1); //容斥思想 减去儿子中的路径数 注意dis要加上w``\n\n于是可不断选取 $root$ 并统计：\n1.若递归深度为 T 层，则总时间复杂度 $O(TNlogN)$。\n2.若选取的 $root$ 为子树重心，则 $root$ 的子树大小不会超过原子树大小的一半，点分治最多 $logN$ 层。\n```cpp\ninline void getRoot(int cur, int fa) { //求树的重心 自上而下\n    sz[cur] = 1, dp[cur] = 0;\n    for (auto &e : G[cur]) {\n        int to = e.first, w = e.second;\n        if (to == fa || vis[to]) continue;\n        getRoot(to, cur);\n        sz[cur] += sz[to];\n        dp[cur] = max(dp[cur], sz[to]); //dp[cur]求以cur为根的最大子树大小\n    }\n    dp[cur] = max(dp[cur], tot - sz[cur]);\n    if (dp[cur] < dp[root]) root = cur;\n}\n```\n时间复杂度 $(NlogNlogN)$。\n\n# Code\n```cpp Tree\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 4e4 + 4;\n\ntemplate<typename T> inline void read(T &x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nvector< pair<int, int> > G[MAXN];\nvector<int> vec;\n\nint n, k, tot, root, res;\nint sz[MAXN], dp[MAXN], dis[MAXN], vis[MAXN];\n\ninline void getRoot(int cur, int fa) { //求树的重心 自上而下\n    sz[cur] = 1, dp[cur] = 0;\n    for (auto &e : G[cur]) {\n        int to = e.first, w = e.second;\n        if (to == fa || vis[to]) continue;\n        getRoot(to, cur);\n        sz[cur] += sz[to];\n        dp[cur] = max(dp[cur], sz[to]); //dp[cur]求以cur为根的最大子树大小\n    }\n    dp[cur] = max(dp[cur], tot - sz[cur]);\n    if (dp[cur] < dp[root]) root = cur;\n}\n\ninline void getDis(int cur, int fa) { //求出到根root的距离\n    vec.emplace_back(dis[cur]);\n    for (auto &e : G[cur]) {\n        int to = e.first, w = e.second;\n        if (to == fa || vis[to]) continue;\n        dis[to] = dis[cur] + w;\n        getDis(to, cur);\n    }\n}\n\ninline void calc(int cur, int w, int type) { //cur为有根树的根节点(重心) type为1表示加\n    dis[cur] = w, vec.clear(), getDis(cur, 0);\n    sort(vec.begin(), vec.end());\n    int l = 0, r = (int)vec.size() - 1;\n    while (l <= r) {\n        if (vec[l] + vec[r] <= k) res += type * (r - l), ++l;\n        else --r;\n    }\n}\n\ninline void dfs(int cur) {\n    vis[cur] = true, calc(root, 0, 1);\n    for (auto &e : G[cur]) {\n        int to = e.first, w = e.second;\n        if (vis[to]) continue;\n        calc(to, w, -1); //容斥思想 减去儿子中的路径数 注意要加上w\n        root = cur, tot = dp[root] = sz[to]; //准备重新选择根节点\n        getRoot(to, root), dfs(root);\n    }\n}\n\nint main() {\n    read(n);\n    for (int i = 1, u, v, w; i < n; i++) {\n        read(u), read(v), read(w);\n        G[u].emplace_back(make_pair(v, w)), G[v].emplace_back(make_pair(u, w));\n    }\n    read(k);\n    root = 0, tot = dp[root] = n;\n    getRoot(1, root), dfs(root);\n    cout << res << endl;\n    return 0;\n}\n```","tags":["点分治"],"categories":["数据结构","点分治"]},{"title":"AtCoder Beginner Contest 172","url":"/2020/07/29/atcoder-abc-172/","content":"[比赛链接](https://atcoder.jp/contests/abc172)\n<!-- more -->\n# C Tsundoku\n[题目链接](https://atcoder.jp/contests/abc172/tasks/abc172_c)\n\n## Solution\n不论如何选取，选取的一定是 A 与 B 数组从头开始的一段。先预处理出前缀和，然后枚举在 A 数组中选取的位置 $i$，其前缀和为 $sumA_i$, 接下来找到 B 数组中前缀和不超过 $k-sumA_i$ 的最后一个位置 $j$，那么此时能选取书的总数为 $i+j$。答案即为所有 $i+j$ 的最大值\n## Code\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 200005;\nll sumA[maxn], sumB[maxn];\nint ans,n, m, k, x;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n >> m >> k;\n    for (int i = 1; i <= n; i++) cin >> x, sumA[i] = sumA[i - 1] + x;\n    for (int i = 1; i <= m; i++) cin >> x, sumB[i] = sumB[i - 1] + x;\n    for (int i = 0; i <= n && sumA[i] <= k; i++) {\n        int rem = k - sumA[i];\n        int Index = upper_bound(sumB, sumB + m + 1, rem) - sumB;\n        ans = max(ans, i + Index - 1);\n    }\n    cout << ans;\n    return 0;\n}\n```\n# D Sum of Divisors\n[题目链接](https://atcoder.jp/contests/abc172/tasks/abc172_d)\n\n## Solution\n根据题意，求解过程可以用如下伪代码表示：\n```cpp\nans = 0\nfor i = 1, ..., N:\n    for j = 1, ..., N:\n\tif i % j == 0 then ans += i\nprint ans\n```\n由于所有二元组都被枚举到，所以两层循环可交换顺序：\n\n```cpp\nans = 0\nfor j = 1, ..., N:\n    for i = 1, ..., N:\n        if i % j == 0 then ans += i\nprint ans\n```\n令 $g(j)$ 表示 $j$ 的所有不超过 $N$ 的倍数的和，那么答案可以表示为 $\\sum\\limits_{j=1}^Ng(j)$。\n对于任意 $X(1<=X<=N)$，令 $Y$ =  $\\lfloor N/X \\rfloor$，那么 $g(X)$ = $X+2X+...YX$ = $(1+Y)YX/2$。这样在 $O(N)$ 时间内即可求得答案。\n## Code\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef unsigned long long ll;\nll n, ans;\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        ll j = n / i;\n        ans += i * j * (j + 1) / 2;\n    }\n    cout << ans;\n    return 0;\n}\n```\n\n# E NEQ\n[题目链接](https://atcoder.jp/contests/abc172/tasks/abc172_e)\n\n## Solution\n先不考虑 $\\forall i \\in[1,N], A_i \\neq B_i$ 这一条件，那么总共的方案数为 $(A_M^N)^2$。\n\n接下来只需要去除使 $A,B$ 数组中某几位相同的方案。设 $P_i$ 表示事件: $A_i = B_i$。那么不合法的方案构成的集合为 $P_1\\cup P_2 \\cup ...\\cup P_n$。由容斥原理有 $|P_1\\cup P_2 \\cup ...\\cup P_n|=\\sum\\limits_{1<=i<=n}|P_i|-\\sum\\limits_{1<=i<j<=n}|P_i\\cap P_j|$\n$+\\sum\\limits_{1<=i<j<k<=n}|P_i\\cap P_j\\cap P_k|-...+(-1)^{n-1}|P_1\\cap P_2 \\cap ...\\cap P_n|$。\n\n设一下标集合 $S$，集合大小为 $|S|$，则它对应的满足 $\\forall i \\in S, A_i = B_i$的 $A,B$数组 有$A_M^{|S|}(A_{M-|S|}^{N-|S|})^2$ 对 ($|S|$位相同对应$A_M^{|S|}$，剩下$N-|S|$位从剩下$M-|S|$个数中任取)。\n根据容斥原理,这一集合对不合法方案的贡献为 $(-1)^{|S|-1}A_M^{|S|}(A_{M-|S|}^{N-|S|})^2$。显然，这样的集合有$C_N^{|S|}$个。于是所有大小为 $|S|$ 的集合的贡献为\n  $C_N^{|S|}(-1)^{|S|-1}A_M^{|S|}(A_{M-|S|}^{N-|S|})^2$。将所有大小的集合的贡献累加即可得到不合法的方案数, 把它从总的方案数中减去即可。\n## Code\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nconst int maxn = 5e5 + 5;\nint n, m;\nll inv[maxn], fac[maxn], ans;\n\nll qpow(ll a, ll b) {\n    ll ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nvoid init() {\n    fac[0] = 1;\n    for (int i = 1; i <= m; i++) fac[i] = fac[i - 1] * i % MOD;\n    for (int i = 0; i <= m; i++) inv[i] = qpow(fac[i], MOD - 2);\n}\n\nll A(ll a, ll b) { return fac[a] * inv[a - b] % MOD; }\n\nll C(ll a, ll b) { return fac[a] * inv[b] % MOD * inv[a - b] % MOD; }\n\nint main() {\n    cin >> n >> m;\n    init();\n    ans = qpow(A(m, n), 2);\n    for (int s = 1; s <= n; s++) {\n        ans -= (s & 1 ? 1 : -1) * C(n, s) * A(m, s) % MOD *\n               qpow(A(m - s, n - s), 2) % MOD;\n        ans %= MOD;\n    }\n    cout << (ans + MOD) % MOD;\n    return 0;\n}\n```\n\n# F Unfair Nim\n[题目链接](https://atcoder.jp/contests/abc172/tasks/abc172_f)\n\n## Solution\n要做本题首先要直到这个结论：后出手的人有必胜策略当且仅当 $A_1⊕A_2⊕...⊕A_N=0$\n\n设从第一堆移动石子数为 $x(0<=x<A_1)$，令 $a=A_1-x,b=A_2+x$，其中$1<=a<=A_1$，那么有 $a+b=A_1+A_2 =S,a⊕b=A_3⊕A_4⊕...⊕A_N=X$。题目要求最小的 $x$，即求最大的 $a$，使前面两个式子成立。\n\n由于 $a+b=a⊕b+2*(a\\&b)$ ($a⊕b$ 可视为不进位的加法，加上 $(a \\& b)<<1$ 即将进位加上)，可以得出 $(a\\&b)=(S-X)/2=D$。如果 $S-X$ 不是偶数，$D$ 小于0，或者 $D$ 与 $X$ 在二进制下某一位同为 1 ($a\\&b$ 在某一位为 1 仅当 $a,b$ 在这一位同为 1，而此时$a⊕b$ 在这一位的结果应为 0)，本题无解。\n\n将 $X$ 在二进制下拆分成两个数 $Y,Z$，满足$Y\\&Z=0,Y⊕Z=X$,即 $X$ 某一位为 1 时，$Y,Z$ 在这一位不同时为1。可以解出 $a=D⊕Y,b=D⊕Z$,可以证明无其它形式的解。根据前面的结论，$D$ 与 $Y$ 不存在某一位同为 1 的情况，所以 $D⊕Y\\ge D$，因此 $a$ 的最小值为 $D$。如果 $D > A_1$ 则本题无解。接下来从高位到低位考察 $X$ 二进制下的每一位，如果这一位为 1，尝试将这一位加到 $a$ 中，看得到的结果是否大于 $A_1$, 如果大于则不能加上这一位。最后，若 $a=0$，即$x=A_1$，本题无解。否则，输出 $A_1-a$ 即为移动石子的最小数量。\n## Code\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nint N;\nll A1, A2, A, ans, X;\n\nbool check(ll a, ll b) {\n    for (int i = 41; ~i; i--) {\n        int ai = (a >> i) & 1;\n        int bi = (b >> i) & 1;\n        if (ai == 1 && bi == 1) return false;\n    }\n    return true;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> N;\n    cin >> A1 >> A2;\n    ll S = A1 + A2;\n    for (int i = 3; i <= N; i++) cin >> A, X ^= A;\n    ll D = (S - X) >> 1;\n    if (((S - X) & 1) || D < 0 || D > A1 || !check(D, X)) cout << -1, exit(0);\n    ans = D;\n    for (int i = 41; ~i; i--) {\n        bool Xi = (X >> i) & 1;\n        if (Xi && ((ans | (1ll << i)) <= A1)) ans |= 1ll << i;\n    }\n    cout << (ans ? A1 - ans : -1);\n    return 0;\n}\n```\n","tags":["contest"],"categories":["contest"]},{"title":"CF1342E Placing Rooks","url":"/2020/07/28/Placing-Rooks/","content":"[题目链接](https://www.luogu.com.cn/problem/CF1342E)\n<!-- more -->\n# Solution\n要满足每个格子都能被共击，那么就要使每一行都有车，或者每一列都有车。以每一行都有车为例，设有 $j$ 列放了车。由于每多一列，能相互共击的车的对数就会减 1，因此放 $j$ 列车就有 $n-j$ 对车能相互共击。题目要求 $k$ 对车能相互共击，那么只能在 $n-k$ 列放置车 (显然 $k\\geqslant\\ n$时答案为 0)。从 $n$ 列选取 $n-k$ 列的方案数为 $C_n^{n-k}$。接下来考虑在 $n-k$ 列中放入 $n$ 个车，每列不空的方案数。\n\n令 $P_i$ 表示事件: 在这 $n-k$ 列中第 $i$ 列没有放车。由容斥原理有 $|\\overline{P_1} \\cap \\overline{P_2} \\cap ...\\cap \\overline{P_{n-k}}|= N-\\sum\\limits_{1<=i<={n-k}}|P_i|+\\sum\\limits_{1<=i<j<={n-k}}|P_i\\cap P_j|$ $-\\sum\\limits_{1<=i<j<q<={n-k}}|P_i\\cap P_j\\cap P_q|+...+(-1)^{n-k}|P_1\\cap P_2 \\cap ...\\cap P_{n-k}|$。\n\n设一**列下标集合** $S$，大小为$|S|(|S|<=n-k)$，这样的集合有$C_{n-k}^{|S|}$个。则满足 $\\forall i \\in S$，第 $i$ 列没有放车的方案数为 $(n-k-|S|)^n$，即 $n$ 个车放在剩下 $n-k-|S|$ 列的任意一个中的方案数。根据前面的公式，容易得出每一行都有车且满足题目条件的方案数为 $C_n^{n-k}\\sum\\limits_{i=0}^{n-k}(-1)^iC_{n-k}^{i}(n-k-i)^n$。如果 $k$ 不等于 0，则每一行都有车和每一列都有车不等价，总的答案应该乘以 2，即 $2C_n^{n-k}\\sum\\limits_{i=0}^{n-k}(-1)^iC_{n-k}^{i}(n-k-i)^n$。\n\n# Code\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 998244353;\nconst int maxn = 2e5 + 5;\nll n, k, inv[maxn], fac[maxn], ans;\n\nll qpow(ll a, ll b) {\n    ll ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nvoid init() {\n    fac[0] = 1;\n    for (int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % MOD;\n    for (int i = 0; i <= n; i++) inv[i] = qpow(fac[i], MOD - 2);\n}\n\nll C(ll a, ll b) { return fac[a] * inv[b] % MOD * inv[a - b] % MOD; }\n\nint main() {\n    cin >> n >> k;\n    if (k >= n) cout << 0, exit(0);\n    init();\n    for (int s = 0; s <= n - k; s++) {\n        ans += (s & 1 ? -1 : 1) * C(n - k, s) * qpow(n - k - s, n) % MOD;\n        ans %= MOD;\n    }\n    ans = ans * (!k ? 1 : 2) * C(n, n - k) % MOD;\n    cout << (ans + MOD) % MOD;\n    return 0;\n}\n```","tags":["组合计数","容斥原理"],"categories":["数论","组合数学","容斥原理"]},{"title":"字典树笔记","url":"/2020/07/19/trie/","content":"# \n<!-- more -->\nTrie，即字典树，是一个非常强大的数据结构，可以高效处理字符串、异或最大值以及数集维护问题，而且常数非常小。\n\n下面的题可用用 Trie 树实现，主要分为4个等级。\n\n# Level 1\nTrie 树基础\n## A 于是他错误的点名开始了\n### Description\n[P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)\n### Solution\n首先把给出的 $n$ 个字符串插入 $trie$ 树中。之后询问时，如果给出的字符串在 $trie$ 树中不存在，否则在字符串末尾对应节点打上标记，如果这个点之前已经被打过标记，说明这个字符串在之前已经被询问过了。\n### Code\n```cpp 于是他错误的点名开始了\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct trie {\n    trie *son[26];\n    trie() {\n        for (int i = 0; i < 26; i++) son[i] = NULL;\n        tag = 0;\n    }\n    bool tag;\n};\n\ntrie *root = new trie;\nint n, m;\nstring s;\n\nvoid insert(const string &s) {\n    trie *cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        int temp = s[i] - 'a';\n        if (cur->son[temp] == NULL) cur->son[temp] = new trie;\n        cur = cur->son[temp];\n    }\n}\n\nint search(const string &s) {\n    trie *cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        int temp = s[i] - 'a';\n        if (cur->son[temp] == NULL) return 0;\n        cur = cur->son[temp];\n        if (i == s.size() - 1) {\n            if (!cur->tag)\n                return cur->tag = 1, 1;\n            else\n                return 2;\n        }\n    }\n}\n\nint main() {\n    cin >> n;\n    while (n--) cin >> s, insert(s);\n    cin >> m;\n    while (m--) {\n        cin >> s;\n        int now = search(s);\n        if (now == 0)\n            cout << \"WRONG\" << endl;\n        else if (now == 1)\n            cout << \"OK\" << endl;\n        else\n            cout << \"REPEAT\" << endl;\n    }\n    return 0;\n}\n```\n## B PHONELST Phone List\n### Description\n[SP4033 PHONELST - Phone List](https://www.luogu.com.cn/problem/SP4033)\n### Solution\n考虑两种情况，若当前串是前面已插入的串中某一个串的前缀，那么它在 $ trie$ 上对应的最后一个节点之前应该被访问过；若前面已插入的串中存在当前串的前缀，那么在插入当前串时，一定会访问到 $trie$ 上的某个节点，且该节点对应之前某个串的结尾。因此只需要打两个标记，一个记录节点是否被访问过，一个记录节点是否对应某个串的结尾，这两个标记边插入边更新即可。\n### Code\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct trie {\n    trie *son[10];\n    trie() {\n        for (int i = 0; i < 10; i++) son[i] = NULL;\n        visTag = isEnd = 0;\n    }\n    bool visTag, isEnd;\n} * root;\n\nint n, T;\nbool ans;\nstring s;\n\nvoid insert(const string &s) {\n    trie *cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        int temp = s[i] - '0';\n        if (cur->son[temp] == NULL) cur->son[temp] = new trie;\n        cur = cur->son[temp];\n        if (cur->isEnd) {\n            ans = 0;\n            break;\n        }\n        if (i == s.size() - 1) {\n            cur->isEnd = 1;\n            if (cur->visTag) ans = 0;\n        }\n        cur->visTag = 1;\n    }\n}\n\nvoid trie_delete(trie *cur) {\n    for (int i = 0; i < 10; i++)\n        if (cur->son[i]) trie_delete(cur->son[i]);\n    delete cur;\n}\n\nint main() {\n    cin >> T;\n    while (T--) {\n        root = new trie;\n        ans = 1;\n        cin >> n;\n        for (int i = 1; i <= n; i++) cin >> s, insert(s);\n        puts(ans ? \"YES\" : \"NO\");\n        trie_delete(root);\n    }\n    return 0;\n}\n```\n\n# Level 2\n$01Trie$ 贪心计算最大异或值\n## A Xor Sum\n### Description\n[HDU 4825 - Xor Sum](https://www.luogu.com.cn/problem/U109895)\n### Solution\n首先将集合中的每个数化为二进制形式，分别从高位到低位依次插入 $trie$ 树中。对于任意给定的数，要使异或结果最大，那么异或结果的每一位尽可能是1，也就是说给定的数，和使异或结果最大的数，在每一位的值尽可能相反。每次贪心的选取，在 $trie$ 树上走互补的链即可。单次查询的复杂度为\n$log_2(S)$。\n\n注：用指针版 $trie$ 树直接 $new$ 的话常数较大，会被卡。可以自己手写$newNode$ 函数，或者改用数组版。\n### Code\n```cpp Xor Sum\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int BIT = 32;\n\nstruct trie {\n    int son[2];\n    trie() { son[0] = son[1] = -1; }\n} trie[16000000];\n\nint root = 0;\nint n, m;\n\nll read() {\n    char ch = getchar();\n    ll x = 0, f = 1;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    return x * f;\n}\n\nvoid insert(ll val) {\n    static int tot;\n    int cur = root;\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        if (trie[cur].son[now] == -1) trie[cur].son[now] = ++tot;\n        cur = trie[cur].son[now];\n    }\n}\n\nvoid query(ll val) {\n    int cur = root;\n    ll ans = 0;\n    for (int i = BIT; ~i; i--) {\n        ll now = (val >> i) & 1;\n        if (trie[cur].son[now ^ 1] != -1)\n            ans |= (now ^ 1) << i, cur = trie[cur].son[now ^ 1];\n        else\n            ans |= now << i, cur = trie[cur].son[now];\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    n = read(), m = read();\n    for (int i = 1; i <= n; i++) insert(read());\n    for (int i = 1; i <= m; i++) query(read());\n    return 0;\n}\n```\n## B Chip Factory\n### Description\n[HDU 5536 - Chip Factory](https://www.luogu.com.cn/problem/U109897)\n### Solution\n做法和上一道类似。先把给出的 $n$ 个数插入 $trie$ 树，然后枚举 $i$ 和 $j$，把 $s[i] + s[j]$ 放到 $trie$ 树上贪心地查询即可,单次查询复杂度为 $log_2(s)$。需要注意的是，题目要求 $i,j,k$ 互不相同，因此选了 $s[i],s[j]$ 后，应将它们从 $trie$ 树上删除。具体的，每个节点记一个 $cnt$， 删除的时候让 $cnt-1$ ，查询时如果该节点 $cnt$ 为 0 说明已被删除，则不能选这个节点。单次查询结束后再把  $s[i],s[j]$ 插入 $trie$ 树即可，这样不影响之后的查询。\n### Code\n```cpp Chip Factory\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, a[1001], mx = 0;\nconst int BIT = 31;\n\nstruct trie {\n    int son[2];\n    int cnt;\n    trie() {\n        son[0] = son[1] = -1;\n        cnt = 0;\n    }\n} trie[1001 * (BIT + 1)];\nint root = 0;\n\nint read() {\n    char ch = getchar();\n    int x = 0, f = 1;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    return x * f;\n}\n\nvoid insert(int val) {\n    static int tot;\n    int cur = root;\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        if (trie[cur].son[now] == -1) trie[cur].son[now] = ++tot;\n        cur = trie[cur].son[now];\n        trie[cur].cnt++;\n    }\n}\n\nvoid trie_delete(int val) {\n    int cur = root;\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        cur = trie[cur].son[now];\n        trie[cur].cnt--;\n    }\n}\n\nvoid trie_add(int val) {\n    int cur = root;\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        cur = trie[cur].son[now];\n        trie[cur].cnt++;\n    }\n}\n\nvoid query(int val, int x, int y) {\n    trie_delete(a[x]), trie_delete(a[y]);\n    int cur = root;\n    int ans = 0;\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        if (trie[cur].son[now ^ 1] != -1 && trie[trie[cur].son[now ^ 1]].cnt)\n            ans |= 1 << i, cur = trie[cur].son[now ^ 1];\n        else if (trie[trie[cur].son[now]].cnt)\n            cur = trie[cur].son[now];\n        else\n            return;\n    }\n    trie_add(a[x]), trie_add(a[y]);\n    mx = max(mx, ans);\n}\n\nint main() {\n    n = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    for (int i = 1; i <= n; i++) insert(a[i]);\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++) query(a[i] + a[j], i, j);\n    cout << mx;\n    return 0;\n}\n```\n## C Nikitosh and xor\n### Description\n[Codechef REBXOR - Nikitosh and xor](https://www.luogu.com.cn/problem/U109923)\n### Solution\n记 $preMx[i]$ 表示从 $1$ 到 $i$ 的最大连续片段异或和，$posMx[i]$ 表示从 $i$ 到 $n$ 的最大连续片段异或和。显然，答案为 $\\max\\limits_{0<i<n}(preMx[i]+posMx[i+1])$。接下来只需要预处理出 $preMx[i]$ 和 $posMx[i]$ 即可。\n记 $preXor[i]$ 表示 $1$ 到 $i$ 的前缀异或和。同时设 $preXor[k](0<=k <i)$ 已计算出，并且已被插入 $trie$ 中, 那么根据异或运算的性质，有 $preMx[i]=\\max\\limits_{0<=k<i}(preMx[i-1], preXor[i]⊕preXor[k])$，而$\\max\\limits_{0<=k<i}(preXor[i]⊕preXor[k])$ 可以在 $trie$ 树上，在 $log_2(a)$的时间内贪心地求出。同样的，容易求出 $posMx[i]$。\n### Code\n```cpp Nikitosh and xor\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int BIT = 31;\nconst int maxn = 400005;\nint n, a[maxn], tot;\nll preXor = 0, posXor = 0, preMx[maxn], posMx[maxn];\nll ans = 0;\n\nstruct trie {\n    int son[2];\n    trie() { son[0] = son[1] = -1; }\n} trie[maxn * BIT * 2];\nint root;\n\nint read() {\n    char ch = getchar();\n    int x = 0, f = 1;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    return x * f;\n}\n\nvoid insert(ll val) {\n    int cur = root;\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        if (trie[cur].son[now] == -1) trie[cur].son[now] = ++tot;\n        cur = trie[cur].son[now];\n    }\n}\n\nll query(ll val) {\n    int cur = root;\n    ll ans = 0;\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        if (trie[cur].son[now ^ 1] != -1)\n            ans |= 1ll << i, cur = trie[cur].son[now ^ 1];\n        else\n            cur = trie[cur].son[now];\n    }\n    return ans;\n}\n\nint main() {\n    n = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n\n    insert(0);\n    for (int i = 1; i <= n; i++) {\n        preXor ^= a[i];\n        insert(preXor);\n        preMx[i] = max(preMx[i - 1], query(preXor));\n    }\n    for (int i = 0; i <= tot; i++) trie[i].son[0] = trie[i].son[1] = -1;\n    tot = 0;\n\n    insert(0);\n    for (int i = n; i >= 1; i--) {\n        posXor ^= a[i];\n        insert(posXor);\n        posMx[i] = max(posMx[i + 1], query(posXor));\n    }\n    for (int i = 1; i <= n - 1; i++) ans = max(ans, posMx[i + 1] + preMx[i]);\n    cout << ans;\n    return 0;\n}\n```\n## D 最长异或路径\n### Descritiption\n[P4551 最长异或路径](https://www.luogu.com.cn/problem/P4551)\n### Solution\n首先 $dfs$ 求出每个点 $i$ 到根节点路径上的异或和，记为 Xor[i]。显然，答案为 $\\max\\limits_{1<=u<=n}( \\max\\limits_{1<=v<=n}(Xor[u]⊕Xor[v]))$。对于任意节点 $u$，它和其它节点的最大异或值可以在 $trie$ 树上在 $log_2(w)$ 的时间内贪心地求得。\n\n### Code\n```cpp 最长异或路径\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100005;\nconst int BIT = 30;\n\nint p[maxn], XOR[maxn];\nint n, u, v, w, ans;\nbool vis[maxn];\n\nstruct trie {\n    trie *son[2];\n    int val;\n    trie() { son[0] = son[1] = NULL; }\n} * root;\n\nstruct edge {\n    int nxt, to, val;\n} e[maxn * 2];\n\ntemplate <class T>\nvoid read(T &x, int f = 1) {\n    char ch = getchar();\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nvoid add(int from, int to, int val) {\n    static int t;\n    e[t].to = to, e[t].val = val, e[t].nxt = p[from], p[from] = t++;\n}\n\nvoid dfs(int now, int val) {\n    XOR[now] = val, vis[now] = 1;\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (!vis[to]) dfs(to, val ^ e[i].val);\n    }\n}\n\nvoid insert(int val) {\n    trie *cur = root;\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        if (cur->son[now] == NULL) cur->son[now] = new trie;\n        cur = cur->son[now];\n    }\n}\n\nint query(int val) {\n    trie *cur = root;\n    int ans = 0;\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        if (cur->son[now ^ 1] != NULL)\n            ans |= 1 << i, cur = cur->son[now ^ 1];\n        else\n            cur = cur->son[now];\n    }\n    return ans;\n}\n\nint main() {\n    memset(p, -1, sizeof(p));\n    read(n);\n    for (int i = 1; i <= n - 1; i++) {\n        read(u), read(v), read(w);\n        add(u, v, w), add(v, u, w);\n    }\n    dfs(1, 0);\n    root = new trie;\n    for (int i = 1; i <= n; i++) insert(XOR[i]);\n    for (int i = 1; i <= n; i++) ans = max(ans, query(XOR[i]));\n    cout << ans;\n    return 0;\n}\n```\n\n# Level 3\nTrie 树 应用\n## A USACO08DEC Secret Message G\n### Descritption\n[P2922 USACO08DEC Secret Message G](https://www.luogu.com.cn/problem/P2922)\n\n### Solution\n首先按题意建好 $trie$ 树。对于一个暗号，需要求出有多少条信息是它的前缀，以及它是多少条信息的前缀。用 $cntEnd$ 表示有多少条信息以该节点为结尾，$sum$ 表示该节点对应信息是多少条信息的前缀。每次查询可以求出在最后一位之前该暗号前缀的个数，在最后一个节点通过 $sum$ 可以得到这个暗号是多少条信息的前缀，加起来去个重即可。\n### Code\n```cpp Secret Message G\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint m, n, k;\nbool v;\n\nstruct trie {\n    trie* son[2];\n    int cntEnd, sum;\n    trie() {\n        son[1] = son[0] = NULL;\n        cntEnd = sum = 0;\n    }\n} * root;\n\ntemplate <class T>\nvoid read(T& x, int f = 1) {\n    char ch = getchar();\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nvoid insert(vector<bool>& bin) {\n    trie* cur = root;\n    for (int i = 0; i < bin.size(); i++) {\n        int now = bin[i];\n        if (cur->son[now] == NULL) cur->son[now] = new trie;\n        cur = cur->son[now];\n        cur->sum++;\n    }\n    cur->cntEnd++;\n}\n\nint query(vector<bool>& bin) {\n    trie* cur = root;\n    int ans = 0;\n    for (int i = 0; i < bin.size(); i++) {\n        int now = bin[i];\n        if (cur->son[now] == NULL) return ans;\n        cur = cur->son[now];\n        ans += cur->cntEnd;\n    }\n    ans += cur->sum - cur->cntEnd;\n    return ans;\n}\n\nint main() {\n    read(m), read(n);\n    root = new trie;\n    for (int i = 1; i <= m; i++) {\n        read(k);\n        vector<bool> bin;\n        for (int i = 1; i <= k; i++) read(v), bin.push_back(v);\n        insert(bin);\n    }\n    for (int i = 1; i <= n; i++) {\n        read(k);\n        vector<bool> bin;\n        for (int i = 1; i <= k; i++) read(v), bin.push_back(v);\n        cout << query(bin) << endl;\n    }\n    return 0;\n}\n```\n## B IOI2008 Type Printer 打印机\n### Descritption\n[P4683 IOI2008 Type Printer 打印机](https://www.luogu.com.cn/problem/P4683)\n\n### Solution\n容易发现，所有字符串都要打印，除了最后一个外都要删除。要使按键次数最少，最后打印的字符串必须最长。对最长的字符串在 $trie$ 树上打个标记，$dfs$ 时把有标记的节点放在最后搜索就行了。\n\n### Code\n```cpp Type Printer\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nchar s[21];\nvector<char> ans;\nstruct trie {\n    int son[26];\n    bool isEnd, tag;\n    trie() {\n        for (int i = 0; i < 26; i++) son[i] = -1;\n        isEnd = tag = 0;\n    }\n} trie[25000 * 20];\nint root, tot;\n\nvoid insert(const string& s) {\n    int cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        int now = s[i] - 'a';\n        if (trie[cur].son[now] == -1) trie[cur].son[now] = ++tot;\n        cur = trie[cur].son[now];\n    }\n    trie[cur].isEnd = 1;\n}\n\nvoid addTag(const string& s) {\n    int cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        cur = trie[cur].son[s[i] - 'a'];\n        trie[cur].tag = 1;\n    }\n}\n\nvoid dfs(int now) {\n    int last = -1;\n    for (int i = 0; i < 26; i++) {\n        if (trie[now].son[i] != -1) {\n            if (!trie[trie[now].son[i]].tag) {\n                ans.push_back(i + 'a');\n                if (trie[trie[now].son[i]].isEnd) ans.push_back('P');\n                dfs(trie[now].son[i]);\n                ans.push_back('-');\n            } else\n                last = i;\n        }\n    }\n    if (last != -1) {\n        ans.push_back(last + 'a');\n        if (trie[trie[now].son[last]].isEnd) ans.push_back('P');\n        dfs(trie[now].son[last]);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    int mxLen = 0;\n    string lastString;\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%s\", s);\n        if (strlen(s) > mxLen) mxLen = strlen(s), lastString = s;\n        insert(s);\n    }\n    addTag(lastString);\n    dfs(root);\n    printf(\"%d\\n\", ans.size());\n    for (int i = 0; i < ans.size(); i++) putchar(ans[i]), putchar('\\n');\n    return 0;\n}\n```\n## C USACO12DEC First! G\n### Description\n[P3065 USACO12DEC First! G](https://www.luogu.com.cn/problem/P3065)\n\n### Solution\n首先建出 $trie$ 树，然后枚举每一个字符串，考察它能否排在第一个。具体的，将一个字符串放在 $trie$ 树上查询，如果途径某个点，这个点是其它串的结尾，那么该串不可能排第一；否则可以根据节点访问顺序建立关于字母优先级的图，用拓扑排序判断是否存在环，若存在环说明该字符串不能排在第一个。\n\n### Code\n```cpp USACO12DEC First! G\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 30005;\nint n, ans;\nstring s[maxn];\nint inDegree[26];\nvector<int> v[26];\nvector<int> firstId;\n\nstruct trie {\n    trie* son[26];\n    bool isEnd;\n    trie() {\n        for (int i = 0; i < 26; i++) son[i] = NULL;\n        isEnd = 0;\n    }\n} * root;\n\nvoid insert(const string& s) {\n    trie* cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        if (cur->son[s[i] - 'a'] == NULL) cur->son[s[i] - 'a'] = new trie;\n        if (i == s.size() - 1) cur->son[s[i] - 'a']->isEnd = 1;\n        cur = cur->son[s[i] - 'a'];\n    }\n}\n\nbool check(const string& s) {\n    for (int i = 0; i < 26; i++) {\n        v[i].clear();\n        inDegree[i] = 0;\n    }\n    trie* cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        for (int j = 0; j < 26; j++)\n            if (cur->son[j] != NULL && j != s[i] - 'a') {\n                v[s[i] - 'a'].push_back(j);\n                inDegree[j]++;\n            }\n        if (i != s.size() - 1 && cur->son[s[i] - 'a']->isEnd) return false;\n        cur = cur->son[s[i] - 'a'];\n    }\n    stack<int> st;\n    for (int i = 0; i < 26; i++)\n        if (!inDegree[i]) st.push(i);\n    while (!st.empty()) {\n        int now = st.top();\n        st.pop();\n        for (int i = 0; i < v[now].size(); i++) {\n            inDegree[v[now][i]]--;\n            if (!inDegree[v[now][i]]) st.push(v[now][i]);\n        }\n    }\n    for (int i = 0; i < 26; i++)\n        if (inDegree[i]) return false;\n    return true;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n;\n    root = new trie;\n    for (int i = 1; i <= n; i++) cin >> s[i], insert(s[i]);\n    for (int i = 1; i <= n; i++)\n        if (check(s[i])) firstId.push_back(i), ans++;\n    cout << ans << endl;\n    for (int i = 0; i < firstId.size(); i++) cout << s[firstId[i]] << endl;\n    return 0;\n}\n```\n## D CQOI2016 路由表\n### Description\n[P5768 CQOI2016 路由表](https://www.luogu.com.cn/problem/P5768)\n\n### Solution\n先把IP地址按题目要求转化为二进制插入 $trie$ 树，顺便对最后访问的节点记录 $inTime$ 和 $length$, 分别表示这个 $IP$ 地址被插入的时间和掩码长度。查询时，对于 $inTime$ 在 $a$ 和 $b$ 之间的 $IP$ 地址，记录对应掩码长度, 将这两个信息存入 $Vector$；对于 $inTime$ 在 $a$ 之前的节点，更新掩码长度最大值。最后对 $Vector$ 按照 $IP$ 地址按插入时间排序，然后从前到后扫一遍 $Vector$，同时更新掩码长度最大值，就可以知道该待查询的IP地址的路由表项选择发生了多少次变化。\n### Code\n```cpp CQOI2016 路由表\n#include <bits/stdc++.h>\n#define pii pair<int, int>\n\nusing namespace std;\n\nint n, x, cntAdd, len, a, b;\nchar type;\nstruct trie {\n    trie* son[2];\n    int inTime, length;\n    trie() {\n        son[1] = son[0] = NULL;\n        inTime = length = 0;\n    }\n} * root;\n\nint read() {\n    char ch = getchar();\n    int x = 0, f = 1;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    return x * f;\n}\n\nvoid insert(vector<bool>& bin, int l, int id) {\n    trie* cur = root;\n    for (int i = 0; i < l; i++) {\n        int now = bin[i];\n        if (cur->son[now] == NULL) cur->son[now] = new trie;\n        cur = cur->son[now];\n        if (i == l - 1) {\n            cur->inTime = id;\n            cur->length = l;\n        }\n    }\n}\n\nvoid query(vector<bool>& bin, int l, int r) {\n    trie* cur = root;\n    int cnt = 0, mx = 0;\n    vector<pii> tmp;\n    for (int i = 0; i < bin.size(); i++) {\n        int now = bin[i];\n        if (cur->son[now] == NULL) break;\n        cur = cur->son[now];\n        if (cur->inTime >= l && cur->inTime <= r)\n            tmp.push_back(make_pair(cur->inTime, cur->length));\n        else if (cur->inTime < l)\n            mx = max(mx, cur->length);\n    }\n    sort(tmp.begin(), tmp.end());\n    for (int i = 0; i < tmp.size(); i++)\n        if (tmp[i].second > mx) mx = tmp[i].second, cnt++;\n    printf(\"%d\\n\", cnt);\n}\n\nint main() {\n    n = read();\n    root = new trie;\n    for (int i = 1; i <= n; i++) {\n        type = getchar();\n        if (type == 'A') {\n            cntAdd++;\n            vector<bool> bin;\n            for (int i = 1; i <= 4; i++) {\n                x = read();\n                for (int j = 7; ~j; j--) bin.push_back((x >> j) & 1);\n            }\n            len = read();\n            insert(bin, len, cntAdd);\n        } else {\n            vector<bool> bin;\n            for (int i = 1; i <= 4; i++) {\n                x = read();\n                for (int j = 7; ~j; j--) bin.push_back((x >> j) & 1);\n            }\n            a = read(), b = read();\n            query(bin, a, b);\n        }\n    }\n    return 0;\n}\n```\n## E JSOI2009 电子字典\n### Description\n[P4407 JSOI2009 电子字典](https://www.luogu.com.cn/problem/P4407)\n\n### Solution\n按照题意直接暴搜即可，注意判重。\n### Code\n```cpp JSOI2009\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, ans, tot;\nstring s;\nstruct trie {\n    trie* son[26];\n    int endTag;\n    trie() {\n        for (int i = 0; i < 26; i++) son[i] = NULL;\n        endTag = 0;\n    }\n} * root;\nunordered_map<int, bool> vis;\n\nvoid insert(const string& s, int id) {\n    trie* cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        if (cur->son[s[i] - 'a'] == NULL) cur->son[s[i] - 'a'] = new trie;\n        cur = cur->son[s[i] - 'a'];\n    }\n    cur->endTag = id;\n}\n\nbool isWord(const string& s) {\n    trie* cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        if (cur->son[s[i] - 'a'] == NULL) return false;\n        cur = cur->son[s[i] - 'a'];\n        if (i == s.size() - 1 && cur->endTag) return true;\n    }\n    return false;\n}\n\nvoid dfs(trie* now, int i, bool canOpt) {\n    if (i == s.size()) {\n        if (now->endTag && !vis[now->endTag]) ans++, vis[now->endTag] = 1;\n        if (canOpt) {\n            for (int k = 0; k < 26; k++)\n                if (now->son[k] != NULL && now->son[k]->endTag &&\n                    !vis[now->son[k]->endTag])\n                    ans++, vis[now->son[k]->endTag] = 1;\n        }\n        return;\n    }\n    if (!canOpt && now->son[s[i] - 'a'] == NULL) return;\n    if (now->son[s[i] - 'a'] != NULL) dfs(now->son[s[i] - 'a'], i + 1, canOpt);\n    if (canOpt) {\n        //增加一位\n        for (int k = 0; k < 26; k++)\n            if (now->son[k] != NULL) dfs(now->son[k], i, 0);\n        //删除一位\n        dfs(now, i + 1, 0);\n        //修改一位\n        for (int k = 0; k < 26; k++)\n            if (now->son[k] != NULL) dfs(now->son[k], i + 1, 0);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    root = new trie;\n    for (int i = 1; i <= n; i++) {\n        cin >> s;\n        insert(s, i);\n    }\n    for (int i = 1; i <= m; i++) {\n        vis.clear();\n        cin >> s;\n        if (isWord(s))\n            cout << -1 << endl;\n        else {\n            ans = 0;\n            dfs(root, 0, 1);\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n```\n## F AHOI2005 病毒检测\n### Description\n[P2536 AHOI2005 病毒检测](https://www.luogu.com.cn/problem/P2536)\n\n### Solution\n按照题意建出 $trie$ 树，然后记忆化搜索即可。本题有加强版，需要使用 AC 自动机实现通配符模糊匹配。(写完 AC 自动机博客再把链接贴上)\n\n### Code\n```cpp AHOI2005 病毒检测\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 505;\nint n, ans, len;\nchar s[maxn], T[maxn * 2];\nint isVirus[maxn], firstId[maxn];\nint to[200];\nbitset<1001> vis[maxn * maxn];\n\nstruct trie {\n    trie* son[4];\n    int endTag, num;\n    trie() {\n        for (int i = 0; i < 4; i++) son[i] = NULL;\n        endTag = num = 0;\n    }\n} * root;\n\nvoid insert(const string& s, const int& id) {\n    static int tot;\n    trie* cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        if (cur->son[to[s[i]]] == NULL) cur->son[to[s[i]]] = new trie;\n        cur = cur->son[to[s[i]]];\n        cur->num = ++tot;\n    }\n    if (!cur->endTag) cur->endTag = id;\n    firstId[id] = cur->endTag;\n}\n\nvoid match(trie* now, int i) {\n    if (i == len) {\n        isVirus[now->endTag] = 1;\n        return;\n    }\n    if (vis[now->num][i]) return;\n    vis[now->num][i] = 1;\n    if (T[i] == '*') {\n        match(now, i + 1);\n        for (int k = 0; k < 4; k++)\n            if (now->son[k] != NULL)\n                match(now->son[k], i + 1), match(now->son[k], i);\n    } else if (T[i] == '?') {\n        for (int k = 0; k < 4; k++)\n            if (now->son[k] != NULL) match(now->son[k], i + 1);\n    } else {\n        if (now->son[to[T[i]]] != NULL) match(now->son[to[T[i]]], i + 1);\n    }\n}\n\nint main() {\n    to['A'] = 0, to['T'] = 1, to['C'] = 2, to['G'] = 3;\n    scanf(\"%s%d\", T, &n);\n    len = strlen(T);\n    root = new trie;\n    for (int i = 1; i <= n; i++) scanf(\"%s\", s), insert(s, i);\n    for (int i = 0; i < maxn * maxn; i++) vis[i].reset();\n    match(root, 0);\n    for (int i = 1; i <= n; i++)\n        if (isVirus[firstId[i]]) ans++;\n    printf(\"%d\\n\", n - ans);\n    return 0;\n}\n```\n## G SCOI2016 背单词\n### Description\n[P3294 SCOI2016 背单词](https://www.luogu.com.cn/problem/P3294)\n\n### Solution\n显然，情形 $3$ 比情形 $1$ 和 $2$ 更优，因为情形 $1$ 和情形 $2$ 不管怎样都会吃大于等于 $x$ 个泡椒。只需要考虑情形 $3$，对于情形 $3$ 我们需要构建一种方案，使得$\\sum(x-y)$ 最小。\n\n首先将输入的字符串反转后插入 $trie$ 树中，这样转化为前缀方便处理。\n容易发现，除了 $root$ 和 一个串最后一个字符对应节点外，其它节点对答案没有影响，我们根据这些终点节点重新构建 $trie$ 树，将多余的节点删掉。以下图为例：\n\n设有字符串：$CA,GDA,HDA,EA,IFB$\n\n原来的 $trie$ 树:\n![](https://s2.ax1x.com/2019/10/28/K6m0Rf.png)\n\n重新构建的 $trie$ 树:\n![](https://s2.ax1x.com/2019/10/28/K6mwJP.png)\n\n容易发现，一个节点(对应一个字符串)的贡献取决于它和它父亲被选取的时间差。可以证明，按dfs选取，且先访问size小的子树最优。\n\n先证明按 $dfs$ 序选取一定最优，对于以同一深度的节点为根的一系列子树，在一颗中找一个叶子节点 $j$,在另一颗里找一个根节点 $i$ (当前序列中j所在的子树的根在i之前出现)。需要明确的是，只有这两种节点间才能交换顺序，否则得到序列不满足情形 $3$ 。假设 $j$ 在 $i$ 之前代价最小，尝试将 $j$ 放在 $i$ 的后面。可以发现发现 $i$ 的孩子们和 $i$ 的距离都会加 1，所以总代价会增加，而 $j$ 和 $j$ 的父亲的距离一定也会增加，所以总代价也会增加。\n\n再证明优先选取size小的子树更优。实际上，按照dfs序，第i个选取的子树的根的贡献等于之前选取的子树的size的和，所以size小的应该放在前面。\n\n### Code SCOI2016 背单词\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn = 510005;\nint n, sz[maxn], in[maxn];\nstring s;\nll ans;\nvector<int> v[maxn];\n\nstruct trie {\n    int son[26];\n    int tag;\n    trie() {\n        for (int i = 0; i < 26; i++) son[i] = -1;\n        tag = 0;\n    }\n} trie[maxn];\nint root, tot;\n\nvoid insert(const string &s) {\n    int cur = root;\n    for (int i = s.size() - 1; ~i; i--) {\n        int now = s[i] - 'a';\n        if (trie[cur].son[now] == -1) trie[cur].son[now] = ++tot;\n        cur = trie[cur].son[now];\n        if (!i) trie[cur].tag = 1;\n    }\n}\n\nvoid rebuild(int now, int pre) {\n    for (int i = 0; i < 26; i++) {\n        if (trie[now].son[i] != -1) {\n            if (trie[trie[now].son[i]].tag) {\n                v[pre].push_back(trie[now].son[i]);\n                rebuild(trie[now].son[i], trie[now].son[i]);\n            } else\n                rebuild(trie[now].son[i], pre);\n        }\n    }\n}\n\nbool cmp(const int &a, const int &b) { return sz[a] < sz[b]; }\nvoid dfs(int now) {\n    sz[now] = 1;\n    for (int i = 0; i < v[now].size(); i++) {\n        dfs(v[now][i]);\n        sz[now] += sz[v[now][i]];\n    }\n    sort(v[now].begin(), v[now].end(), cmp);\n}\n\nvoid dfs2(int now) {\n    static int tim;\n    in[now] = tim++;\n    for (int i = 0; i < v[now].size(); i++) {\n        ans += tim - in[now];\n        dfs2(v[now][i]);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) cin >> s, insert(s);\n    rebuild(root, root);\n    dfs(root);\n    dfs2(root);\n    cout << ans;\n    return 0;\n}\n```\n\n## H HAOI2017 供给侧改革\n### Description\n[P3732 HAOI2017 供给侧改革](https://www.luogu.com.cn/problem/P3732)\n\n### Solution\n在线不太好做，考虑离线处理，将询问按右端点排序,从 $1$ 到 $n$ 枚举起始位 $i$，将起始位置 $i$ 到最后一位的部分插入 $trie$ 树中，然后查询对右端点为 $i$ 的询问的答案。实际上，由于数据随机生成，容易推出最长公共前缀长度不超过40，所以只需要从起始位 $i$ 开始往后插入 $40$ 位就可以了。\n\n对任意位置$i$，记 $pos[k]$ 对应最大左端点，使得 $data(pos[k],i)=k$。显然，$k$ 越大，$pos[k]$ 越小。同时 $trie$ 树上每个节点记一个 $last$，表示上次被访问时对应串的起点位置。插入时，容易算出之前的插入的串和当前串\n被插入部分的公共前缀的长度 $l$, 并更新 $pos[l]$ = $\\max(pos[l],last)$,对应新的最大左端点。\n\n每次插入后，对所有以 $i$ 为右端点的询问，枚举公共前缀的长度 $k$，根据 $pos$ 中的信息即可求得该询问的答案。\n\n### Code\n```cpp HAOI2017 供给侧改革\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn = 100005;\nint n, m, pos[50];\n// pos[k]对应最大左端点，使得 data(pos[k],i)=k;\n//大于pos[k]的位置，data(pos[k],i)<k\nchar s[maxn];\nll ans[maxn];\nstruct trie {\n    trie* son[2];\n    int last;\n    trie() {\n        son[0] = son[1] = NULL;\n        last = 0;\n    }\n} * root;\n\nstruct Question {\n    int l, r, qId;\n    bool operator<(const Question& other) { return r < other.r; }\n} Q[maxn];\n\nint read() {\n    char ch = getchar();\n    int x = 0, f = 1;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    return x * f;\n}\n\nvoid insert(int st) {\n    trie* cur = root;\n    for (int i = st; i <= min(st + 39, n); i++) {\n        int now = s[i] - '0';\n        if (cur->son[now] == NULL) cur->son[now] = new trie;\n        cur = cur->son[now];\n        if (cur->last) pos[i - st + 1] = max(pos[i - st + 1], cur->last);\n        cur->last = st;\n    }\n}\n\nint main() {\n    n = read(), m = read();\n    scanf(\"%s\", s + 1);\n    for (int i = 1; i <= m; i++) Q[i].l = read(), Q[i].r = read(), Q[i].qId = i;\n    sort(Q + 1, Q + m + 1);\n    root = new trie;\n    for (int i = 1, j = 1; i <= n; i++) {\n        insert(i); //插入起始位置在i的串\n        while (j <= m && Q[j].r == i) {//以i结尾询问\n            for (int k = 1; k <= 40; k++) {//枚举长度\n                if (pos[k] >= Q[j].l)// pos[k]在[l,r]内\n                    ans[Q[j].qId] +=k * (pos[k] - max(pos[k + 1] + 1, Q[j].l) +1); \n                else\n                    break;  \n                    // data(pos[k+1]+1,pos[k])=k\n                    //由pos单调性可知更大的k都不合法\n            }\n            j++;  //下一个询问\n        }\n    }\n    for (int i = 1; i <= m; i++) printf(\"%lld\\n\", ans[i]);\n    return 0;\n}\n```\n## I BJOI2016 IP地址\n### Description\n[P5460 BJOI2016 IP地址](https://www.luogu.com.cn/problem/P5460)\n\n### Solution\n一个 $ip$ 地址在操作 $[l+1,r]$ 匹配到的生效规则变化的次数等于 在 $[1,r]$ 的变化次数**减去** 在$[1,l]$ 的变化次数。容易发现，不论删除还是插入某一规则，在 $trie$ 树中，只会对**当前规则的结尾**和**当前规则结尾往下的第一个结尾**之间的全部节点产生影响。\n\n用 $cnt$ 记录到当前节点匹配到的生效规则变化的次数，$lazyTag$作为延迟下放标记，$endTag$ 记录是否为某条规则的结尾。在插入/删除一个规则时，在结尾处更新 $endTag= endTag + type$($type$ 为 1 表示插入，-1 表示删除)，$cnt++$ 表示匹配到的生效规则发生了一次变化，同时更新 $lazyTag$。插入/删除的同时沿途下放标记，直到遇到下一个结尾停止。  \n\n将操作按 1 到 $n$ 的顺序进行，对于操作 $i$, 可以预处理出哪些询问的左端点或右端点是 $i$。将这些询问的 IP 地址放在当前的 $trie$ 上查询，同时沿途下放标记, 返回末尾处的 $cnt$ 即可求得该 IP 地址在操作$[1,i]$ 匹配到的生效规则变化的次数。如果是左端点，则这个询问的答案应减去 $cnt$; 否则，这个询问的答案应加上 $cnt$。\n\n### Code\n```cpp BJOI2016 IP地址\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int maxn = 1e5 + 5;\n\nint n, m;\nchar opt[4];\nstring principle[maxn], ip[maxn];\nint l[maxn], r[maxn], type[maxn], ans[maxn];\nvector<int> vl[maxn], vr[maxn];\n\nstruct trie {\n    trie* son[2];\n    int lazyTag, endTag, cnt;\n    trie() {\n        son[0] = son[1] = NULL;\n        lazyTag = endTag = cnt = 0;\n    }\n} * root;\n\nvoid pushDown(trie* cur) {\n    if (cur->son[0] == NULL) cur->son[0] = new trie;\n    if (cur->son[1] == NULL) cur->son[1] = new trie;\n\n    if (!cur->son[0]->endTag)\n        cur->son[0]->lazyTag += cur->lazyTag, cur->son[0]->cnt += cur->lazyTag;\n    if (!cur->son[1]->endTag)\n        cur->son[1]->lazyTag += cur->lazyTag, cur->son[1]->cnt += cur->lazyTag;\n\n    cur->lazyTag = 0;\n}\n\nvoid insert(const string& s, int type) {\n    trie* cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        pushDown(cur);\n        cur = cur->son[s[i] - '0'];\n    }\n    cur->endTag += type;\n    cur->lazyTag++;\n    cur->cnt++;\n}\n\nint query(const string& s) {\n    trie* cur = root;\n    for (int i = 0; i < s.size(); i++) {\n        if (cur->son[s[i] - '0'] == NULL) return cur->cnt;\n        pushDown(cur);\n        cur = cur->son[s[i] - '0'];\n    }\n    return cur->cnt;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) {\n        cin >> opt >> principle[i];\n        type[i] = (opt[0] == 'A' ? 1 : -1);\n    }\n    for (int i = 1; i <= m; i++) {\n        cin >> ip[i] >> l[i] >> r[i];\n        vl[l[i]].push_back(i);\n        vr[r[i]].push_back(i);\n    }\n    root = new trie;\n    for (int i = 1; i <= n; i++) {\n        insert(principle[i], type[i]);\n        for (int j = 0; j < vl[i].size(); j++) {\n            int id = vl[i][j];\n            ans[id] -= query(ip[id]);\n        }\n        for (int j = 0; j < vr[i].size(); j++) {\n            int id = vr[i][j];\n            ans[id] += query(ip[id]);\n        }\n    }\n    for (int i = 1; i <= m; i++) cout << ans[i] << endl;\n    return 0;\n}\n```\n## J Ynoi2011 竞赛实验班\n### Description\n[P5312 Ynoi2011 竞赛实验班](https://www.luogu.com.cn/problem/P5312)\n\n### Solution\n对于操作 1、3，根据异或运算性质, 开一个全局异或值 $X$ ( 初始为0 ）, 每次将 $X$ 异或上操作 3 给出的 $x$。当插入一个数 $x$ 时，将 $x$ 异或上 $X$ 再插入，这样在查询时再异或上当前的 $X$ 就可以得到插入 $x$ 之后，进行一系列操作 3 后 $x$ 的真实值。\n\n注意到经过操作 4， 任意时刻的序列一定是前半段有序，后半段无序的，这两段对应区间记为 $[1,lastN]$ 和 $[lastN+1,n]$。\n实际上，构建出的 $trie$ 树某种程度上说本身就是排好序的，所以对于操作 2，有序的部分可以在 $trie$ 上用类似平衡树查询前缀和的方式；无序的部分可以用二维数组记每一位 1 的个数的前缀和求出，这个前缀和在排序后清零。\n\n综合上述分析，查询应分有两种。具体的，对于无序部分的查询，根据 $X$ 的值，结合前缀和数组，可以推出在 $[lastN+1,n]$ 这段区间上每一位 1 的个数的实际值，一位一位累加可得答案；对于有序的部分，应分别求出前 $lastN$ 个数的和以及前 $l-1$ 个数的和，两者相减可得有序部分 $[l,lastN]$ 的和，详见代码。\n### Code\n```cpp Ynoi2011 竞赛实验班\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn = 1e5 + 5;\nint n, m, type, l, r, X, lastN, lastXor;\nint a[maxn * 2], sum[maxn * 2][31];\n\nstruct trie {\n    trie* son[2];\n    int sz;\n    int cnt[31];\n    trie() {\n        son[0] = son[1] = NULL;\n        for (int i = 0; i < 31; i++) cnt[i] = 0;\n        sz = 0;\n    }\n} * root;\n\nint read() {\n    char ch = getchar();\n    int x = 0, f = 1;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    return x * f;\n}\n\nvoid insert(const int& x) {\n    trie* cur = root;\n    for (int i = 30; i >= 0; i--) {\n        int to = (x >> i) & 1;\n        if (cur->son[to] == NULL) cur->son[to] = new trie;\n        cur = cur->son[to];\n        cur->sz++;\n        for (int k = 0; k <= 30; ++k) cur->cnt[k] += (x >> k) & 1;\n    }\n}\n\nll query2(const int& l, const int& r) {\n    ll ans = 0, len = r - l + 1;\n    for (int i = 0; i < 31; i++) {\n        ll cnt = sum[r][i] - sum[l - 1][i];\n        if ((X >> i) & 1) cnt = len - cnt;\n        ans += cnt << i;\n    }\n    return ans;\n}\n\nll query1(int sz) {\n    if (!sz) return 0;\n    ll ans = 0, val = 0; \n    //val 记录排名第sz的数在当前树中的值，最后实际值要异或全局X\n    //ans 在查询的时候已经对X异或过了，最后不需要再异或\n    trie* cur = root;\n    for (int i = 30; i >= 0; --i) {\n        int to = (lastXor >> i) & 1;  //最后一次排序后的异或值\n        if (cur->son[to] != NULL && sz <= cur->son[to]->sz)\n            cur = cur->son[to], val |= to << i;\n        else {\n            int sizeOfSon = (cur->son[to] == NULL ? 0 : cur->son[to]->sz);\n            //统计son[to]的贡献, 注意用的是当前异或值\n            for (int k = 0; k < 31; k++) {\n                ll cnt = (cur->son[to] == NULL ? 0 : cur->son[to]->cnt[k]);\n                if ((X >> k) & 1) cnt = sizeOfSon - cnt;//实际值要异或X\n                ans += cnt << k;\n            }\n            //走另外一边\n            sz -= sizeOfSon;\n            cur = cur->son[to ^ 1];\n            val |= (to ^ 1) << i;\n        }\n    }\n    return ans + (val ^ X) * sz;  //可能多个数结尾在同一链\n}\n\nint main() {\n    n = read();\n    for (int i = 1; i <= n; i++) {\n        a[i] = read();\n        for (int k = 0; k < 31; k++)\n            sum[i][k] = sum[i - 1][k] + ((a[i] >> k) & 1);\n    }\n    m = read();\n    root = new trie;\n    for (int i = 1; i <= m; i++) {\n        type = read();\n        if (type == 1) {\n            a[++n] = read() ^ X;\n            for (int k = 0; k < 31; k++)\n                sum[n][k] = sum[n - 1][k] + ((a[n] >> k) & 1);\n        } else if (type == 2) {\n            l = read(), r = read();\n            //有序部分用trie处理，无序部分利用前缀和\n            if (r <= lastN)\n                printf(\"%lld\\n\", query1(r) - query1(l - 1));\n            else if (l > lastN)\n                printf(\"%lld\\n\", query2(l, r));\n            else\n                printf(\"%lld\\n\",\n                       query1(lastN) - query1(l - 1) + query2(lastN + 1, r));\n        } else if (type == 3) {\n            X ^= read();\n        } else {\n            for (int k = lastN + 1; k <= n; k++) insert(a[k]);\n            memset(sum[n], 0, sizeof(sum[n]));\n            lastN = n, lastXor = X;\n        }\n    }\n    return 0;\n}\n```\n## K Choosing The Commander\n### Description\n[CF817E Choosing The Commander](https://www.luogu.com.cn/problem/CF817E)\n\n### Solution\n插入一个数将其访问过的节点的 $sum++$，删除一个数则 $sum--$。查询时，类似平衡树求 $rank$ 的做法。具体的，记 $l$ 的第 $i$ 位为 $l_i$，$p$ 的第 $i$ 位为 $p_i$。若 $l_i=1$,那么答案应该加上 $son[p_i]$的 $sum$，同时继续查询 $son[p_i⊕1]$；否则继续查询 $son[p_i]$。\n\n### Code\n```cpp Choosing The Commander\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, p, l, type;\nstruct trie {\n    trie* son[2];\n    int sum;\n    trie() {\n        son[0] = son[1] = NULL;\n        sum = 0;\n    }\n} * root;\n\ntemplate <class T>\nvoid read(T& x, int f = 1) {\n    char ch = getchar();\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nvoid insert(int p, int type) {\n    trie* cur = root;\n    for (int i = 31; ~i; i--) {\n        int now = (p >> i) & 1;\n        if (cur->son[now] == NULL) cur->son[now] = new trie;\n        cur = cur->son[now];\n        cur->sum += type;\n    }\n}\n\nvoid query(int p, int l) {\n    int ans = 0;\n    trie* cur = root;\n    for (int i = 31; ~i; i--) {\n        bool pi = (p >> i) & 1;\n        bool li = (l >> i) & 1;\n        if (cur == NULL) break;\n        if (li && cur->son[pi] != NULL) ans += cur->son[pi]->sum;\n        cur = cur->son[pi ^ li];\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    read(n);\n    root = new trie;\n    for (int i = 1; i <= n; i++) {\n        read(type), read(p);\n        if (type == 1)\n            insert(p, 1);\n        else if (type == 2)\n            insert(p, -1);\n        else\n            read(l), query(p, l);\n    }\n    return 0;\n}\n```\n## L CF241B Friends\n### Description\n[CF241B Friends](https://www.luogu.com.cn/problem/CF241B)\n### Solution\n直接求第 $k$ 不太好处理，因为选取的是无序对，存在选取顺序问题,不然会重复。为了方便可以考虑求所有有序对的异或值，然后求前 $2k$ 大的异或值的和 ，那么答案就是求得的和的一半，这样就不需要考虑重复了。\n\n建立好 $trie$ 树后，用类似平衡树求第 $2k$ 大的方法求出第 $2k$ 大的两两异或值 $valKth$，同时可以得到这样的值有多少个。接下来于对每一个数 $val[i]$，在 $trie$ 树上，求与之异或后大于 $valKth$ 的数的和。具体的，若 $valkth$ 第 $j$ 位为 1，那么接下来应该访问和 $val[i]$ 第 $j$ 位互补的那个儿子；否则，应该访问$val[i]$ 第 $j$ 位相同的儿子，同时统计与 $val[i]$ 在第 $j$ 位异或值为 1 的值的和。具体的统计方法是，在预处理时将 $val$ 数组排序，记录每一位上 0/1 数量的前缀和，在插入时记录每个节点对应 $val$ 的下标范围，之后根据这个范围内每一位(设为 $p$)  0/1 的个数以及 $val[i]$ 的第 $p$ 位的值按位求和即可。\n### Code\n```cpp CF241B Friends\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 5e4 + 5;\nconst int MOD = 1e9 + 7;\nconst int BIT = 30;\nint n, val[MAXN];\nll k, pre[MAXN][BIT + 2][2];  //每一位上0,1的个数前缀和\n\nstruct trie {\n    trie* son[2];\n    int sz, mx, mi;\n    trie() {\n        son[0] = son[1] = NULL;\n        sz = mx = mi = 0;\n    }\n} * root;\n\nll qpow(ll a, ll b) {\n    ll ans = 1, base = a;\n    while (b) {\n        if (b & 1) ans = ans * base % MOD;\n        b >>= 1, base = base * base % MOD;\n    }\n    return ans;\n}\n\nvoid insert(int& id) {\n    trie* cur = root;\n    for (int i = BIT; ~i; i--) {\n        int now = (val[id] >> i) & 1;\n        if (cur->son[now] == NULL) cur->son[now] = new trie;\n        cur = cur->son[now];\n        cur->sz++;\n        cur->mx = id;\n        cur->mi = (cur->mi ? cur->mi : id);\n    }\n}\n\nll getKth(ll& k) {\n    ll ans = 0;\n    trie* nodePtr[MAXN];\n    for (int i = 1; i <= n; i++) nodePtr[i] = root;\n    for (int j = BIT; ~j; j--) {\n        ll tmp = 0;\n        bool tag = 1;\n        for (int i = 1; i <= n; i++)\n            if (nodePtr[i] != NULL &&\n                nodePtr[i]->son[((val[i] >> j) & 1) ^ 1] != NULL)\n                tmp += nodePtr[i]->son[((val[i] >> j) & 1) ^ 1]->sz;\n        if (tmp >= k)  //该位选1的方案数>=k，则第k大的在这一位必为1\n            ans |= 1ll << j;\n        else  //该位选1的方案数<k，则第k大的在这一位必为0，且排名<=k-该位选1的方案数\n            k -= tmp, tag = 0;\n        for (int i = 1; i <= n; i++)\n            if (nodePtr[i])\n                nodePtr[i] = nodePtr[i]->son[((val[i] >> j) & 1) ^ tag];\n    }\n    return ans;\n}\n\nvoid getSum(ll k) {\n    ll valKth = getKth(k);\n    ll ans = valKth * k % MOD;\n    for (int i = 1; i <= n; i++) {\n        //对于每一个数，求与之异或后大于valKth的数的和\n        trie* cur = root;\n        for (int j = BIT; ~j; j--) {\n            if (cur == NULL) break;\n            if ((valKth >> j) & 1)\n                cur = cur->son[((val[i] >> j) & 1) ^ 1];\n            else {\n                if (cur->son[((val[i] >> j) & 1) ^ 1] != NULL) {\n                    int l = cur->son[((val[i] >> j) & 1) ^ 1]->mi - 1;\n                    int r = cur->son[((val[i] >> j) & 1) ^ 1]->mx;\n                    for (int p = BIT; ~p; p--) {\n                        if ((val[i] >> p) & 1)\n                            ans += (pre[r][p][0] - pre[l][p][0]) << p;\n                        else\n                            ans += (pre[r][p][1] - pre[l][p][1]) << p;\n                        ans %= MOD;\n                    }\n                }\n                cur = cur->son[(val[i] >> j) & 1];\n            }\n        }\n    }\n    cout << ans * qpow(2, MOD - 2) % MOD;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n >> k;\n    k *= 2;\n    for (int i = 1; i <= n; i++) cin >> val[i];\n    sort(val + 1, val + n + 1);\n    root = new trie;\n    for (int i = 1; i <= n; i++) insert(i);\n    for (int j = BIT; ~j; j--)\n        for (int i = 1; i <= n; i++) {\n            pre[i][j][0] = pre[i - 1][j][0] + !((val[i] >> j) & 1);\n            pre[i][j][1] = pre[i - 1][j][1] + ((val[i] >> j) & 1);\n        }\n    getSum(k);\n    return 0;\n}\n```\n\n## L 十二省联考2019 异或粽子\n### Description\n[P5283 十二省联考2019 异或粽子](https://www.luogu.com.cn/problem/P5283)\n### Solution\n上一题的弱化版。本机运行时可能炸内存，可以适当调小 MAXN 的值。\n### Code\n```cpp 十二省联考2019 异或粽子\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 5e5 + 5;\nconst int BIT = 31;\nint n;\nll k, pre[MAXN][BIT + 1][2], val[MAXN], x;\nstruct trie {\n    trie* son[2];\n    int sz, mx, mi;\n    trie() {\n        son[0] = son[1] = NULL;\n        sz = mx = mi = 0;\n    }\n} * root;\n\nvoid insert(int& id) {\n    trie* cur = root;\n    for (int i = BIT; ~i; i--) {\n        int now = (val[id] >> i) & 1;\n        if (cur->son[now] == NULL) cur->son[now] = new trie;\n        cur = cur->son[now];\n        cur->sz++;\n        cur->mx = id;\n        cur->mi = (cur->mi ? cur->mi : id);\n    }\n}\n\nll getKth(ll& k) {\n    ll ans = 0;\n    trie* nodePtr[MAXN];\n    for (int i = 1; i <= n + 1; i++) nodePtr[i] = root;\n    for (int j = BIT; ~j; j--) {\n        ll tmp = 0;\n        bool tag = 1;\n        for (int i = 1; i <= n + 1; i++)\n            if (nodePtr[i] != NULL &&\n                nodePtr[i]->son[((val[i] >> j) & 1) ^ 1] != NULL)\n                tmp += nodePtr[i]->son[((val[i] >> j) & 1) ^ 1]->sz;\n        if (tmp >= k)\n            ans |= 1ll << j;\n        else\n            k -= tmp, tag = 0;\n        for (int i = 1; i <= n + 1; i++)\n            if (nodePtr[i])\n                nodePtr[i] = nodePtr[i]->son[((val[i] >> j) & 1) ^ tag];\n    }\n    return ans;\n}\n\nvoid getSum(ll k) {\n    ll valKth = getKth(k);\n    ll ans = valKth * k;\n    for (int i = 1; i <= n + 1; i++) {\n        trie* cur = root;\n        for (int j = BIT; ~j; j--) {\n            if (cur == NULL) break;\n            if ((valKth >> j) & 1)\n                cur = cur->son[((val[i] >> j) & 1) ^ 1];\n            else {\n                if (cur->son[((val[i] >> j) & 1) ^ 1] != NULL) {\n                    int l = cur->son[((val[i] >> j) & 1) ^ 1]->mi - 1;\n                    int r = cur->son[((val[i] >> j) & 1) ^ 1]->mx;\n                    for (int p = BIT; ~p; p--) {\n                        if ((val[i] >> p) & 1)\n                            ans += (pre[r][p][0] - pre[l][p][0]) << p;\n                        else\n                            ans += (pre[r][p][1] - pre[l][p][1]) << p;\n                    }\n                }\n                cur = cur->son[(val[i] >> j) & 1];\n            }\n        }\n    }\n    cout << ans / 2;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    cin >> n >> k;\n    k *= 2;\n    val[1] = 0;\n    for (int i = 2; i <= n + 1; i++) {\n        cin >> x;\n        val[i] = val[i - 1] ^ x;\n    }\n    sort(val + 1, val + n + 2);\n    root = new trie;\n    for (int i = 1; i <= n + 1; i++) insert(i);\n    for (int j = BIT; ~j; j--)\n        for (int i = 1; i <= n + 1; i++) {\n            pre[i][j][0] = pre[i - 1][j][0] + !((val[i] >> j) & 1);\n            pre[i][j][1] = pre[i - 1][j][1] + ((val[i] >> j) & 1);\n        }\n    getSum(k);\n    return 0;\n}\n```\n\n## M CF1055F Tree and XOR\n### Description\n[CF1055F Tree and XOR](https://www.luogu.com.cn/problem/CF1055F)\n### Solution\n做法同 CF241B Friends。不过按照 CF241B Friends 的做法空间复杂度为 $O(61*N)$，显然不可能把整个 $trie$ 树存进去。实际上，只求第 $k$ 大的话有用的只有一层节点，当访问到下一层时，将上一层节点删除就好了。这样空间复杂度变为 $O(N)$，时间复杂度依然为$O(61*N)$。\n\n注: 用系统自带的 $delete$ 时不知道为何 $RE$ 了，这里手写了 $new$ 和 $delete$ 操作。\n### Code\n```cpp CF1055F Tree and XOR\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e6 + 5;\nconst int BIT = 61;\nint n, p[MAXN],u,tot[2];\nll k, val[MAXN], v;\n\ntemplate<class T>\nvoid read(T &x, int f = 1) {\n  char ch = getchar();\n  x = 0;\n  while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n  while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n  x *= f;\n}\n\nstruct trie {\n  trie* son[2];\n  int sz;\n  trie() {\n    son[0] = son[1] = NULL;\n    sz = 0;\n  }\n}*root,node[MAXN][2];\n\ntrie* newNode(trie* &cur,bool tag) {\n  return cur=&node[tot[tag]++][tag];\n}\n\nvoid getKth(ll k) {\n  ll ans = 0;\n  newNode(root,0);\n  trie *nodePtr[MAXN],*valPtr[MAXN];\n  for (int i = 1; i <= n; i++) nodePtr[i] = valPtr[i] = root;\n  for (int j = BIT; ~j; j--) {\n    ll tmp = 0;\n    bool tag = 0;\n    for (int i = 1; i <= n; i++) {\n      if (valPtr[i]->son[((val[i] >> j) & 1)] == NULL)\n        newNode(valPtr[i]->son[((val[i] >> j) & 1)],j&1);\n      valPtr[i] = valPtr[i]->son[((val[i] >> j) & 1)];\n      valPtr[i]->sz++;\n    }\n    for (int i = 1; i <= n; i++)\n      if (nodePtr[i] != NULL && nodePtr[i]->son[((val[i] >> j) & 1)] != NULL)\n        tmp += nodePtr[i]->son[((val[i] >> j) & 1)]->sz;\n    if (tmp < k) {\n      k -= tmp, tag = 1;\n      ans |= 1ll << j;\n    }\n    for (int i = 1; i <= n; i++)\n      if (nodePtr[i] != NULL)\n        nodePtr[i] = nodePtr[i]->son[((val[i] >> j) & 1) ^ tag];\n    for(int i=0; i<=tot[(j&1)^1]; i++) {\n      node[i][(j&1)^1].son[0]=node[i][(j&1)^1].son[1]=NULL;\n      node[i][(j&1)^1].sz=0;\n    }\n    tot[(j&1)^1]=0;\n  }\n  cout << ans;\n}\n\nstruct edge {\n  int nxt, to;\n  ll val;\n} e[MAXN];\n\nvoid addEdge(int from, int to, ll val) {\n  static int t;\n  e[t].val = val, e[t].to = to, e[t].nxt = p[from], p[from] = t++;\n}\n\nvoid dfs(int now, ll v) {\n  val[now] = v;\n  for (int i = p[now]; ~i; i = e[i].nxt) {\n    int to = e[i].to;\n    if (!val[to]) dfs(to, v ^ e[i].val);\n  }\n}\n\nint main() {\n  read(n),read(k);\n  memset(p, -1, sizeof(p));\n  for (int i = 1; i <= n - 1; i++) {\n    read(u), read(v);\n    addEdge(u, i + 1, v);\n  }\n  dfs(1, 0);\n  getKth(k);\n  return 0;\n}\n```\n# Level IV\n可持久化 $Trie$ 树,原理和可持久化线段树相同\n\n## A 最大异或和\n### Description\n[P4735 最大异或和](https://www.luogu.com.cn/problem/P4735)\n### Solution\n记 $preXor_i$ 表示前 $i$ 个数的异或和。对于查询操作，用异或性质转化一下，只需要求 $preXor_N⊕x$ 异或上 $preXor_{p-1}$ 的最大值（$l-1<=p<=r-1$），即在 $r-1$ 版本的 $trie$ 树中求插入时间大于等于 $l-1$ 的数与 $preXor_N⊕x$ 的最大异或和。因此每个点记一个 $last$，表示最后访问的时间，当 $last\\ge l-1$时才可能被计入答案。 \n### Code\n```cpp 最大异或和\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int MAXN = 3e5 + 5;\n\nint n, m, l, r;\nint preXor, x;\nchar type[2];\nstruct trie {\n    trie *son[2];\n    int last;\n    trie() {\n        son[0] = son[1] = NULL;\n        last = 0;\n    }\n} node[MAXN * 48], *root[MAXN * 2];\n\nvoid read(int &x, int f = 1) {\n    char ch = getchar();\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n}\n\ntrie *newNode(trie *&cur) {\n    static int cntNode;\n    return cur = &node[cntNode++];\n}\n\nvoid initR0() {\n    trie *cur = newNode(root[0]);\n    for (register int i = 23; i >= 0; i--) cur = newNode(cur->son[0]);\n}\n\nvoid build(const int &id) {\n    trie *cur = newNode(root[id]), *pre = root[id - 1];\n    for (register int i = 23; ~i; i--) {\n        int now = (preXor >> i) & 1;\n        if (pre != NULL) {\n            cur->son[now ^ 1] = pre->son[now ^ 1];\n            pre = pre->son[now];\n        }\n        cur = newNode(cur->son[now]);\n        cur->last = id;\n    }\n}\n\nvoid query(trie *cur, const int &last, const int &val) {\n    int ans = 0;\n    for (register int i = 23; ~i; i--) {\n        int now = (val >> i) & 1;\n        trie *tmp = cur->son[now ^ 1];\n        if (tmp != NULL && tmp->last >= last)\n            cur = tmp, ans += 1 << i;\n        else\n            cur = cur->son[now];\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    read(n), read(m);\n    initR0();\n    for (int i = 1; i <= n; i++) {\n        read(x);\n        preXor ^= x;\n        build(i);\n    }\n    for (int i = 1; i <= m; i++) {\n        scanf(\"%s\", type);\n        if (type[0] == 'A') {\n            read(x);\n            preXor ^= x;\n            build(++n);\n        } else {\n            read(l), read(r), read(x);\n            query(root[r - 1], l - 1, preXor ^ x);\n        }\n    }\n    return 0;\n}\n```\n## B TJOI2018 异或\n### Description\n[P4592 TJOI2018 异或](https://www.luogu.com.cn/problem/P4592)\n### Solution\n对于询问 1，按dfs序建立可持久化 $trie$ 树；对于询问 2，按深度建立可持久化 $trie$ 树，查询的时候求一下 $lca$ 即可。\n\n### Code\n```cpp TJOI2018 异或\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\nconst int BIT = 29;\nint n, q, u, v, opt, z;\nint p[MAXN], fa[MAXN][18], depth[MAXN];\nint in[MAXN], out[MAXN], val[MAXN];\n\nvoid read(int &x, int f = 1) {\n    char ch = getchar();\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct trie {\n    trie *son[2];\n    int last;\n    trie() {\n        son[0] = son[1] = NULL;\n        last = 0;\n    }\n} node[MAXN * (BIT + 2)][2], *root[MAXN][2];\n\ntrie *newNode(trie *&cur, const bool &tag) {\n    static int cntNode[2];\n    return cur = &node[cntNode[tag]++][tag];\n}\n\nvoid initRoot() {\n    trie *cur = newNode(root[1][0], 0);\n    trie *tmp = newNode(root[1][1], 1);\n    for (int i = BIT; ~i; i--) {\n        int now = (val[1] >> i) & 1;\n        cur = newNode(cur->son[now], 0);\n        tmp = newNode(tmp->son[now], 1);\n        cur->last = tmp->last = 1;\n    }\n}\n\nvoid insert(trie *pre, trie *cur, int val, int last, bool tag) {\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        if (pre != NULL) {\n            cur->son[now ^ 1] = pre->son[now ^ 1];\n            pre = pre->son[now];\n        }\n        cur = newNode(cur->son[now], tag);\n        cur->last = last;\n    }\n}\n\nint query(trie *cur, int val, int last) {\n    int ans = 0;\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        if (cur->son[now ^ 1] != NULL && cur->son[now ^ 1]->last >= last)\n            cur = cur->son[now ^ 1], ans += 1 << i;\n        else if (cur->son[now] != NULL && cur->son[now]->last >= last)\n            cur = cur->son[now];\n        else\n            break;\n    }\n    return ans;\n}\n\nstruct edge {\n    int to, nxt;\n} e[MAXN * 2];\n\nvoid addEdge(int from, int to) {\n    static int t;\n    e[t].to = to, e[t].nxt = p[from], p[from] = t++;\n}\n\nvoid dfs1(const int &now) {\n    static int times = 1;\n    in[now] = times++;\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (!in[to]) {\n            insert(root[times - 1][0], newNode(root[times][0], 0), val[to],\n                   times, 0);\n            dfs1(to);\n        }\n    }\n    out[now] = times;\n}\n\nvoid dfs2(int now, int d) {\n    depth[now] = d;\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (!depth[to]) {\n            fa[to][0] = now;\n            insert(root[now][1], newNode(root[to][1], 1), val[to], d + 1, 1);\n            dfs2(to, d + 1);\n        }\n    }\n}\n\nvoid getFa() {\n    for (int j = 1; (1 << j) <= n; j++)\n        for (int i = 1; i <= n; i++)\n            if (fa[i][j - 1]) fa[i][j] = fa[fa[i][j - 1]][j - 1];\n}\n\nint lca(int a, int b, int i = 0) {\n    if (depth[a] < depth[b]) swap(a, b);\n    for (; (1 << i) <= depth[a]; i++)\n        ;\n    for (int j = i - 1; j >= 0; j--)\n        if (depth[a] - depth[b] >= (1 << j)) a = fa[a][j];\n    if (a == b) return a;\n    for (int j = i - 1; j >= 0; j--)\n        if (fa[a][j] && fa[a][j] != fa[b][j]) a = fa[a][j], b = fa[b][j];\n    return fa[a][0];\n}\n\nint main() {\n    read(n), read(q);\n    for (int i = 1; i <= n; i++) read(val[i]);\n    memset(p, -1, sizeof(p));\n    for (int i = 1; i <= n - 1; i++) {\n        read(u), read(v);\n        addEdge(u, v), addEdge(v, u);\n    }\n    initRoot();\n    dfs1(1);\n    dfs2(1, 1);\n    getFa();\n    for (int i = 1; i <= q; i++) {\n        read(opt);\n        if (opt == 1) {\n            read(u), read(z);\n            printf(\"%d\\n\", query(root[out[u] - 1][0], z, in[u]));\n        } else {\n            read(u), read(v), read(z);\n            int tmp = lca(u, v);\n            printf(\"%d\\n\", max(query(root[u][1], z, depth[tmp]),\n                               query(root[v][1], z, depth[tmp])));\n        }\n    }\n    return 0;\n}\n```\n## C JSOI2015 字符串树\n### Description\n[P6088 JSOI2015 字符串树](https://www.luogu.com.cn/problem/P6088)\n### Solution\n$dfs$ 时，对每个点，在其父亲版本的基础上建立可持久化 $trie$ 树。令$cnt_i$ 表示从根到节点到 $i$ 有多少字符串以 $S$ 为前缀。显然，答案具有可加性，$u,v$ 之间以 $S$ 为前缀的字符串数目为 $cnt_u + cnt_v - 2*cnt_{lca(u,v)}$，查询的时候求一下 $lca$ 即可。\n### Code\n```cpp JSOI2015 字符串树\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nint n, m, u, v;\nchar s[11];\nint p[MAXN], fa[MAXN][17], depth[MAXN];\nvoid read(int& x, int f = 1) {\n    char ch = getchar();\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\nstruct trie {\n    trie* son[26];\n    int cnt;\n    trie() {\n        for (int i = 0; i < 26; i++) son[i] = NULL;\n        cnt = 0;\n    }\n} node[MAXN * 10], *root[MAXN];\ntrie* newNode(trie*& cur) {\n    static int cntNode;\n    return cur = &node[cntNode++];\n}\nstruct edge {\n    int to, nxt;\n    string s;\n} e[MAXN * 2];\nvoid addEdge(int from, int to, const string& s) {\n    static int t;\n    e[t].s = s, e[t].to = to, e[t].nxt = p[from], p[from] = t++;\n}\nvoid build(trie* pre, trie* cur, const string& s) {\n    for (int i = 0; i < s.size(); i++) {\n        int to = s[i] - 'a';\n        if (pre != NULL) {\n            for (int j = 0; j < 26; j++) cur->son[j] = pre->son[j];\n            pre = pre->son[to];\n        }\n        cur = newNode(cur->son[to]);\n        cur->cnt = (pre != NULL ? pre->cnt : 0) + 1;\n    }\n}\nint query(trie* cur, const string& s) {\n    for (int i = 0; i < s.size(); i++) {\n        int to = s[i] - 'a';\n        if (cur->son[to] != NULL)\n            cur = cur->son[to];\n        else\n            return 0;\n    }\n    return cur->cnt;\n}\nvoid dfs(const int& now, int d) {\n    depth[now] = d;\n    for (int i = p[now]; ~i; i = e[i].nxt) {\n        int to = e[i].to;\n        if (!depth[to] && to != 1) {\n            fa[to][0] = now;\n            build(root[now], newNode(root[to]), e[i].s);\n            dfs(to, d + 1);\n        }\n    }\n}\nvoid getFa() {\n    for (int j = 1; (1 << j) <= n; j++)\n        for (int i = 1; i <= n; i++)\n            if (fa[i][j - 1]) fa[i][j] = fa[fa[i][j - 1]][j - 1];\n}\nint lca(int a, int b, int i = 0) {\n    if (depth[a] < depth[b]) swap(a, b);\n    for (; (1 << i) <= depth[a]; i++);\n    for (int j = i - 1; j >= 0; j--)\n        if (depth[a] - depth[b] >= (1 << j)) a = fa[a][j];\n    if (a == b) return a;\n    for (int j = i - 1; j >= 0; j--)\n        if (fa[a][j] && fa[a][j] != fa[b][j]) a = fa[a][j], b = fa[b][j];\n    return fa[a][0];\n}\nint main() {\n    memset(p, -1, sizeof(p));\n    read(n);\n    for (int i = 1; i <= n - 1; i++) {\n        read(u), read(v), scanf(\"%s\", s);\n        addEdge(u, v, s), addEdge(v, u, s);\n    }\n    newNode(root[1]);\n    dfs(1, 0);\n    getFa();\n    read(m);\n    for (int i = 1; i <= m; i++) {\n        read(u), read(v), scanf(\"%s\", s);\n        printf(\"%d\\n\", query(root[u], s) + query(root[v], s) -\n                           2 * query(root[lca(u, v)], s));\n    }\n    return 0;\n}\n```\n## C HEOI2013 ALO\n### Description\n[P4098 HEOI2013 ALO](https://www.luogu.com.cn/problem/P4098)\n### Solution\n首先建立可持久化 $trie$ 树。对于 $a_i$，设左边第一个比它大的数下标为 $l_1$, 左边第二个比它大的数下标为 $l_2$；右边第一个比它大的数下标为 $r_1$, 左边第二个比它大的数下标为 $r_2$。显然，能让 $a_i$ 为次大值的最大区间为 $[l_1+1,r_2-1]$ 和 $[l_2+1,r_1-1]$。只需预处理出 $l_{1,2}$ 和 $r_{1,2}$，接下来在可持久化 $trie$ 上贪心地求最大值即可。\n\n考虑如何求 $l_{1,2}$ 和 $r_{1,2}$。将 $a_1$ 到  $a_n$ 按从大到小排序，同时记录原来的下标 $b_i$。排序后按顺序将 $b_i$ 插入 $set$ 中。易知 $set$ 中任意元素 $b_k$ 对应值 $a_{b_k}$一定大于当前位置 $b_i$ 对应值 $a_{b_i}$(题目约定数组 $a$ 中的元素不重复), 且 $set$ 已按下标排好序，用 lower_bound 和 upper_bound 容易求出当前下标 $b_i$ 的前驱和后继。\n\n\n### Code\n```cpp HEOI2013 ALO\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int MAXN = 5e4 + 5;\nconst int BIT = 30;\nint n, a[MAXN], b[MAXN], l[MAXN][3], r[MAXN][3];\n\ntemplate <class T>\nvoid read(T &x, int f = 1) {\n    char ch = getchar();\n    x = 0;\n    while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct trie {\n    trie *son[2];\n    int last;\n    trie() {\n        son[0] = son[1] = NULL;\n        last = 0;\n    }\n} * root[MAXN];\n\nvoid insert(int id) {\n    trie *cur = root[id] = new trie, *pre = root[id - 1];\n    for (int i = BIT; ~i; i--) {\n        int now = (a[id] >> i) & 1;\n        if (pre != NULL) {\n            cur->son[now ^ 1] = pre->son[now ^ 1];\n            pre = pre->son[now];\n        }\n        cur->son[now] = new trie;\n        cur = cur->son[now];\n        cur->last = id;\n    }\n}\n\nint query(trie *cur, int last, int val) {\n    int ans = 0;\n    for (int i = BIT; ~i; i--) {\n        int now = (val >> i) & 1;\n        if (cur->son[now ^ 1] != NULL && cur->son[now ^ 1]->last >= last)\n            cur = cur->son[now ^ 1], ans |= 1 << i;\n        else\n            cur = cur->son[now];\n    }\n    return ans;\n}\n\nbool cmp(const int &x, const int &y) { return a[x] > a[y]; }\n\nint main() {\n    read(n);\n    root[0] = new trie;\n    for (int i = 1; i <= n; i++) read(a[i]), insert(i), b[i] = i;\n    sort(b + 1, b + n + 1, cmp);\n    set<int> s;\n    set<int>::iterator it;\n    s.insert(-2), s.insert(-1), s.insert(n + 1), s.insert(n + 2);\n    for (int i = 1; i <= n; i++) {\n        s.insert(b[i]);\n        it = s.lower_bound(b[i]);\n        l[b[i]][1] = max(0, *--it);\n        l[b[i]][2] = max(0, *--it);\n        it = s.upper_bound(b[i]);\n        r[b[i]][1] = min(n + 1, *it);\n        r[b[i]][2] = min(n + 1, *++it);\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++)\n        ans = max(ans, max(query(root[r[i][1] - 1], l[i][2] + 1, a[i]),\n                           query(root[r[i][2] - 1], l[i][1] + 1, a[i])));\n    printf(\"%d\", ans);\n    return 0;\n}\n```\n\n","tags":["trie"],"categories":["数据结构","trie"]},{"title":"JSOI 2007 合金","url":"/2020/07/18/alloy/","content":"# 合金\n  - [题目链接](https://www.luogu.com.cn/problem/P4049)\n  - 计算几何/凸包\n  - 图论/Floyed\n<!-- more -->\n# Description\n有 m 种原材料由铁、铝、锡组成的合金，不同合金有不同铁铝锡的比重 $a_i$, $b_i$, $c_i$。将每种原材料取出一定量，经过融解、混合，得到新的合金。现需要 $n$ 种合金，铁铝锡的比重为 $d_i$, $e_i$, $f_i$。求最少需要的原材料种数。\n# Solution\n设有合金 $(a_1, b_1, c_1)$ 与 $(a_2, b_2, c_2)$，欲合成合金 $(d, e, f)$。\n则有\n$$\n\\left\\{\n\\begin{array}{lr}\nk_1 (a_1, b_1, c_1)+k_2 (a_2, b_2, c_2)=(d, e, f)\\\\\nk_1 (1-b_1-a_1)+k_2 (1-b_2-a_2)=1-d-e\\\\\n\\end{array}\n\\right.\n$$\n如果只考虑2维，那么有\n$$\n\\left\\{\n\\begin{array}{lr}\nk_1 (a_1, b_1)+k_2 (a_2, b_2)=(d, e)\\\\\nk_1+k_2+k_1 (-b_1-a_1)+k_2 (-b_2-a_2)=1-d-e\\\\\n\\end{array}\n\\right.\n$$\n可得\n$$\n\\left\\{\n\\begin{array}{lr}\nk_1 (a_1, b_1)+k_2 (a_2, b_2)=(d, e)\\\\\nk1 + k2 = 1\\\\\n\\end{array}\n\\right.\n$$\n即\n- 若 2 种合金 $(a_1, b_1, c_1)$，$(a_2, b_2, c_2)$ 能合成合金 $(d, e, f)$，则 $(a_1, b_1)$、$(a_2, b_2)$、$(d, e)$ 三点共线，且点 $(d, e)$ 位于两点之间。\n- 若有 3 种合金，对应三个点，则先连接其中两点，两点所连线段上的点都可以被表示；再将线段上的点与第三个点连接，所连的线段上的点均可被选取。即三点所围的点都能被表示出来。\n\n于是问题转化为求原材料合金对应二维坐标的凸包(点最少)，该凸包能否将所需要的材料对应二维坐标的凸包给围住。\n对于两个坐标，如果所需要的材料对应的坐标均在所连向量的左侧(通过向量外积判断)，则两点连边单向边，长度为 1。通过弗洛伊德最小环可得到最少的原料数。\n\n注意：\n- 若所需材料的坐标在原材料坐标所连直线上(此时向量外积为0)，则需通过向量内积判断是否在原材料坐标所连线段上\n- 注意比较时的精度 $epsilon$\n\n\n# Code\n```cpp 合金\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 505;\nconstexpr double EPSILON = 1e-15;\n\nstruct Vector {\n    Vector() = default;\n    Vector(double _x, double _y) : x(_x), y(_y) {}\n\n    friend inline double operator* /*×*/(const Vector& a, const Vector& b) {\n        return a.x * b.y - a.y * b.x; //向量外积\n    }\n\n    friend inline Vector operator-(const Vector& a, const Vector& b) {\n        return Vector(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline double dotProduct(const Vector& a, const Vector& b) {\n        return a.x * b.x + a.y * b.y; //向量内积\n    }\n\n    double x = .0, y = .0;\n} mat[MAXN], pro[MAXN];  // material and product\n\nint n, m, ans(0x3f3f3f3f), dis[MAXN][MAXN];\n\ninline void init() {\n    memset(dis, 0x3f, sizeof(dis));\n    for (int i = 1; i <= m; i++)\n        for (int j = 1; j <= m; j++) {\n            bool connect = true;\n            for (int k = 1; k <= n; k++) {//判断是否能作为凸包的边\n                double cross = (mat[j] - mat[i]) * (pro[k] - mat[i]);\n                double dot = dotProduct(mat[j] - pro[k], mat[i] - pro[k]);\n                if (cross < -EPSILON || (abs(cross) < EPSILON && dot > EPSILON))\n                    connect = false;\n            }\n            if (connect) dis[i][j] = 1;\n        }\n}\n\ninline void floyed() { //floyed求最小环\n    for (int k = 1; k <= m; k++)\n        for (int i = 1; i <= m; i++)\n            for (int j = 1; j <= m; j++) {\n                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);\n            }\n    for (int i = 1; i <= m; i++) ans = min(ans, dis[i][i]);\n    cout << (ans == 0x3f3f3f3f ? -1 : ans) << endl;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> m >> n;\n\n    double a, b, c;\n    for (int i = 1; i <= m; i++) {\n        cin >> a >> b >> c;\n        mat[i] = Vector(a, b);\n    }\n    for (int i = 1; i <= n; i++) {\n        cin >> a >> b >> c;\n        pro[i] = Vector(a, b);\n    }\n    init();\n    floyed();\n    return 0;\n}\n```","tags":["凸包","Floyed"],"categories":["图论","计算几何","最短路","凸包","Floyed"]},{"title":"国家集训队 种树","url":"/2020/07/17/zhong-shu/","content":"# 国家集训队 种树\n  - [题目链接](https://www.luogu.com.cn/problem/P1792)\n  - 数据结构/优先队列/链表\n  - STL/list\n  - 贪心\n<!-- more -->\n# Description\n有一个环形广场上有 $n$ 个种树位置，顺时针编号 1 到 $n$。每个位置有美观度 $A_i$，选取不相邻的 $m$ 个位置种树，求最大美观度和。\n# Solution\n思路同[APIO/CTSC 2007 数据备份](http://shaun-shane.vercel.app/2020/07/17/shu-ju-bei-fen/)，只不过需通过环形链表解决，且当 $n / 2 < m$ 时无解。\n# Code\n## 环形双向链表\n与非环形双向链表不同，$head$ 与 $tail$ 不用作为虚拟节点。链表建立时 $tail->next = head$ 且 $head->prev = tail$。删除和插入操作与非双向链表类似。\n```cpp 环形双向链表\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 2e5 + 5;\n\nint n, m, a[MAXN], cnt, ans;\n\nstruct ListNode {\n    ListNode() = default;\n    bool operator<(const ListNode& other) const {\n        return this->data == other.data ? this->id < other.id : this->data < other.data;\n    }\n    ListNode *prev = NULL, *next = NULL, *cur = NULL;\n    int data = 0, id = -1;\n};\nmap<int, bool> deleted;\npriority_queue<ListNode> q;\n\nstruct CycleList {\n    CycleList() = default;\n\n    ListNode* insert(int data, int id) {\n        auto newNode = new ListNode();\n        newNode->data = data, newNode->id = id, newNode->cur = newNode;\n        if (head == NULL) head = tail = newNode;\n        newNode->prev = tail, tail->next = newNode, tail = newNode;\n        tail->next = head, head->prev = tail;\n        return newNode;\n    }\n\n    ListNode* erase(ListNode* cur) {\n        auto prev = cur->prev, next = cur->next;\n        int data = prev->data + next->data - cur->data;\n        deleted[prev->id] = deleted[cur->id] = deleted[next->id] = true;\n        \n        auto newNode = new ListNode();\n        newNode->data = data, newNode->id = cnt++, newNode->cur = newNode;\n        prev->prev->next = newNode, newNode->prev = prev->prev;\n        next->next->prev = newNode, newNode->next = next->next;\n        return newNode;\n    }\n\n    ListNode *head = NULL, *tail = NULL;\n} lst;\n\nvoid calcA(int tot = 0) {\n    while (!q.empty() && tot < m) {\n        auto cur = q.top();\n        q.pop();\n        if (deleted[cur.id]) continue;\n        ans += cur.data, tot++;\n        auto newNode = lst.erase(cur.cur);\n        q.push(*newNode);\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    if (n / 2 < m) return printf(\"Error!\\n\"), 0;\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", a + i);\n        auto newNode = i == n - 1 ? lst.insert(a[i], cnt++) : lst.insert(a[i], cnt++);\n        q.push(*newNode);\n    }\n    calcA();\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```\n## STL 环形链表\n$STL$ 的 $list$ 是环形链表。list.end() 的下一个迭代器是 list.begin()，list.begin() 的上一个迭代器是 list.end()。删除过程中，需特判当前迭代器是否为 list.end()，若是，则选取下一个迭代器进行删除。另外需注意：由于最后一次删除操作可能导致 $list$ 为空，要特判一下。\n```cpp STL 环形链表\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAXN = 2e5 + 5;\n\nint n, m, a[MAXN], ans, cnt;\n\nstruct ListNode {\n    ListNode() = default;\n    ListNode(int _data, int _id) : data(_data), id(_id) {}\n    bool operator<(const ListNode &other) const {\n        return this->data == other.data ? this->id < other.id : this->data < other.data;\n    }\n    int data = 0, id = -1;\n    list<ListNode>::iterator itr;\n};\nlist<ListNode> lst;\npriority_queue<ListNode> q;\nmap<int, bool> deleted;\n\ninline void calcA(int tot = 0) {\n    while (!q.empty() && tot < m) {\n        auto cur = q.top();\n        q.pop();\n        if (deleted[cur.id]) continue;\n        ans += cur.data, tot++;\n        if (tot == m) break;\n        //将相邻三个节点删除 并用新节点替换 带反悔贪心\n        int data(0);\n        auto itr = --cur.itr;\n        if (itr == lst.end()) --itr;\n\n        data += itr->data, deleted[itr->id] = true, itr = lst.erase(itr);\n        if (itr == lst.end()) ++itr;\n\n        data -= itr->data, deleted[itr->id] = true, itr = lst.erase(itr);\n        if (itr == lst.end()) ++itr;\n\n        if (itr == lst.end()) cout << \"err\" << endl;\n        data += itr->data, deleted[itr->id] = true, itr = lst.erase(itr);\n        //将相邻三个节点删除 并用新节点替换 带反悔贪心\n        auto newNode = ListNode(data, cnt++);\n        newNode.itr = lst.insert(itr, newNode);\n        q.push(newNode);\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    if (n / 2 < m) return printf(\"Error!\\n\"), 0;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", a + i);\n        auto newNode = ListNode(a[i], cnt++);\n        newNode.itr = lst.insert(lst.end(), newNode); //末尾插入\n        q.push(newNode); //加入优先队列\n    } \n    calcA(); //计算美观度sigma_Ai\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["贪心","优先队列","链表"],"categories":["数据结构","STL","链表","贪心","优先队列","list"]},{"title":"APIO/CTSC 2007 数据备份","url":"/2020/07/17/shu-ju-bei-fen/","content":"# 数据备份\n  - [题目链接](https://www.luogu.com.cn/problem/P3620)\n  - 数据结构/优先队列/链表\n  - STL/list\n  - 贪心\n<!-- more -->\n# Description\n有 $N$ 座办公楼位于同一条街上，已知每座办公楼距离大街起点的距离。现要用 $K$ 条网络电缆将办公楼连接，且任意一个办公楼都属于唯一配对组(即连接的 $2K$ 个办公楼一定是相异的)。求 $K$ 条网络电缆最小的长度总和。\n# Solution\n容易发现，最优解中每两个配对的办公楼一定是相邻的。于是先求出两个相邻办公楼之间的距离，记为 $D_1, D_2, D_3, ..., D_{N - 1}$。于是问题可以转化为：从数列 $D$ 中选取不超过 $K$ 个不相邻的数，使它们的和最小。\n\n考虑贪心：\n  - 如果 $K=1$，答案显然是数列 D 中的最小值\n  - 如果 $K=2$，可以证明答案是以下两种情况之一：\n    - 选取 $D_i$，以及除了 $D_{i-1}, D_i, D_{i+1}$ 之外其他数中的最小值\n    - 选取最小值 $D_i$左右两侧的两个数，即 $D_{i-1}$ 和 $D_{i+1}$\n    - 即最优解中，最小值左右两侧的数要么选，要么都不选\n  - 为防止选取局部最优解，可以先选取数列 $D$ 中的最小值 $D_i$，然后把 $D_{i-1}, D_i, D_{i+1}$ 删除，把 $D_{i-1}+D_{i+1}-D_i$ 插入到数列 $D$ 中之前执行删除的位置。这样如果之后选了 $D_{i-1}+D_{i+1}-D_i$，相当于没有选 $D_i$，换上了 $D_{i-1}$ 和 $D_{i+1}$。\n\n于是可建立一个初始有 $N-1$ 个节点的链表，链表节点记录数值 $D_i$，节点编号 $Id_i$，以及链表节点指针或对应的迭代器。再建立一个优先队列(小根堆)，将链表节点存入。K 次操作中，取出堆顶的链表节点 $ListNode$，在链表中删除 $ListNode->prev$ 和 $ListNode->next$，并创建新节点(数值为 $ListNode->prev->data+ListNode->next->data-ListNode->data$)插入链表和优先队列。\n\n注意：为防止越界或简化边界情况判断，可以在链表起始和末尾插入极大值。\n\n# Code\n## 指针版双向链表\n```cpp 指针版双向链表\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 1e5 + 5;\nconstexpr LL INF = 1e18;\n\nLL n, k, dis[MAXN], ans, cnt;\n\nstruct ListNode {\n    ListNode() = default;\n    bool operator<(const ListNode &other) const {\n        return this->data == other.data ? this->id > other.id : this->data > other.data;\n    }\n    ListNode *prev = NULL, *next = NULL, *cur = NULL;\n    LL data = 0, id = -1;\n};\nmap<int, bool> deleted;\n\nstruct List {\n    List() { //构造函数\n        this->head = new ListNode(), this->tail = new ListNode();\n        this->head->next = this->tail;\n        this->tail->prev = this->head;\n    }\n\n    ListNode *insert(LL data) { //插入值，返回节点指针\n        ListNode *cur = new ListNode();\n        cur->data = data, cur->id = cnt++, cur->cur = cur;\n        tail->prev->next = cur, cur->prev = tail->prev;\n        cur->next = tail, tail->prev = cur;\n        return cur;\n    }\n\n    ListNode *erase(ListNode *cur) { //删除节点，返回新节点指针\n        LL data = cur->prev->data + cur->next->data - cur->data;\n        ListNode *newListNode = new ListNode();\n        newListNode->cur = newListNode;\n        newListNode->data = data, newListNode->id = cnt++;\n\n        ListNode *prev = cur->prev, *next = cur->next;\n        prev->prev->next = newListNode, newListNode->prev = prev->prev;\n        next->next->prev = newListNode, newListNode->next = next->next;\n\n        deleted[prev->id] = deleted[next->id] = deleted[cur->id] = true;\n        return newListNode;\n    }\n\n    ~List() {}\n    ListNode *head = NULL, *tail = NULL;\n} lst;\n\npriority_queue<ListNode> q;\ninline void calcLen(int tot = 0) {\n    while (!q.empty() && tot < k) {\n        ListNode* cur = q.top().cur;\n        q.pop();\n        if (deleted[cur->id]) continue;\n        ans += cur->data, tot++;\n        ListNode *newListNode = lst.erase(cur);\n        q.push(*newListNode); //插入新节点\n    }\n}\n\nint main() {\n    scanf(\"%lld %lld\", &n, &k);\n    for (int i = 0; i < n; ++i) scanf(\"%lld\", dis + i);\n    lst.insert(INF); //防止越界 简化边界判断\n    for (int i = 0; i < n - 1; ++i) q.push(*lst.insert(dis[i + 1] - dis[i]));\n    lst.insert(INF); //防止越界 简化边界判断\n    calcLen(); //计算总长度\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```\n## STL list\n$STL$ 的 $list$ 为 环形双向链表, 本题中用到以下功能。\n- 通过 $iterator--$ 或 $iterator++$ 获得 $prev$ 或 $next$ 的迭代器。\n- insert() 成员函数在指定位置处插入值，并返回插入的元素所对应的的迭代器\n- erase() 成员函数对指定位置进行删除，返回删除的元素后一个位置的迭代器\n\n```cpp STL list\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 1e5 + 5;\nconstexpr LL INF = 1e15;\n\nLL n, k, dis[MAXN], ans, cnt;\n\nstruct ListNode {\n    ListNode() = default;\n    ListNode(LL _data, LL _id) : data(_data), id(_id) {}\n    bool operator<(const ListNode &other) const {\n        return this->data == other.data ? this->id > other.id : this->data > other.data;\n    }\n    LL data = INF, id = -1;\n    list<ListNode>::iterator itr;\n};\nlist<ListNode> lst;\npriority_queue<ListNode> q;\nmap<LL, bool> deleted;\n\ninline void calcLen(int tot = 0) {\n    while (!q.empty() && tot < k) {\n        auto cur = q.top();\n        q.pop();\n        if (deleted[cur.id]) continue;\n        ans += cur.data, tot++;\n        //删除\n        auto itr = cur.itr;\n        --itr; //得到cur->prev的迭代器\n        LL data = itr->data; deleted[itr->id] = true, itr = lst.erase(itr);\n        data -= itr->data, deleted[itr->id] = true, itr = lst.erase(itr);\n        data += itr->data, deleted[itr->id] = true, itr = lst.erase(itr);\n        //删除\n        auto newNode = ListNode(data, cnt++);\n        newNode.itr = lst.insert(itr, newNode);\n        q.push(newNode);\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> k;\n    for (int i = 0; i < n; ++i) cin >> dis[i];\n    lst.emplace_back(ListNode(INF, cnt++)); //防止越界 简化边界判断\n    for (int i = 0; i < n - 1; ++i) {\n        auto newNode = ListNode(dis[i + 1] - dis[i], cnt++);\n        newNode.itr = lst.insert(lst.end(), newNode); //末尾插入\n        q.push(newNode);\n    }\n    lst.emplace_back(ListNode(INF, cnt++)); //防止越界 简化边界判断\n    calcLen();\n    cout << ans << endl;\n    return 0;\n}\n```\n\n# 类似题目\n[种树](https://www.luogu.com.cn/problem/P1484)\n[国家集训队 种树](https://www.luogu.com.cn/problem/P1792)\n[BACKUP Backup Files](https://www.luogu.com.cn/problem/SP1553)\n","tags":["贪心","优先队列","链表"],"categories":["数据结构","STL","链表","贪心","优先队列","list"]},{"title":"AtCoder Beginner Contest 167","url":"/2020/07/17/atcoder-abc-167/","content":"[比赛链接](https://atcoder.jp/contests/abc167)\n<!-- more -->\n# D Teleporter\n## Description\n有 $n$ 个小镇，小镇 $i$ 有一个传送能传送到小镇 $j$。从小镇 1 开始传送，求出经过 $k$ 次传送最终到哪个小镇。\n## Solution\n可通过拓扑排序找到环(拓扑排序后入度 $in$ 不为 0 的节点为环上的节点)。然后处理出环长，起点到环的距离，即可判断传送 $k$ 次后所在的节点编号。\n## Code\n```cpp Teleporter\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 2e5 + 5;\n\nint n, to[MAXN], in[MAXN], step1[MAXN], step2[MAXN], vis[MAXN];\nLL k, len1, len2;\n\nvoid toposort() {\n    queue<int> q;\n    for (int i = 1; i <= n; i++)\n        if (!in[i]) q.push(i);\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        if(!(--in[to[cur]])) q.push(to[cur]);\n    }\n}\n\nvoid getLen(int cur) {\n    if (vis[cur]) return;\n    vis[cur] = 1;\n    if (in[cur]) step2[++len2] = to[cur], getLen(to[cur]);\n    else step1[++len1] = to[cur], getLen(to[cur]);\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++)\n        cin >> to[i], in[to[i]]++;\n    toposort(), getLen(1);\n    if (k <= len1) cout << step1[k] << endl;\n    else {\n        k = (k - len1) % len2 ? (k - len1) % len2 : len2;\n        cout << step2[k] << endl;\n    }\n    return 0;\n}\n```\n# E Colorful Blocks\n## Description\n有排列于一行的 $N$ 个格子，每个格子染上颜色 1 到 $M$，求至多有 $K$ 对颜色相同的相邻格子的染色方案数。\n## Solution\n  - $K$ 对相邻颜色相同，则相邻颜色相同的一对格子缩成一个格子，则有 $N−K$ 个格子颜色互不相同，其中一个格子颜色有 $M$ 种取法，其它格子只有 $M−1$ 种。\n  - 所以答案为 $\\Sigma C_{n-1}^im(m−1)^{n−i−1}$\n\n## Code\n```cpp Colorful Blocks\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 2e5 + 5;\nconstexpr LL Mod = 998244353;\n\nLL n, m, k, ans, fac[MAXN];\n\ninline void Init() {\n    fac[0] = 1;\n    for (LL i = 1; i < MAXN; i++) fac[i] = fac[i - 1] * i % Mod;\n}\n\ninline LL qpow(LL a, LL b) {  // a^b\n    LL res = 1;\n    while (b) {\n        if (b & 1) res = res * a % Mod;\n        a = a * a % Mod;\n        b >>= 1;\n    }\n    return res;\n}\n\ninline LL C(LL N, LL M) {\n    if (M > N || M < 0) return 0;\n    return fac[N] * qpow(fac[M], Mod - 2) % Mod * qpow(fac[N - M], Mod - 2) % Mod;\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n >> m >> k;\n    Init();\n    for (LL i = 0 ; i <= k; i++)\n        ans = (ans + C(n - 1, i) * m % Mod * qpow(m - 1, n - i - 1) % Mod) % Mod;\n    cout << ans << endl;\n    return 0;\n}\n```\n# F Bracket Sequencing\n## Description\n给出n个括号序列，总长不超过 $10^6$，能否用它们按照一定顺序拼接成一个合法的括号序列。\n## Solution\n  - 设 “(“ 的权为 1，“)” 的权为 -1。\n  - 对于一个合法括号序列，任意前缀和一定大于等于 0，且总权值和为 0(任意位置只允许有 “(“ 待配对，且整个序列 “(“ 和 “)” 数量相同)\n  - 首先用 $sum$ 记录 $n$ 个序列中权值的和，$sum$ 不为 0 一定不能拼接出合法序列\n  - 考虑一种最优的拼接方案，如果该方案不成功，则其他方案一定不会成功\n    - 显然，先选权值和大于等于零的，且任意前缀最小值大的先选\n    - 接下来取权值和小于零的。如果用前面的选取方法，可以举出反例\n  - 接下来推权值和小于零时一种方案更优的等价条件\n    - 设 $i$ 和 $j$ 是之后紧接着拼接的序列，它们之前已构造和为 $sum$ 的序列，那么这两个序列放入后满足任意前缀大于等于 0\n    - 先 $i$ 后 $j$，则 $sum+cnt_i+\\min pre_j>=0$\n    - 先 $j$ 后 $i$，则 $sum+cnt_j+\\min pre_i>=0$\n    - 设先放 $i$ 更优，有 $cnt_i−\\min pre_i >cnt_j−\\min pre_j$\n    - 于是先选 $cnt−\\min pre$ 大的更优\n\n## Code\n```cpp Bracket Sequencing\n#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int, int>\nvector<pii> ls, rs;\nbool check() {\n    int tot = 0;  //记前缀和\n    for (int i = 0; i < ls.size(); i++) {\n        if (tot + ls[i].first < 0) return false;\n        tot += ls[i].second;\n    }\n    for (int i = 0; i < rs.size(); i++) {\n        if (tot + rs[i].second - rs[i].first < 0) return false;\n        tot += rs[i].second;\n    }\n    return true;\n}\nbool cmp(const pii &a, const pii &b) {\n    if (a.first == b.first) return a.second > b.second;\n    return a.first > b.first;\n}\nint main() {\n    int n;\n    cin >> n;\n    int sum = 0;  //所有序列值总和\n    for (int i = 1; i <= n; i++) {\n        string s;\n        cin >> s;\n        int cnt = 0, min_pre = 1e9;\n        //对每个序列，cnt记任权值和，min_pre记任意前缀最小值\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '(')\n                ++cnt;\n            else\n                --cnt;\n            min_pre = min(min_pre, cnt);\n        }\n        sum += cnt;\n        if (cnt >= 0)\n            ls.push_back(make_pair(min_pre, cnt));\n        else\n            rs.push_back(make_pair(cnt - min_pre, cnt));\n    }\n    sort(ls.begin(), ls.end(), cmp);\n    sort(rs.begin(), rs.end(), cmp);\n    if (sum == 0 && check())\n        puts(\"Yes\");\n    else\n        puts(\"No\");\n    return 0;\n}\n```","tags":["contest"],"categories":["contest"]},{"title":"IOI2008 Island","url":"/2020/07/15/Island/","content":"# Island\n  - [题目链接](https://www.luogu.com.cn/problem/P4381)\n  - 图论/基环树/拓扑排序/树的直径\n  - 数据结构/单调队列\n  - 动态规划/环形DP/单调队列优化DP\n<!-- more -->\n# Solution\n## 基环树\n$N$ 个点 $N$ 条边, 即在树上加一条边构成一个恰好包含一个环的图，称为基环树。若不保证联通，则可能是若干个基环树构成的森林，简称基环森林。求解基环数相关问题的方法一般是先找出图中的环，把除环之外的部分按照若干棵树处理，再考虑与环一起计算。\n## 问题转换\n根据题意，整个公园是一个基环树森林的形态。一旦离开一个基环树则不能再返回，因此答案就是各基环树的直径之和。\n## 基环树直径\n基环树直径(最长链)可能有两种情况:\n  - 去掉环之后的某棵子树中，即求子树直径最大值\n  - 经过环最长简单路径\n\n求环可用拓扑排序，并在拓扑排序时 $dp$ 求出某棵基环树去掉环的直径最大值 $diameter[belong[node]]$， 以及子树中以环上节点为起点的最长链 $dis[nodeOnCircle]$。\n无向图进行拓扑排序， 节点入度为 1 则入队，拓扑排序后入度大于 1 则在环上。\n```cpp 拓扑排序\ninline void topoSort() {\n    queue<int> q;\n    for (int i = 1; i <= n; i++)\n        if (in[i] == 1) q.push(i);\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        for (auto& e : G[cur]) {\n            int to = e.first, w = e.second;\n            if (in[to] > 1) {\n                in[to]--;\n                diameter[belong[to]] = max(diameter[belong[to]], dis[to] + dis[cur] + w);\n                //dp求子树直径\n                dis[to] = max(dis[to], dis[cur] + w);\n                //dp求直径与以环结点为起点的子树中的最长链\n                if (in[to] == 1) q.push(to);\n            }\n        }\n    }\n}\n```\n经过环的最长简单路径: 设环上有两节点为 $S_i,S_j$，设它们在环上的最近距离为 $cycleDis(S_i,S_j)$，则最长路径为 $\\max(dis[S_i]+dis[S_j]+cycleDis(S_i,S_j))$。把环断开成链再复制一倍，用单调队列即可 $O(N)$ 解决。\n```cpp 单调队列\ninline void dp(int cur, int cnt, LL res) {\n    int st = cur, end = false, m(0);\n    res = diameter[cnt];\n    do {\n        end = true, in[cur] = 1;\n        tmpDis[++m] = dis[cur]; //根到节点的最长距离\n        for (auto& e : G[cur]) {\n            int to = e.first, w = e.second;\n            if (in[to] <= 1) continue;\n            end = false, cur = to;\n            cycleDis[m + 1] = cycleDis[m] + w;\n            break;\n        }\n    } while (!end);\n    for (auto& e : G[cur]) { //回到起点\n        int to = e.first, w = e.second;\n        if (to == st) cycleDis[m + 1] = cycleDis[m] + w;\n    }\n    for (int i = 1; i < m; i++) {//断环成链 复制一倍\n        tmpDis[i + m] = tmpDis[i]; //根到节点的最长距离\n        cycleDis[i + m] = cycleDis[m + 1] + cycleDis[i]; //用于求出环上两节点距离\n    }\n    deque<int> q;\n    q.push_back(1);\n    for (int i = 2; i < 2 * m; i++) {\n        while (!q.empty() && i - q.front() >= m) q.pop_front();\n        res = max(res, tmpDis[i] + tmpDis[q.front()] + cycleDis[i] -\n                           cycleDis[q.front()]);\n        //让tmpDis[q.front()] + cycleDis[q.front()]单调递增\n        while (!q.empty() &&\n               tmpDis[i] - cycleDis[i] >= tmpDis[q.back()] - cycleDis[q.back()])\n            q.pop_back(); //比当前值小则无效，直接弹出\n        q.push_back(i);\n    }\n    ans += res;\n}\n```\n# Code\n```cpp IOI Island\n#include <bits/stdc++.h>\nconstexpr int MAXN = 1e6 + 6;\nusing namespace std;\nusing LL = long long;\nusing Arr = LL[MAXN];\n\nLL n, ans;\nArr in, dis, diameter, belong, tmpDis, cycleDis;\nvector<pair<int, int> > G[MAXN];\n\ninline void bfs(int cur, int cnt) { //bfs处理出该节点属于哪一个基环树\n    queue<int> q;\n    q.push(cur);\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        belong[cur] = cnt;\n        for (auto& e : G[cur]) {\n            int to = e.first;\n            if (!belong[to]) q.push(to);\n        }\n    }\n}\n\ninline void topoSort() {\n    queue<int> q;\n    for (int i = 1; i <= n; i++)\n        if (in[i] == 1) q.push(i);\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        for (auto& e : G[cur]) {\n            int to = e.first, w = e.second;\n            if (in[to] > 1) {\n                in[to]--;\n                diameter[belong[to]] =\n                    max(diameter[belong[to]], dis[to] + dis[cur] + w);\n                dis[to] = max(dis[to], dis[cur] + w);\n                //dp求直径与以环结点为起点的子树中的最长链\n                if (in[to] == 1) q.push(to);\n            }\n        }\n    }\n}\n\ninline void dp(int cur, int cnt, LL res) {\n    int st = cur, end = false, m(0);\n    res = diameter[cnt];\n    do {\n        end = true, in[cur] = 1;\n        tmpDis[++m] = dis[cur]; //根到节点的最长距离\n        for (auto& e : G[cur]) {\n            int to = e.first, w = e.second;\n            if (in[to] <= 1) continue;\n            end = false, cur = to;\n            cycleDis[m + 1] = cycleDis[m] + w;\n            break;\n        }\n    } while (!end);\n    for (auto& e : G[cur]) { //回到起点\n        int to = e.first, w = e.second;\n        if (to == st) cycleDis[m + 1] = cycleDis[m] + w;\n    }\n    for (int i = 1; i < m; i++) {//断环成链 复制一倍\n        tmpDis[i + m] = tmpDis[i]; //根到节点的最长距离\n        cycleDis[i + m] = cycleDis[m + 1] + cycleDis[i]; //用于求出环上两节点距离\n    }\n    deque<int> q;\n    q.push_back(1);\n    for (int i = 2; i < 2 * m; i++) {\n        while (!q.empty() && i - q.front() >= m) q.pop_front();\n        res = max(res, tmpDis[i] + tmpDis[q.front()] + cycleDis[i] -\n                           cycleDis[q.front()]);\n        //让tmpDis[q.front()] + cycleDis[q.front()]单调递增\n        while (!q.empty() &&\n               tmpDis[i] - cycleDis[i] >= tmpDis[q.back()] - cycleDis[q.back()])\n            q.pop_back(); //比当前值小则无效，直接弹出\n        q.push_back(i);\n    }\n    ans += res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int u = 1, v, w; u <= n; u++) {\n        cin >> v >> w;\n        G[u].emplace_back(make_pair(v, w));\n        G[v].emplace_back(make_pair(u, w));\n        in[u]++, in[v]++;\n    }\n    int cnt(0);\n    for (int i = 1; i <= n; i++)\n        if (!belong[i]) bfs(i, ++cnt);\n    topoSort(); //拓扑排序求环\n    for (int i = 1; i <= n; i++)\n        if (in[i] > 1) dp(i, belong[i], 0);\n    cout << ans << endl;\n    return 0;\n}\n```\n","tags":["基环树"],"categories":["动态规划","数据结构","图论","环形DP","单调队列优化DP","基环树","拓扑排序","树的直径","单调队列"]},{"title":"凸包笔记 Convex Hull","url":"/2020/07/14/convex-hull/","content":"# Convex Hull\n<!-- more -->\n[参考资料](https://oi-wiki.org/geometry/convex-hull/)\n凸包常用的求法有 Graham 扫描法和 Andrew 算法。\nAndrew 算法求凸包:\n运用向量外积以及单调栈，[单调栈例题](https://www.luogu.com.cn/problem/SP1805)。\n向量类(重载了一些运算符)\n```cpp Vector\nstruct Vec2 {\n    Vec2() = default;\n    Vec2(int _x, int _y) : x(_x), y(_y) {}\n\n    friend inline bool operator<(const Vec2 &a, const Vec2 &b) {\n        return a.x == b.x ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline int operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x; //×\n    }\n    int x = 0, y = 0;\n} vec[MAXN], cov[MAXN];\n```\nAndrew 算法求凸包\n```cpp Andrew\ninline double convex(double res = 0) {\n    top = 0, up = 0;\n    sort(vec + 1, vec + n + 1);\n    for (int i = 1; i <= n; i++) {  //下凸壳\n        while (top > 1 && (cov[top] - cov[top - 1]) * (vec[i] - cov[top]) <= 0)\n            cov[top--] = Vec2(0, 0);\n        cov[++top] = vec[i];\n    }\n    up = top; //上凸壳起点\n    for (int i = n - 1; i > 0; i--) {  //上凸壳\n        while (top > up && (cov[top] - cov[top - 1]) * (vec[i] - cov[top]) <= 0)\n            cov[top--] = Vec2(0, 0);\n        cov[++top] = vec[i];\n    }\n    for (int i = 1; i < top; i++) {  //凸包中的所有点 求周长\n        Vec2 tmp = cov[i + 1] - cov[i];\n        res += sqrt(pow(tmp.x, 2) + pow(tmp.y, 2));\n    }\n    return res;\n}\n```\n\n# 例题\n## A UVA1303 Wall\n### Problem\n[题目链接](https://www.luogu.com.cn/problem/UVA1303)\n### Solution\n先求出给定点的凸包，再将凸包向外推 $L$。\n顶点处产生圆弧，各顶点圆弧对应圆周角总和为 $360°$(运用多边形内角和可推出)。\n答案为凸包长度加上一个半径为L的圆的周长。\n### Code\n```cpp Wall\n#include <bits/stdc++.h>\n#define PI acos(-1)\n\nusing namespace std;\n\nconstexpr int MAXN = 1e3 + 3;\n\nint testCase, n, L, top, up;\n\nstruct Vec2 {\n    int x, y;\n\n    Vec2() : x(0), y(0) {}\n    Vec2(int _x, int _y) : x(_x), y(_y) {}\n\n    friend inline bool operator<(const Vec2 &a, const Vec2 &b) {\n        return a.x == b.x ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline int operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x; //×\n    }    \n} vec[MAXN], cov[MAXN];\n\ninline double convex(double res = 0) {\n    top = 0, up = 0;\n    sort(vec + 1, vec + n + 1);\n    for (int i = 1; i <= n; i++) {  //下凸壳\n        while (top > 1 && (cov[top] - cov[top - 1]) * (vec[i] - cov[top]) <= 0)\n            cov[top--] = Vec2(0, 0);\n        cov[++top] = vec[i];\n    }\n    up = top; //上凸壳起点\n    for (int i = n - 1; i > 0; i--) {  //上凸壳\n        while (top > up && (cov[top] - cov[top - 1]) * (vec[i] - cov[top]) <= 0)\n            cov[top--] = Vec2(0, 0);\n        cov[++top] = vec[i];\n    }\n    for (int i = 1; i < top; i++) {  //凸包中的所有点\n        Vec2 tmp = cov[i + 1] - cov[i];\n        res += sqrt(pow(tmp.x, 2) + pow(tmp.y, 2));\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> testCase;\n    while (testCase--) {\n        cin >> n >> L;\n        for (int i = 1; i <= n; i++) cin >> vec[i].x >> vec[i].y;\n        double res = convex() + PI * 2 * L;\n        cout << setprecision(0) << fixed << res << endl;\n        if (testCase) cout << endl;\n    }\n    return 0;\n}\n```\n\n## B USACO5.1 圈奶牛Fencing the Cows\n### Problem\n[题目链接](https://www.luogu.com.cn/problem/P2742)\nAndrew 算法模板。\n\n## C UVA11626 Convex Hull\n### Problem\n[题目链接](https://www.luogu.com.cn/problem/UVA11626)\nAndrew 算法模板。\n\n## D UVA811 The Fortified Forest\n### Problem\n[题目链接](https://www.luogu.com.cn/problem/UVA11626)\n### Solution\n$N \\le 15$，考虑dfs枚举哪些树被砍掉，每个组合跑一次 $Andrew$ 算法进行比较(注意排序前需拷贝)。\n### Code\n```cpp The Fortified Forest\n#include <bits/stdc++.h>\n//旧版凸包写法\nusing namespace std;\n\nconstexpr int MAXN = 20;\n\nstruct Vector {\n    long long x = 0, y = 0, value = 0, len = 0;\n\n    Vector() = default;\n    Vector(long long _x, long long _y, long long _v, long long _l)\n        : x(_x), y(_y), value(_v), len(_l) {}\n\n    friend inline istream& operator>>(istream& is, Vector& obj) {\n        is >> obj.x >> obj.y >> obj.value >> obj.len;\n        return is;\n    }\n\n    friend inline bool operator<(const Vector& a, const Vector& b) {\n        return a.x == b.x ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vector operator-(const Vector& a, const Vector& b) {\n        return Vector(a.x - b.x, a.y - b.y, 0, 0);\n    }\n\n    friend inline long long operator*(const Vector& a, const Vector& b) {\n        return a.x * b.y - a.y * b.x;  //×\n    }\n} vec[MAXN], vec2[MAXN], vec3[MAXN];\n\nint n, testCase, ansSize, tmpSize;\ndouble ansLen, ansValue;\nvector<int> vecTmp, vecAns;\n\ninline void convex() {\n    int stk[MAXN] = {0}, used[MAXN] = {0}, top(0);\n    double res(0), value(0);\n    for (int i = 1; i <= tmpSize; i++) vec2[i] = vec3[i];\n    sort(vec2 + 1, vec2 + 1 + tmpSize);\n    for (auto &i : vecTmp) value += vec[i].value, res += vec[i].len;\n    stk[++top] = 1;\n    for (int i = 2; i <= tmpSize; i++) {  //下凸壳\n        while (top > 1 &&\n               (vec2[stk[top]] - vec2[stk[top - 1]]) * (vec2[i] - vec2[stk[top]]) <= 0)\n            used[stk[top--]] = false;\n        used[i] = true;\n        stk[++top] = i;\n    }\n    int tmp = top;\n    for (int i = tmpSize - 1; i > 0; i--) {  //上凸壳\n        if (!used[i]) {\n            while (top > tmp && (vec2[stk[top]] - vec2[stk[top - 1]]) *\n                                        (vec2[i] - vec2[stk[top]]) <= 0)\n                used[stk[top--]] = false;\n            used[i] = true;\n            stk[++top] = i;\n        }\n    }\n    for (int i = 1; i < top; i++) {\n        Vector tmp = vec2[stk[i + 1]] - vec2[stk[i]];\n        res -= sqrt(tmp.x * tmp.x + tmp.y * tmp.y);\n    }\n\n    if (res >= 0 && (value < ansValue || (value == ansValue && ansSize > vecTmp.size()))) {\n        ansLen = res;\n        ansValue = value;\n        ansSize = vecTmp.size();\n        vecAns = vecTmp;\n    }\n}\n\nvoid dfs(int cur) {\n    if (cur == n + 1) {\n        convex();\n        return;\n    }\n    vecTmp.emplace_back(cur);\n    dfs(cur + 1); //chopped\n    vecTmp.pop_back();\n\n    vec3[++tmpSize] = vec[cur];\n    dfs(cur + 1); //not chopped\n    --tmpSize;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    int cnt(0);\n    while (cin >> n && n) {\n        cnt++;\n        if (cnt > 1) cout << endl;\n        ansLen = 1e15, ansValue = 1e15, ansSize = 20, tmpSize  = 0;\n        vecTmp.clear(), vecAns.clear(), vecTmp.clear();\n        for (int i = 1; i <= n; i++) cin >> vec[i];\n        dfs(1);\n        cout.unsetf(ios_base::fixed);\n        cout << \"Forest \" << cnt << endl;\n        cout << \"Cut these trees:\";\n        for (auto &i : vecAns) cout << \" \" << i;\n        cout << endl;\n        cout << \"Extra wood: \" << setprecision(2) << fixed << ansLen << endl;\n    }\n    return 0;\n}\n```\n\n## E SHOI2012 信用卡凸包\n### Problem\n[题目链接](https://www.luogu.com.cn/problem/P3829)\n### Solution\n将矩形向内缩 1/4 圆半径 r，对其旋转后的顶点求凸包，再外推，加上一个半径为r的圆。\n### Code\n```cpp 信用卡凸包\n#include <bits/stdc++.h>\n//旧版凸包写法\nusing namespace std;\n\nconstexpr int MAXN = 1e5 + 5;\n\nstruct Vector {\n    double x = .0, y = .0;\n\n    Vector() = default;\n    Vector(double _x, double _y) : x(_x), y(_y) {}\n\n    friend inline bool operator<(const Vector& a, const Vector& b) {\n        return a.x == b.x ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vector operator-(const Vector& a, const Vector& b) {\n        return Vector(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline double operator*(const Vector& a, const Vector& b) {\n        return a.x * b.y - a.y * b.x;  //×\n    }\n} vec[MAXN];\n\nint cnt;\n\ninline double convex() {\n    int stk[MAXN] = {0}, used[MAXN] = {0}, top(0);\n    memset(used, 0, sizeof(used));\n    double res(.0);\n    sort(vec + 1, vec + cnt + 1);\n    stk[++top] = 1;\n    for (int i = 2; i <= cnt; i++) { //下凸壳\n        while (top > 1 &&\n               (vec[stk[top]] - vec[stk[top - 1]]) * (vec[i] - vec[stk[top]]) <= 0)\n            used[stk[top--]] = false;\n        used[i] = true;\n        stk[++top] = i;\n    }\n    int tmp = top;\n    for (int i = cnt - 1; i > 0; i--) { //上凸壳\n        if (!used[i]) {\n            while (top > tmp && (vec[stk[top]] - vec[stk[top - 1]]) *\n                                        (vec[i] - vec[stk[top]]) <= 0)\n                used[stk[top--]] = false;\n            used[i] = true;\n            stk[++top] = i;\n        }\n    }\n    for (int i = 1; i < top; i++) { //凸包中的所有点\n        Vector tmp = vec[stk[i + 1]] - vec[stk[i]];\n        res += sqrt(pow(tmp.x, 2) + pow(tmp.y , 2));\n    }   \n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    int n;\n    double a, b, r;\n    cin >> n >> a >> b >> r;\n    a = a / 2 - r, b = b / 2 - r;\n    for (int i = 1; i <= n; i++) {\n        double x, y, theta;\n        cin >> x >> y >> theta;\n        double len = sqrt(pow(a, 2) + pow(b, 2));\n        double alpha1 = atan2(a, b) + theta;\n        double alpha2 = atan2(a, -b) + theta;\n        double alpha3 = atan2(-a, -b) + theta;\n        double alpha4 = atan2(-a, b) + theta;\n        vec[++cnt] = Vector(x + len * cos(alpha1), y + len * sin(alpha1));\n        vec[++cnt] = Vector(x + len * cos(alpha2), y + len * sin(alpha2));\n        vec[++cnt] = Vector(x + len * cos(alpha3), y + len * sin(alpha3));\n        vec[++cnt] = Vector(x + len * cos(alpha4), y + len * sin(alpha4));\n    }\n    cout << setprecision(2) << fixed << convex() + acos(-1) * r * 2.0 << endl;\n    return 0;\n}\n```\n\n## F CERC2016 凸轮廓线 Convex Contour\n### Problem\n[题目链接](https://www.luogu.com.cn/problem/P3680)\n### Solution\n将正方形和矩形的顶点计入，圆不能仅将上下两个点计入求凸包。\n对于圆，可割圆法变为正1e4边形，将顶点计入求凸包。\n### Code\n```cpp Convex Contour\n#include <bits/stdc++.h>\n\n#define PI acos(-1)\n\nusing namespace std;\n\nconstexpr int MAXN = 2e5 + 5;\nconstexpr int M = 1e4;\n\nstruct Vec2 {\n    Vec2() = default;\n    Vec2(double _x, double _y) : x(_x), y(_y) {}\n\n    friend inline bool operator<(const Vec2& a, const Vec2& b) {\n        return a.x == b.x ? a.y < b.y : a.x < b.x;\n    }\n\n    friend inline Vec2 operator-(const Vec2& a, const Vec2& b) {\n        return Vec2(a.x - b.x, a.y - b.y);\n    }\n\n    friend inline double operator*(const Vec2& a, const Vec2& b) {\n        return a.x * b.y - a.y * b.x;  //×\n    }\n    double x = .0, y = .0;\n} vec[MAXN], cov[MAXN];\n\nint cnt;\nint top(0), up;\n\ninline double convex(double res = 0) {\n    sort(vec + 1, vec + cnt + 1);\n    for (int i = 1; i <= cnt; i++) {  //下凸壳\n        while (top > 1 && (cov[top] - cov[top - 1]) * (vec[i] - cov[top]) <= 0)\n            cov[top--] = Vec2(0, 0);\n        cov[++top] = vec[i];\n    }\n    up = top; //上凸壳起点\n    for (int i = cnt - 1; i > 0; i--) {  //上凸壳\n        while (top > up && (cov[top] - cov[top - 1]) * (vec[i] - cov[top]) <= 0)\n            cov[top--] = Vec2(0, 0);\n        cov[++top] = vec[i];\n    }\n    for (int i = 1; i < top; i++) {  //凸包中的所有点\n        Vec2 tmp = cov[i + 1] - cov[i];\n        res += sqrt(pow(tmp.x, 2) + pow(tmp.y, 2));\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    double n, st(0);\n    string s;\n    cin >> n >> s;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'S') {\n            vec[++cnt] = Vec2(st, 0);\n            vec[++cnt] = Vec2(st, 2);\n            vec[++cnt] = Vec2(st + 2, 0);\n            vec[++cnt] = Vec2(st + 2, 2);\n        } else if (s[i] == 'T') {\n            vec[++cnt] = Vec2(st, 0);\n            vec[++cnt] = Vec2(st + 2, 0);\n            vec[++cnt] = Vec2(st + 1, sqrt(3.0));\n        } else {\n            for (int j = 1; j <= M; j++) {\n                double theta = PI * 2 * j / M;\n                vec[++cnt] = Vec2(st + 1 + cos(theta), 1 + sin(theta));\n            }\n        }\n        st += 2;\n    }\n    cout << setprecision(14) << fixed << convex() / 2 << endl;\n    return 0;\n}\n```\n\n\n\n\n","tags":["凸包"],"categories":["计算几何","凸包"]},{"title":"国家集训队 小Z的袜子","url":"/2020/07/13/xiao-z-de-wa-zi/","content":"# 小Z的袜子\n  - [题目链接](https://www.luogu.com.cn/problem/P1494)\n  - 数据结构/分块/莫队\n\n<!-- more -->\n# Description\n多组询问求给定区间 $[l_i,r_i]$ 中取出相同两个数的概率。\n# Solution\n  - 设区间内某种颜色的数目为 $cnt_{color}$。\n  - 则概率为 $\\frac{\\Sigma{}cnt_{color}(cnt_{color} − 1)}{(r − l + 1)(r − l)}$。\n  - 将询问分块，一般取块的长度为 $sqrt(n)$ 或 $\\frac{n}{sqrt(2 * m / 3)}$。询问所在的块由询问左端点$l_i$ 决定。\n    ```cpp\n    read(n), read(m), Len = n / sqrt(m * 2.0 / 3);\n    for (int i = 1; i <= n; i++) cin >> c[i];\n    for (int i = 1; i <= m; i++) \n        read(Q[i].l), read(Q[i].r), Q[i].id = i, Q[i].block = Q[i].l / Len;\n    sort(Q + 1, Q + m + 1, cmp1);\n    ```\n  - 排序: 询问 $q_i$，$q_j$所在块相同则按其右端点排序，否则按块的编号升序排序。\n    ```cpp\n    struct query {\n        int l, r, id, block, x/*记录询问分子*/, y/*记录询问分母*/;\n    }Q[MAXN];\n\n    inline bool cmp1 (const query &a, const query &b) {\n      return (a.block== b.block) ? a.r < b.r : a.block < b.block;\n    }\n    inline bool cmp2 (const query &a, const query &b) { //按照原始顺序排序\n        return a.id < b.id;\n    }\n    ```\n  - 询问时，用 $l$，$r$ 记录上一次询问的位置(初始均为 1)，不断加减扩展即可(求的是 $\\Delta$)。\n\n# Code\n```cpp 小Z的袜子\n#include<bits/stdc++.h>\n#define int long long\n\nconstexpr int MAXN = 5e4 + 4;\n\nusing namespace std;\n\ntemplate <typename T> inline void read(T &x) {\n    int f = 1; x = 0; \n    char ch = getchar();\n    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nint n, m, Len, l, r, ans;\nint c[MAXN], cnt[MAXN];\nstruct query {\n    int l, r, id, block, x/*记录询问分子*/, y/*记录询问分母*/;\n}Q[MAXN];\n\ninline bool cmp1 (const query &a, const query &b) {\n    return (a.block== b.block) ? a.r < b.r : a.block < b.block;\n}\n\ninline bool cmp2 (const query &a, const query &b) { //按照原始顺序排序\n    return a.id < b.id;\n}\n\ninline int gcd(int x, int y) {\n    return !y ? x : gcd(y, x % y);\n}\n\nsigned main(){\n    read(n), read(m), Len = n / sqrt(m * 2.0 / 3);\n    for (int i = 1; i <= n; i++) read(c[i]);\n    for (int i = 1; i <= m; i++) \n        read(Q[i].l), read(Q[i].r), Q[i].id = i, Q[i].block = Q[i].l / Len;\n    sort(Q + 1, Q + m + 1, cmp1);\n    l = 1, r = 0;\n    for (int i = 1; i <= m; i++) {\n        while (r < Q[i].r) {\n            r++;\n            ans -= cnt[c[r]] * (cnt[c[r]] - 1);\n            cnt[c[r]]++;\n            ans += cnt[c[r]] * (cnt[c[r]] - 1);\n        }\n        while (r > Q[i].r) {\n            ans -= cnt[c[r]] * (cnt[c[r]] - 1);\n            cnt[c[r]]--;\n            ans += cnt[c[r]] * (cnt[c[r]] - 1);\n            r--;\n        }\n        while (l < Q[i].l) {\n            ans -= cnt[c[l]] * (cnt[c[l]] - 1);\n            cnt[c[l]]--;\n            ans += cnt[c[l]] * (cnt[c[l]] - 1);\n            l++;\n        }\n        while (l > Q[i].l) {\n            l--;\n            ans -= cnt[c[l]] * (cnt[c[l]] - 1);\n            cnt[c[l]]++;\n            ans += cnt[c[l]] * (cnt[c[l]] - 1);\n        }\n        Q[i].x = ans, Q[i].y = (Q[i].r - Q[i].l + 1) * (Q[i].r - Q[i].l);\n    }\n    sort(Q + 1, Q + m + 1, cmp2);\n    for (int i = 1; i <= m; i++)\n        if (Q[i].l == Q[i].r) puts(\"0/1\");\n        else printf(\"%lld/%lld\\n\", Q[i].x / gcd(Q[i].x, Q[i].y), Q[i].y / gcd(Q[i].x, Q[i].y));\n    return 0;\n}\n```\n","tags":["莫队"],"categories":["数据结构","分块","莫队"]},{"title":"USACO07DEC Best Cow Line G","url":"/2020/07/13/Best-Cow-Line-G/","content":"# Best Cow Line G\n  - [题目链接](https://www.luogu.com.cn/problem/P2870)\n  - 哈希/字符串哈希\n  - 二分答案\n  - 倍增\n\n<!-- more -->\n# Description\n给定长度为 $N$ 的字符串 $S$，每次可从 $S$ 的两端选取一个字符插入空字符串 $T$ 尾部。求字典序最小的字符串 $T$。\n# Solution\n考虑贪心：比较当前 $S$ 与 $reverse(S)$ 的字典序，如果 $S$ 的字典序小则从 $S$ 头部取出字符；否则从尾部取出。\n本题数据加强，逐位比较会被卡。需 $hash$ + 二分或倍增求出最长相同前缀子串，比较下一个位置的大小。\n注：字符串 $hash$(%) 不能直接用来比较字符串大小。\n# Code\n## 二分子串长度\n```cpp Best Cow Line G\n#include<bits/stdc++.h>\n\ntypedef unsigned long long uLL;\nconstexpr int MAXN = 5e5 + 5;\nconstexpr uLL base = 13331;\n\nusing namespace std;\n\nint n;\nuLL H1[MAXN], H2[MAXN], P[MAXN] = {1};\nchar s[MAXN], revs[MAXN];\nstring ans;\n\ninline void Init() {\n    for (int i = 1; i <= n; i++) P[i] = P[i - 1] * base;\n    for (int i = 1; i <= n; i++) H1[i] = H1[i - 1] * base + s[i] - 'A' + 1;\n    for (int i = 1; i <= n; i++) H2[i] = H2[i - 1] * base + revs[i] - 'A' + 1;\n}\n\ninline uLL getHash(int l, int r, uLL * H) {\n    return H[r] - H[l - 1] * P[r - l + 1];\n}\n\ninline bool compare(int l, int r) {\n    int L = 0, R = r - l, len = -1;\n    while (L <= R) {\n        int mid = (L + R) >> 1;\n        if (getHash(l, l + mid, H1) == getHash(n - r + 1, n - r + 1 + mid, H2)) \n            len = mid, L = mid + 1;\n        else R = mid - 1;\n    }\n    return s[l + len + 1] < s[r - len - 1];\n}\n\nint main(){\n    cin >> n;\n    for (int i = 1; i <= n; i++) \n        getchar(), s[i] = getchar(), revs[n - i + 1] = s[i];\n    Init();\n    int l = 1, r = n;\n    while (l <= r) {\n        if (compare(l, r)) ans += s[l], l++;\n        else ans += s[r], r--;\n    }\n    for (int i = 0; i < n; i++) {\n        if (i && i % 80 == 0) putchar('\\n');\n        putchar(ans[i]);\n    }\n    return 0;\n}\n```\n## 倍增\n```cpp Best Cow Line G\n#include <bits/stdc++.h>\n\n\ntypedef unsigned long long uLL;\nconstexpr uLL base = 13331;\nconstexpr int MAXN = 5e5 + 5;\n\nusing namespace std;\n\nint n;\nuLL H1[MAXN], H2[MAXN], P[MAXN] = {1};\nchar s[MAXN], revs[MAXN];\nstring ans;\n\ninline void Init() {\n    for (int i = 1; i <= n; i++) P[i] = P[i - 1] * base;\n    for (int i = 1; i <= n; i++) H1[i] = H1[i - 1] * base + s[i] - 'A' + 1;\n    for (int i = 1; i <= n; i++) H2[i] = H2[i - 1] * base + revs[i] - 'A' + 1;\n}\n\ninline uLL getHash(int l, int r, uLL* H) {\n    return H[r] - H[l - 1] * P[r - l + 1];\n}\n\ninline bool compare(int l, int r) {\n    int len = 1, Lst = l - 1, Rst = n - r;\n    while (len) {\n        if (Lst + len <= r &&\n            getHash(l, Lst + len, H1) == getHash(n - r + 1, Rst + len, H2)) {\n            Lst += len, Rst += len, len <<= 1;\n        } else\n            len >>= 1;\n    }\n    return s[Lst + 1] < revs[Rst + 1];\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        getchar(), s[i] = getchar(), revs[n - i + 1] = s[i];\n    Init();\n    int l = 1, r = n;\n    while (l <= r) {\n        if (compare(l, r)) ans += s[l], l++;\n        else ans += s[r], r--;\n    }\n    for (int i = 0; i < n; i++) {\n        if (i && i % 80 == 0) putchar('\\n');\n        putchar(ans[i]);\n    }\n    return 0;\n}\n```\n","tags":["字符串哈希","二分答案","倍增"],"categories":["哈希","字符串哈希","二分答案","倍增"]},{"title":"CF1312E Array Shrinking","url":"/2020/07/13/Array-Shrinking/","content":"# Array Shrinking\n  - [题目链接](https://www.luogu.com.cn/problem/CF1312E)\n  - 动态规划/区间DP\n\n<!-- more -->\n# Description\n给定一个数组，若数组中相邻的两个数相同(设都为 $a$)，则它们合并为一个数，其值为 $a + 1$。求合并后数组的最小长度。\n# Solution\n  - 考虑区间 $DP$, 设 $dp[l][r]$ 表示区间 $[l,r]$ 合并后的最小长度，并设 $w[l][r]$ 表示区间 $[l,r]$ 合并后的和\n  - 状态转移方程：$dp[l][r] = \\min(dp[l][r], dp[l][mid] + dp[mid + 1][r])$\n  - 若 $dp[l][mid] = dp[mid + 1][r] = 1$，并且 $w[l][mid] = w[mid + 1][r]$，则 $dp[l][r] = 1，w[l][r] = w[l][mid] + 1$\n\n# Code\n```cpp Array Shrinking\n#include<bits/stdc++.h>\n#define boost std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n\nusing namespace std;\nusing LL = long long;\n\nconstexpr int MAXN = 505;\nconstexpr LL M = 998244353;\n\nint n, a[MAXN], dp[MAXN][MAXN], w[MAXN][MAXN];\n\ntemplate <typename T> inline void read(T &x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nint main() {\n    boost;\n    cin >> n;\n    memset(dp, 0x3f, sizeof(dp));\n    for (int i = 1; i <= n; i++) cin >> a[i], dp[i][i] = 1, w[i][i] = a[i];\n    for (int len = 2; len <= n; len++)\n        for (int l = 1; l + len - 1 <= n; l++) {\n            int r = l + len - 1;\n            for (int mid = l; mid < r; mid++) {\n                dp[l][r] = min(dp[l][r], dp[l][mid] + dp[mid + 1][r]);\n                if (dp[l][mid] == 1 && dp[mid + 1][r] == 1 && w[l][mid] == w[mid + 1][r])\n                    dp[l][r] = 1, w[l][r] = w[l][mid] + 1;\n            }\n        }\n    cout << dp[1][n] << endl;\n    return 0;\n}\n```\n","tags":["区间DP"],"categories":["动态规划","区间DP"]},{"title":"P4098 ALO","url":"/2020/07/12/ALO/","content":"# ALO\n- [题目链接](https://www.luogu.com.cn/problem/P4098)\n- STL/set\n- 数据结构/trie/可持久化trie\n\n<!-- more -->\n# Description\n  任意选取区间 $[l,r]$ 并将区间次大值和区间内的某个数异或，求所有区间中异或值的最大值。\n# Solution\n  - 设 $a_i$ 为次大值，则只需求出 $a_i$ 为次大值的最大区间范围 $[l_i,r_i]$，通过可持久化trie贪心即可求出最大异或值\n  - 设位置i左边第一个大于 $a_i$ 的数的位置为 $l_1$， 第二个大于 $a_i$ 为 $l_2$\n  - 设位置i右边第一个大于 $a_i$ 的数的位置为 $r_1$， 第二个大于 $a_i$ 为 $r_2$\n  ![](/images/ALO1.png)\n  - 则可选择的区间为 $[l_1 + 1,r_2 − 1]$ 和 $[l_2 + 1,r_1 − 1]$，但其实只需求区间 $[l_2 + 1,r_2 − 1]$ 的异或最大值\n  ![](/images/ALO2.png)\n  ![](/images/ALO3.png)\n  - 求大于 $a_i$ 的数即求 $a_i$ 的后继，将原数组排序后一次插入平衡树(set)，则已插入的数值一定是 $a_i$ 的后继，只需以下标为key， lower_bound求出 $l_2,r_2$\n    ```cpp\n    struct node {\n        int key, pos;\n        inline bool operator < (const node &other) const {\n            return pos < other.pos;\n        }\n    }jewel[MAXN];\n\n    sort(jewel + 1, jewel + n + 1, cmp); //按key值从大到小插入元素\n    s.insert(jewel[1]); //按key值从大到小插入元素\n    for (int i = 2, L, R; i <= n; i++) {\n       l = r = s.lower_bound(jewel[i]); //求后继(后继已插入 按indices查找)\n\n        if (l != s.begin()) --l;\n        if (l != s.begin()) --l, L = l->pos + 1;\n        else L = 1;\n\n       if (r != s.end()) ++r;\n       if (r != s.end()) R = r->pos - 1;\n       else R = n;\n\n      res = max(res, search(root[R], jewel[i].key, L));\n      s.insert(jewel[i]);\n    }\n    ```\n\n# Code\n```cpp ALO\n#include <bits/stdc++.h>\nconstexpr int MAXN = 5e4 + 4;\nconstexpr int BIT = 30;\n\nusing namespace std;\n\ntemplate <typename T>\ninline void read(T &x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    while (!isdigit(ch)) f = (ch == '-') ? -1 : 1, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();\n    x *= f;\n}\n\nstruct node {\n    int key, pos;\n    inline bool operator < (const node &other) const {\n        return pos < other.pos;\n    }\n}jewel[MAXN];\n\ninline bool cmp(const node &a, const node &b) {\n    return a.key > b.key;\n}\n\nstruct Trie {\n    Trie *son[2];\n    int lst;\n}Tree[MAXN << 5], *root[MAXN];\nusing Node = Trie *;\n\ninline Node newNode(Node &root) {\n    static int nptr;\n    return root = &Tree[++nptr];\n}\n\ninline void insert(Node pre, Node root, int x, int index) {\n    for (int i = BIT - 1; ~i; i--) {\n        int tmp = (x >> i) & 1;\n        if (pre) root->son[tmp ^ 1] = pre->son[tmp ^ 1];\n        root->lst = max(root->lst, index);\n        root = newNode(root->son[tmp]), pre = pre ? pre->son[tmp] : NULL;\n    }\n    root->lst = max(root->lst, index);\n}\n\ninline int search(Node root, int x, int limit) {\n    int res = 0;\n    for (int i = BIT - 1; ~i; i--) {\n        int tmp = (x >> i) & 1;\n        if (root->son[tmp ^ 1] && root->son[tmp ^ 1]->lst >= limit)\n            res |= (1 << i), root = root->son[tmp ^ 1];\n        else root = root->son[tmp];\n    }\n    return res;\n}\n\nint main() {\n    int n, res(0);\n    set<node> s;\n    set<node>::iterator l, r;\n    read(n);\n    insert(Tree, newNode(root[0]), 0, 0);\n    for (int i = 1; i <= n; i++) {\n        read(jewel[i].key), jewel[i].pos = i;\n        insert(root[i - 1], newNode(root[i]), jewel[i].key, i);\n    }\n    sort(jewel + 1, jewel + n + 1, cmp); //按key值从大到小插入元素\n    s.insert(jewel[1]); //按key值从大到小插入元素\n    for (int i = 2, L, R; i <= n; i++) {\n        l = r = s.lower_bound(jewel[i]); //求后继(后继已插入 按indices查找)\n\n        if (l != s.begin()) --l;\n        if (l != s.begin()) --l, L = l->pos + 1;\n        else L = 1;\n\n        if (r != s.end()) ++r;\n        if (r != s.end()) R = r->pos - 1;\n        else R = n;\n\n        res = max(res, search(root[R], jewel[i].key, L));\n        s.insert(jewel[i]);\n    }\n    cout << res << endl;\n    return 0;\n}\n```\n","tags":["可持久化trie","set"],"categories":["数据结构","STL","set","trie","可持久化trie"]},{"title":"模拟退火笔记-Simulated Annealing","url":"/2020/07/11/mo-ni-tui-huo/","content":"Simulated Annealing\n<!-- more -->\n# A [JSOI2004]平衡点\n[题目链接](https://www.luogu.com.cn/problem/P1337)\n## Description\n![](/images/pexels1.png)\n## Solution\n\n## Code\n```cpp [JSOI2004]平衡点\n#include<bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAXN = 1e3 + 3;\nconstexpr double down = 0.996;\n\nint n;\npair<pair<int, int>, int> obj[MAXN];\ndouble x, y, Ep;\n\ninline double energy(double x, double y) { //重力势能越小越稳定\n    double E = 0;\n    for (int i = 0; i < n; i++) {\n        double dx = x - obj[i].first.first;\n        double dy = y - obj[i].first.second;\n        E += sqrt(dx * dx + dy * dy) * obj[i].second;\n    }\n    return E;\n}\n\ninline void SA() { //SimulateAnneal\n    double T = 3000;\n    while (T > 1e-14) {\n        double randx = x + (rand() * 2 - RAND_MAX) * T;\n        double randy = y + (rand() * 2 - RAND_MAX) * T;\n        double E = energy(randx, randy);\n        double delta = E - Ep;\n        if (delta < 0) { //E更小 答案更优\n            x = randx, y = randy, Ep = E;\n        }\n        else if (exp(-delta / T) * RAND_MAX > rand()) { //根据多项式概率接受\n            x = randx, y = randy;\n        }\n        T *= down;\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> obj[i].first.first >> obj[i].first.second >> obj[i].second;\n        x += obj[i].first.first, y += obj[i].first.second;\n    }\n    x /= n, y /= n, Ep = energy(x, y);\n    for (int i = 0; i < 4; i++) SA();\n    cout << setprecision(3) << fixed << x << \" \" << y << endl;\n    return 0;\n}\n```\n\n","tags":["模拟退火"],"categories":["模拟退火"]}]